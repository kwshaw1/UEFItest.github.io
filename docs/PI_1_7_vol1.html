

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Revision History &mdash; OTC-TCS Documentation Template 0.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon-48x48.png"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Documentation Guidelines" href="contribute/doc_guidelines.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> OTC-TCS Documentation Template
          

          
            
            <img src="_static/logo_white_200w.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction/index.html">Introduction to the Documentation Template Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="howtos/index.html">How-Tos</a><ul>
<li class="toctree-l2"><a class="reference internal" href="howtos/index.html#technical-notes">Technical Notes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="howtos/tech/pandocs-conversion.html">Pandocs Conversion Tutorial</a><ul>
<li class="toctree-l4"><a class="reference internal" href="howtos/tech/pandocs-conversion.html#scope">Scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/tech/pandocs-conversion.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/tech/pandocs-conversion.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/tech/pandocs-conversion.html#single-file-conversion">Single file Conversion</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/tech/pandocs-conversion.html#multiple-file-conversion-using-pandoc">Multiple file Conversion using Pandoc</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="howtos/tech/placeholder.html">Work in Progress</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="howtos/index.html#process-notes">Process Notes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="howtos/process/guide.html">Template Setup Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/guide.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/guide.html#setup-steps">Setup Steps</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="howtos/process/docbuild.html">Documentation Generation Guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/docbuild.html#documentation-overview">Documentation overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/docbuild.html#set-up-the-documentation-working-folders">Set up the documentation working folders</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/docbuild.html#installing-the-documentation-tools">Installing the documentation tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/docbuild.html#documentation-presentation-theme">Documentation presentation theme</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/docbuild.html#running-the-documentation-processors">Running the documentation processors</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/docbuild.html#publishing-content">Publishing content</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="howtos/process/set-up-ubuntu-on-windows.html">Set up Ubuntu on Windows for Sphinx development</a><ul>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/set-up-ubuntu-on-windows.html#install-the-windows-subsystem-for-linux">Install the Windows Subsystem for Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/set-up-ubuntu-on-windows.html#configure-your-ubuntu-distro-for-the-proxy">Configure your Ubuntu distro for the proxy</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/set-up-ubuntu-on-windows.html#set-up-your-ssh-key">Set up your ssh key</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/set-up-ubuntu-on-windows.html#install-dependencies">Install dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="howtos/process/set-up-ubuntu-on-windows.html#some-rules">Some Rules</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contribute/index.html">Contributing to the Project</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contribute/contribute_guidelines.html">Contribution Guidelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contribute/contribute_guidelines.html#licensing">Licensing</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/contribute_guidelines.html#developer-certification-of-origin-dco">Developer Certification of Origin (DCO)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contribute/contribute_guidelines.html#dco-sign-off-methods">DCO Sign-Off Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contribute/contribute_guidelines.html#prerequisites">Prerequisites</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contribute/doc_guidelines.html">Documentation Guidelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#headings">Headings</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#content-highlighting">Content Highlighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#lists">Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#multi-column-lists">Multi-column lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#file-names-and-commands">File names and Commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#internal-cross-reference-linking">Internal Cross-Reference Linking</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#non-ascii-characters">Non-ASCII Characters</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#code-and-command-examples">Code and Command Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="contribute/doc_guidelines.html#tabs-spaces-and-indenting">Tabs, spaces, and indenting</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Revision History</a></li>
<li class="toctree-l1"><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="#list-of-figures">List of Figures</a></li>
<li class="toctree-l1"><a class="reference internal" href="#list-of-tables">List of Tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="#introduction">1 Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">1.1 Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#organization-of-the-pei-cis">1.2 Organization of the PEI CIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conventions-used-in-this-document">1.3 Conventions Used in this Document</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-structure-descriptions">1.3.1 Data Structure Descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#procedure-descriptions">1.3.2 Procedure Descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instruction-descriptions">1.3.3 Instruction Descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ppi-descriptions">1.3.4 PPI Descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pseudo-code-conventions">1.3.5 Pseudo-Code Conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typographic-conventions">1.3.6 Typographic Conventions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#requirements">1.4 Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">1.5 Conventions used in this document</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#number-formats">1.5.1 Number formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binary-prefixes">1.5.2 Binary prefixes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id28">2 Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id29">2.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#design-goals">2.2 Design Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pre-efi-initialization-pei-phase">2.3 Pre-EFI Initialization (PEI) Phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pei-services">2.4 PEI Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pei-foundation">2.5 PEI Foundation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pei-dispatcher">2.6 PEI Dispatcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pre-efi-initialization-modules-peims">2.7 Pre-EFI Initialization Modules (PEIMs)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#peim-to-peim-interfaces-ppis">2.8 PEIM-to-PEIM Interfaces (PPIs)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#firmware-volumes">2.9 Firmware Volumes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#pei-services-table">3 PEI Services Table</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id30">3.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id31">3.2 PEI Services Table</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-services">3.2.1 EFI_PEI_SERVICES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#services-pei">4 Services - PEI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id68">4.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ppi-services">4.2 PPI Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installppi">InstallPpi()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reinstallppi">ReinstallPpi()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#locateppi">LocatePpi()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notifyppi">NotifyPpi()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#boot-mode-services">4.3 Boot Mode Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getbootmode">GetBootMode()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setbootmode">SetBootMode()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hob-services">4.4 HOB Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gethoblist">GetHobList()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#createhob">CreateHob()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#firmware-volume-services">4.5 Firmware Volume Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ffsfindnextvolume">FfsFindNextVolume()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ffsfindnextfile">FfsFindNextFile()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ffsfindsectiondata">FfsFindSectionData()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ffsfindsectiondata3">FfsFindSectionData3()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ffsfindfilebyname">FfsFindFileByName()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ffsgetfileinfo">FfsGetFileInfo()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ffsgetfileinfo2">FfsGetFileInfo2()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ffsgetvolumeinfo">FfsGetVolumeInfo()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#registerforshadow">RegisterForShadow()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pei-memory-services">4.6 PEI Memory Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installpeimemory">InstallPeiMemory()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocatepages">AllocatePages()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocatepool">AllocatePool()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copymem">CopyMem()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#freepages">FreePages()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setmem">SetMem()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#status-code-service">4.7 Status Code Service</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reportstatuscode">ReportStatusCode()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reset-services">4.8 Reset Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="#i-o-and-pci-services">4.9 I/O and PCI Services</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id99">5 PEI Foundation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id100">5.1 Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#prerequisites">5.1.1 Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processor-execution-mode">5.1.2 Processor Execution Mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#processor-execution-mode-in-ia-32-intel-architecture">5.1.2.1 Processor Execution Mode in IA-32 Intel<sup>®</sup> Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#processor-execution-mode-in-itanium-processor-family">5.1.2.2 Processor Execution Mode in Itanium<sup>®</sup> Processor Family</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-to-the-boot-firmware-volume-bfv-and-other-boot-critical-fvs">5.1.2.3 Access to the Boot Firmware Volume (BFV) and other boot-critical FVs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-to-the-boot-firmware-volume-in-ia-32-intel-architecture">5.1.2.4 Access to the Boot Firmware Volume in IA-32 Intel Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-to-the-boot-firmware-volume-in-itanium-processor-family">5.1.2.5 Access to the Boot Firmware Volume in Itanium Processor Family</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pei-foundation-entry-point">5.2 PEI Foundation Entry Point</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id101">5.2.1 PEI Foundation Entry Point</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pei-calling-convention-processor-binding">5.3 PEI Calling Convention Processor Binding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pei-services-table-retrieval">5.4 PEI Services Table Retrieval</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#x86">5.4.1 X86</a></li>
<li class="toctree-l3"><a class="reference internal" href="#x64">5.4.2 x64</a></li>
<li class="toctree-l3"><a class="reference internal" href="#itanium-processor-family-register-mechanism">5.4.3 Itanium Processor Family – Register Mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arm-processor-family-register-mechanism">5.4.4 ARM Processor Family – Register Mechanism</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arm-vector-table">5.4.4.1 ARM Vector Table</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#aarch64-processor-family-register-mechanism">5.4.5 AArch64 Processor Family – Register Mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#risc-v-processor-family-register-mechanism">5.4.6 RISC-V Processor Family – Register Mechanism</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pei-dispatcher-introduction">5.5 PEI Dispatcher Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ordering">5.6 Ordering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id110">5.6.1 Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-representation-and-notation">5.6.2 Requirement Representation and Notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pei-a-priori-file-overview">5.6.3 PEI <em>a priori</em> File Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pei-apriori-file-name-guid">PEI_APRIORI_FILE_NAME_GUID</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dispatch-behavior">5.6.3.1 Dispatch Behavior</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#firmware-volume-image-files">5.6.4 Firmware Volume Image Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#peim-dependency-expressions">5.6.5 PEIM Dependency Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types-of-dependencies">5.6.6 Types of Dependencies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dependency-expressions">5.7 Dependency Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id119">5.7.1 Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dependency-expression-instruction-set">5.7.1.1 Dependency Expression Instruction Set</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#push">PUSH</a></li>
<li class="toctree-l3"><a class="reference internal" href="#and">AND</a></li>
<li class="toctree-l3"><a class="reference internal" href="#or">OR</a></li>
<li class="toctree-l3"><a class="reference internal" href="#not">NOT</a></li>
<li class="toctree-l3"><a class="reference internal" href="#true">TRUE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#false">FALSE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#end">END</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dependency-expression-with-no-dependencies">5.7.2 Dependency Expression with No Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#empty-dependency-expressions">5.7.3 Empty Dependency Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dependency-expression-reverse-polish-notation-rpn">5.7.4 Dependency Expression Reverse Polish Notation (RPN)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dispatch-algorithm">5.8 Dispatch Algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id134">5.8.1 Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ordering-algorithm">5.8.1.1 Ordering Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-firmware-volume-support">5.8.1.2 Multiple Firmware Volume Support</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id135">5.8.2 Requirements</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#requirements-of-a-dispatching-algorithm">5.8.2.1 Requirements of a Dispatching Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#preventing-infinite-loops">5.8.2.3 Preventing Infinite Loops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controlling-processor-register-resources">5.8.2.4 Controlling Processor Register Resources</a></li>
<li class="toctree-l4"><a class="reference internal" href="#preserving-proper-dispatch-order">5.8.2.5 Preserving Proper Dispatch Order</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-available-memory">5.8.2.6 Using Available Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invoking-the-peim-s-entry-point">5.8.2.7 Invoking the PEIM’s Entry Point</a></li>
<li class="toctree-l4"><a class="reference internal" href="#knowing-when-dispatcher-tasks-are-finished">5.8.2.8 Knowing When Dispatcher Tasks Are Finished</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reporting-pei-core-location">5.8.2.9 Reporting PEI Core Location</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-dispatch-algorithm">5.8.3 Example Dispatch Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dispatching-when-memory-exists">5.8.4 Dispatching When Memory Exists</a></li>
<li class="toctree-l3"><a class="reference internal" href="#peim-dispatching">5.8.5 PEIM Dispatching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#peim-authentication">5.8.6 PEIM Authentication</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#architectural-ppis">6 Architectural PPIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id138">6.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#required-architectural-ppis">6.2 Required Architectural PPIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-master-boot-mode-ppi-required">EFI_PEI_MASTER_BOOT_MODE_PPI (Required)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-dxe-ipl-ppi-required">EFI_DXE_IPL_PPI (Required)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-dxe-ipl-ppi-entry">EFI_DXE_IPL_PPI.Entry()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-permanent-memory-installed-ppi-required">EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI (Required)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#optional-architectural-ppis">6.3 Optional Architectural PPIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-boot-in-recovery-mode-ppi-optional">EFI_PEI_BOOT_IN_RECOVERY_MODE_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-end-of-pei-phase-ppi-optional">EFI_PEI_END_OF_PEI_PHASE_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-reset-ppi-optional">EFI_PEI_RESET_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-reset2-ppi-optional">EFI_PEI_RESET2_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resetsystem">ResetSystem()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-progress-code-ppi-optional">EFI_PEI_PROGRESS_CODE_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-security2-ppi-optional">EFI_PEI_SECURITY2_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-security2-ppi-authenticationstate">EFI_PEI_SECURITY2_PPI.AuthenticationState()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-temporary-ram-support-ppi-optional">EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-temporary-ram-support-ppi-temporaryrammigration">EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI.TemporaryRamMigration ()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-temporary-ram-done-ppi-optional">EFI_PEI_TEMPORARY_RAM_DONE_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-temporary-ram-done-ppi-temporaryramdone">EFI_PEI_TEMPORARY_RAM_DONE_PPI.TemporaryRamDone ()</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#peims">7 PEIMs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id187">7.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#peim-structure">7.2 PEIM Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#peim-structure-overview">7.2.1 PEIM Structure Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relocation-information">7.2.2 Relocation Information</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#position-dependent-code">7.2.2.1 Position-Dependent Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#position-independent-code">7.2.2.2 Position-Independent Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relocation-information-format">7.2.2.3 Relocation Information Format</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#authentication-information">7.2.3 Authentication Information</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#peim-invocation-entry-point">7.3 PEIM Invocation Entry Point</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#efi-peim-entry-point2">7.3.1 EFI_PEIM_ENTRY_POINT2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#peim-descriptors">7.4 PEIM Descriptors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#peim-descriptors-overview">7.4.1 PEIM Descriptors Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-descriptor">EFI_PEI_DESCRIPTOR</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-notify-descriptor">EFI_PEI_NOTIFY_DESCRIPTOR</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-ppi-descriptor">EFI_PEI_PPI_DESCRIPTOR</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#peim-to-peim-communication">7.5 PEIM-to-PEIM Communication</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id188">7.5.1 Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-ppi-discovery">7.5.2 Dynamic PPI Discovery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ppi-database">7.5.2.1 PPI Database</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invoking-a-ppi">7.5.2.2 Invoking a PPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-resolution">7.5.2.3 Address Resolution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#additional-ppis">8 Additional PPIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id189">8.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#required-additional-ppis">8.2 Required Additional PPIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pci-configuration-ppi-required">8.2.1 PCI Configuration PPI (Required)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-pci-cfg2-ppi">EFI_PEI_PCI_CFG2_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-pci-cfg2-ppi-read">EFI_PEI_PCI_CFG2_PPI.Read()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-pci-cfg2-ppi-write">EFI_PEI_PCI_CFG2_PPI.Write()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-pci-cfg2-ppi-modify">EFI_PEI_PCI_CFG2_PPI.Modify()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-stall-ppi-required">EFI_PEI_STALL_PPI (Required)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-stall-ppi-stall">EFI_PEI_STALL_PPI.Stall()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-read-only-variable2-ppi">EFI_PEI_READ_ONLY_VARIABLE2_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-read-only-variable2-ppi-getvariable">EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-read-only-variable2-ppi-nextvariablename">EFI_PEI_READ_ONLY_VARIABLE2_PPI.NextVariableName</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#optional-additional-ppis">8.3 Optional Additional PPIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#efi-sec-platform-information-ppi-optional">EFI_SEC_PLATFORM_INFORMATION_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-sec-platform-information-ppi-platforminformation">EFI_SEC_PLATFORM_INFORMATION_PPI.PlatformInformation()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-sec-platform-information2-ppi-optional">EFI_SEC_PLATFORM_INFORMATION2_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-sec-platform-information2-ppi-platforminformation2">EFI_SEC_PLATFORM_INFORMATION2_PPI.PlatformInformation2()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-loaded-image-ppi">EFI_PEI_LOADED_IMAGE_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-sec-hob-data-ppi">EFI_SEC_HOB_DATA_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-sec-hob-data-ppi-gethobs">EFI_SEC_HOB_DATA_PPI.GetHobs()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recovery">8.3.4 Recovery</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-module-ppi">EFI_PEI_RECOVERY_MODULE_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-module-ppi-loadrecoverycapsule">EFI_PEI_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-device-recovery-module-ppi">EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getnumberrecoverycapsules">GetNumberRecoveryCapsules()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-device-recovery-module-ppi-getrecoverycapsuleinfo">EFI_PEI_DEVICE_RECOVERY_MODULE_PPI. GetRecoveryCapsuleInfo()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-device-recovery-module-ppi-loadrecoverycapsule">EFI_PEI_DEVICE_RECOVERY_MODULE_PPI. LoadRecoveryCapsule()</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-recovery-block-i-o-ppi">8.3.4.3 Device Recovery Block I/O PPI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-block-io-ppi">EFI_PEI_RECOVERY_BLOCK_IO_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-block-io-ppi-getnumberofblockdevices">EFI_PEI_RECOVERY_BLOCK_IO_PPI. GetNumberOfBlockDevices()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-block-io-ppi-getblockdevicemediainfo">EFI_PEI_RECOVERY_BLOCK_IO_PPI.GetBlockDeviceMediaInfo()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-block-io2-ppi">EFI_PEI_RECOVERY_BLOCK_IO2_PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-block-io2-ppi-getnumberofblockdevices">EFI_PEI_RECOVERY_BLOCK_IO2_PPI.GetNumberOfBlockDevices()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-block-io2-ppi-getblockdevicemediainfo">EFI_PEI_RECOVERY_BLOCK_IO2_PPI.GetBlockDeviceMediaInfo()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-recovery-block-io2-ppi-readblocks">EFI_PEI_RECOVERY_BLOCK_IO2_PPI.ReadBlocks()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-vector-handoff-info-ppi-optional">EFI_PEI_VECTOR_HANDOFF_INFO_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-optional">EFI_PEI_CPU_IO_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-mem">EFI_PEI_CPU_IO_PPI.Mem()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-io">EFI_PEI_CPU_IO_PPI.Io()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-ioread8">EFI_PEI_CPU_IO_PPI.IoRead8()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-ioread16">EFI_PEI_CPU_IO_PPI.IoRead16()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-ioread32">EFI_PEI_CPU_IO_PPI.IoRead32()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-ioread64">EFI_PEI_CPU_IO_PPI.IoRead64()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-iowrite8">EFI_PEI_CPU_IO_PPI.IoWrite8()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-iowrite16">EFI_PEI_CPU_IO_PPI.IoWrite16()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-iowrite32">EFI_PEI_CPU_IO_PPI.IoWrite32()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-iowrite64">EFI_PEI_CPU_IO_PPI.IoWrite64()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memread8">EFI_PEI_CPU_IO_PPI.MemRead8()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memread16">EFI_PEI_CPU_IO_PPI.MemRead16()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memread32">EFI_PEI_CPU_IO_PPI.MemRead32()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memread64">EFI_PEI_CPU_IO_PPI.MemRead64()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memwrite8">EFI_PEI_CPU_IO_PPI.MemWrite8()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memwrite16">EFI_PEI_CPU_IO_PPI.MemWrite16()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memwrite32">EFI_PEI_CPU_IO_PPI.MemWrite32()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-cpu-io-ppi-memwrite64">EFI_PEI_CPU_IO_PPI.MemWrite64()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-capsule-ppi-optional">EFI_PEI_CAPSULE_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-capsule-ppi-coalesce">EFI_PEI_CAPSULE_PPI.Coalesce</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-capsule-check-capsule-udpate-checkcapsuleupdat-e">EFI_PEI_CAPSULE_CHECK_CAPSULE_UDPATE.CheckCapsuleUpdat e()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-capsule-check-capsule-udpate-capsulecreatestate">EFI_PEI_CAPSULE_CHECK_CAPSULE_UDPATE.CapsuleCreateState(</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-mp-services-ppi">8.3.9 EFI MP Services PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-mp-services-ppi-optional">EFI_MP_SERVICES_PPI (Optional)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-mp-services-ppi-getprocessorinfo">EFI_MP_SERVICES_PPI.GetProcessorInfo()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-mp-services-ppi-startupallaps">EFI_MP_SERVICES_PPI.StartupAllAPs ()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-mp-services-ppi-startupthisap">EFI_MP_SERVICES_PPI.StartupThisAP ()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-mp-services-ppi-switchbsp">EFI_MP_SERVICES_PPI.SwitchBSP ()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-mp-services-ppi-whoami">EFI_MP_SERVICES_PPI.WhoAmI ()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graphics-peim-interfaces">8.4 Graphics PEIM Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pei-graphics-ppi">8.4.1 Pei Graphics PPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graphicsppiinit">GraphicsPpiInit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graphicsppigetmode">GraphicsPpiGetMode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-graphics-info-hob">EFI_PEI_GRAPHICS_INFO_HOB</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-graphics-device-info-hob">EFI_PEI_GRAPHICS_DEVICE_INFO_HOB</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#pei-to-dxe-handoff">9 PEI to DXE Handoff</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id304">9.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discovery-and-dispatch-of-the-dxe-foundation">9.2 Discovery and Dispatch of the DXE Foundation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#passing-the-hand-off-block-hob-list">9.3 Passing the Hand-Off Block (HOB) List</a></li>
<li class="toctree-l2"><a class="reference internal" href="#handoff-processor-state-to-the-dxe-ipl-ppi">9.4 Handoff Processor State to the DXE IPL PPI</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#boot-paths">10 Boot Paths</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id305">10.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code-flow">10.2 Code Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reset-boot-paths">10.2.1 Reset Boot Paths</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intel-itanium-processor-reset">10.2.1.1 Intel Itanium Processor Reset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-power-on-resets">10.2.1.2 Non-Power-on Resets</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#normal-boot-paths">10.3 Normal Boot Paths</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-g0-to-s0-and-s0-variation-boot-paths">10.3.1 Basic G0-to-S0 and S0 Variation Boot Paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="#s-state-boot-paths">10.3.2 S-State Boot Paths</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recovery-paths">10.4 Recovery Paths</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#discovery">10.4.1 Discovery</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-recovery-architecture">10.4.2 General Recovery Architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#defined-boot-modes">10.5 Defined Boot Modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#priority-of-boot-paths">10.6 Priority of Boot Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assumptions">10.7 Assumptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#architectural-boot-mode-ppis">10.8 Architectural Boot Mode PPIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id326">10.9 Recovery</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scope">10.9.1 Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id327">10.9.2 Discovery</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id328">10.9.3 General Recovery Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finding-and-loading-the-recovery-dxe-image">10.9.4 Finding and Loading the Recovery DXE Image</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#finding-the-recovery-dxe-image-overview">10.9.4.1 Finding the Recovery DXE Image: Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recovery-sequence">10.9.4.2 Recovery Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recovery-ppis-recovery-module-ppi">10.9.4.3 Recovery PPIs: Recovery Module PPI</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#pei-physical-memory-usage">11 PEI Physical Memory Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id331">11.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#before-permanent-memory-is-installed">11.2 Before Permanent Memory Is Installed</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#discovering-physical-memory">11.2.1 Discovering Physical Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-physical-memory">11.2.2 Using Physical Memory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#after-permanent-memory-is-installed">11.3 After Permanent Memory Is Installed</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#allocating-physical-memory">11.3.1 Allocating Physical Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocating-memory-using-guid-extension-hobs">11.3.2 Allocating Memory Using GUID Extension HOBs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocating-memory-using-pei-service">11.3.3 Allocating Memory Using PEI Service</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#itanium-processor-family">Itanium<sup>®</sup> Processor Family</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id334">12.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unique-boot-paths-for-itanium-architecture">12.2 Unique Boot Paths for Itanium Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#min-state-save-area">12.3 Min-State Save Area</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#efi-pei-min-state-data">EFI_PEI_MIN_STATE_DATA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dispatching-itanium-processor-family-peims">12.4 Dispatching Itanium Processor Family PEIMs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#security-sec-phase-information">13 Security (SEC) Phase Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id335">13.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#responsibilities">13.2 Responsibilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#handling-all-platform-restart-events">13.2.1 Handling All Platform Restart Events</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-temporary-memory-store">13.2.2 Creating a Temporary Memory Store</a></li>
<li class="toctree-l3"><a class="reference internal" href="#serving-as-the-root-of-trust-in-the-system">13.2.3 Serving As the Root of Trust in the System</a></li>
<li class="toctree-l3"><a class="reference internal" href="#passing-handoff-information-to-the-pei-foundation">13.2.4 Passing Handoff Information to the PEI Foundation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sec-platform-information-ppi">13.3 SEC Platform Information PPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-hob-data-ppi">13.4 SEC HOB Data PPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#health-flag-bit-format">13.5 Health Flag Bit Format</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#self-test-state-parameter">13.5.1 Self-Test State Parameter</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#processor-specific-details">13.6 Processor-Specific Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sec-phase-in-ia-32-intel-architecture">13.6.1 SEC Phase in IA-32 Intel Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sec-phase-in-the-itanium-processor-family">13.6.2 SEC Phase in the Itanium Processor Family</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#dependency-expression-grammar">14 Dependency Expression Grammar</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id336">14.1 Dependency Expression Grammar</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-dependency-expression-bnf-grammar">14.1.1 Example Dependency Expression BNF Grammar</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sample-dependency-expressions">14.1.2 Sample Dependency Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#te-image">15 TE Image</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id337">15.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pe32-headers">15.2 PE32 Headers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#te-header">TE Header</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#te-image-creation">16 TE Image Creation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#te-image-utility-requirements">16.2 TE Image Utility Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#te-image-relocations">16.3 TE Image Relocations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#te-image-loading">17 TE Image Loading</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id340">17.1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xip-images">17.2 XIP Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="#relocated-images">17.3 Relocated Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pic-images">17.4 PIC Images</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">OTC-TCS Documentation Template</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Revision History</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <blockquote>
<div><p><a class="reference internal" href="media/image1.jpg"><img alt="image0" src="media/image1.jpg" style="width: 1.63500in; height: 1.88500in;" /></a></p>
<p><strong>Platform Initialization (PI) Specification</strong></p>
</div></blockquote>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>Volume 1: **</p>
<p><strong>Pre-EFI Initialization Core Interfac e</strong></p>
<p><strong>Version 1.7</strong></p>
<p><strong>July 2018</strong></p>
<p>The material contained herein is not a license, either expressly or
impliedly, to any intellectual property owned or controlled by any of
the authors or developers of this material or to any contribution
thereto. The material contained herein is provided on an “AS IS” basis
and, to the maximum extent permitted by applicable law, this information
is provided AS IS AND WITH ALL FAULTS, and the authors and developers of
this material hereby disclaim all other warranties and conditions,
either express, implied or statutory, including, but not limited to, any
(if any) implied warranties, duties or conditions of merchantability, of
fitness for a particular purpose, of accuracy or completeness of
responses, of results, of workmanlike effort, of lack of viruses and of
lack of negligence, all with regard to this material and any
contribution thereto. Designers must not rely on the absence or
characteristics of any features or instructions marked “reserved” or
“undefined.” The Unified EFI Forum, Inc. reserves any features or
instructions so marked for future definition and shall have no
responsibility whatsoever for conflicts or incompatibilities arising
from future changes to them. ALSO, THERE IS NO WARRANTY OR CONDITION OF</p>
<p>TITLE, QUIET ENJOYMENT, QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION
OR NON-INFRINGEMENT WITH REGARD TO THE SPECIFICATION AND ANY
CONTRIBUTION THERETO.</p>
<p>IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR ANY</p>
<p>CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR THE COST OF</p>
<p>PROCURING SUBSTITUTE GOODS OR SERVICES, LOST PROFITS, LOSS OF USE, LOSS</p>
<p>OF DATA, OR ANY INCIDENTAL, CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL</p>
<p>DAMAGES WHETHER UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN
ANY WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS DOCUMENT,
WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF THE POSSIBILITY OF SUCH
DAMAGES.</p>
<p>Copyright 2017 Unified EFI, Inc. All Rights Reserved.</p>
<div class="section" id="revision-history">
<h1>Revision History<a class="headerlink" href="#revision-history" title="Permalink to this headline">¶</a></h1>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="74%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.7</td>
<td><ul class="first last">
<li><p class="first">1848 PEI Core PEIM Migration Support Change</p>
</li>
<li><p class="first">1856 SecCore/PeiCore BFV Requirement Change</p>
</li>
<li><p class="first">1860 MM MP Protocol issues</p>
</li>
<li><p class="first">1885 Add extended data for</p>
<blockquote>
<div><p>EFI_SW_DXE_BS_EC_BOOT_OPTION_LOAD_ERROR</p>
</div></blockquote>
</li>
<li><p class="first">1889 New Status Codes</p>
</li>
<li><p class="first">1891 PEI delayed dispatch</p>
</li>
<li><p class="first">1892 new pi spec revision</p>
</li>
</ul>
</td>
<td>July 2018</td>
</tr>
<tr class="row-odd"><td>1.6 Errata A</td>
<td><ul class="first last simple">
<li>1828 Add decorator ‘OPTIONAL’ for Attributes parameter of EFI_PEI_GET_VARIABLE2.</li>
<li>1849 Issues in PI Spec Vol. 5 Ch. 18</li>
<li>1857 Specifies how notifications are passed from SEC to PEI.</li>
<li>1884 Variadic API issue in S3 save API</li>
<li>1907 Clarification of the EFI_MM_COMMUNICATION_PROTOCOL</li>
</ul>
</td>
<td>July 2018</td>
</tr>
<tr class="row-even"><td>1.6</td>
<td><ul class="first last">
<li><p class="first">1567 Layered SPI bus</p>
</li>
<li><p class="first">1648 PI Binding for RISC-V</p>
</li>
<li><p class="first">1746 Add an FV Extended Header entry that contains the used size of the</p>
<blockquote>
<div><p>FV</p>
</div></blockquote>
</li>
<li><p class="first">1763 MM Handler state notification protocol</p>
</li>
<li><p class="first">1764 Add additional alignment</p>
</li>
<li><p class="first">1768 Update the PI Spec to 1.6</p>
</li>
<li><p class="first">1777 Update Revision History</p>
</li>
<li><p class="first">1778 Update front matter</p>
</li>
</ul>
</td>
<td>April 2017</td>
</tr>
<tr class="row-odd"><td>1.5 Errata A</td>
<td><ul class="first last">
<li><p class="first">1587 pre permanent memory page allocation</p>
</li>
<li><p class="first">1665 Incorrect status code for an AP calling</p>
<blockquote>
<div><p>EFI_MP_SERVICES_PROTOCOL.SwitchBSP()</p>
</div></blockquote>
</li>
<li><p class="first">1734 Outdated EFI spec reference in Save State Write</p>
</li>
<li><p class="first">1735 Several copy &amp; paste errors in Save State Write</p>
</li>
<li><p class="first">1747 Clarify that MM_ACCESS_PROTOCOL should cover all MMRAM region used by the platform</p>
</li>
</ul>
</td>
<td>April 2017</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="72%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.5</td>
<td><ul class="first last simple">
<li>1315 SMM Environment to Support Newer Architecture/Platform Designs</li>
<li>1317 additional I2C PPI’s (vol5)</li>
<li>1321 ARM Extensions to Volume 4</li>
<li>1330 Add PPI to allow SEC pass HOBs into PEI</li>
<li>1336 Provide For Pre-DXE Initialization Of The SM Foundation</li>
<li>1369 Handling PEI PPI descriptor notifications from SEC</li>
<li>1387 Variable services errors not consistent</li>
<li>1390 SM stand-alone infrastructure</li>
<li>1396 Update SEC HOB Capabilities of 1330 with additional guidance</li>
<li>1413 Communicate protocol enhancements</li>
<li>1506 New MP protocol</li>
<li>1513 Need a way to propagate PEI-phase FV verification status to DXE</li>
<li>1563 Update MM PPIs to match existing implementations</li>
<li>1566 PI.next - update the specification revisions</li>
<li>1568 Add SD/MMC GUID to DiskInfo protocol</li>
<li>1592 Add EFI_FV_FILETYPE_SMM_CORE_STANDALONE file type</li>
<li>1593 coalesce language enhancements</li>
<li>1594 Pei GetVaiable M1387 issue</li>
<li>1595 M1568 Disk Info issue</li>
<li>1596 M1489 GCD issue</li>
<li>1603 Minor erratas in Vol4 PI 1.5 draft related to ECR 0001506</li>
<li>1607 Update MM guid def’n to match edkII impl</li>
<li>1626 Add new Status Code for BDS Attempting UEFI BootOrder entries</li>
<li>1628 Minor feedback for PI 1.5 Vol 4 SMM Draft</li>
<li>1666 Graphics Device Info Hob</li>
</ul>
</td>
<td>4/26/16</td>
</tr>
<tr class="row-odd"><td>1.4 Errata A</td>
<td><ul class="first last simple">
<li>1574 Fix artificial limitation in the PCD.SetSku support</li>
<li>1565 Update status code to include AArch64 exception error codes</li>
<li>1564 SMM Software Dispatch Protocol Errata</li>
<li>1562 Errata to remove statement from DXE vol about PEI dispatch behavior</li>
<li>1561 Errata to provide Equivalent of DXE-CIS Mantis 247 for the PEI-CIS</li>
<li>1532 Allow S3 Resume without having installed permanent memory (via InstallPeiMemory)</li>
<li>1530 errata on dxe report status code</li>
<li>1529 address space granularity errata</li>
<li>1525 PEI Services Table Retrieval for AArch64</li>
<li>1515 EFI_PEIM_NOTIFY_ENTRY_POINT return values are undefined</li>
<li>1497 Fixing language in SMMStartupThisAP</li>
<li>1489 GCD Conflict errata</li>
<li>1485 Minor Errata in SMM Vo2 description of SMMStartupThisAP</li>
<li>1397 PEI 1.4 specification revision errata</li>
<li>1394 Errata to Relax requirements on CPU rendez in SEC</li>
<li>1351 EndOfDxe and SmmReadyToLock</li>
<li>1322 Minor Updates to handle Asynchronous CPU Entry Into SMM</li>
</ul>
</td>
<td>3/15/16</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="73%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.4</td>
<td><ul class="first last simple">
<li>1210 Adding persistence attribute to GCD</li>
<li>1235 PI.Next Feature - no execute support</li>
<li>1236 PI.Next feature - Graphics PPI</li>
<li>1237 PI.Next feature - add reset2 PPI</li>
<li>1239 PI.Next feature - Disk Info Guid UFS</li>
<li>1240 PI.Next feature - Recovery Block IO PPI - UFS</li>
<li>1259 PI.Next feature - MP PPI</li>
<li>1273 PI.Next feature - capsule PPI</li>
<li>1274 Recovery Block I/O PPI Update</li>
<li>1275 GetMemoryMap Update</li>
<li>1277 PI1.next feature - multiple CPU health info</li>
<li>1278 PI1.next - Memory relative reliability definition</li>
<li>1305 PI1.next - specification number encoding</li>
<li>1331 Remove left-over Boot Firmware Volume references in the SEC Platform Information PPI</li>
<li>1366 PI 1.4 draft - M1277 issue BIST / CPU. So health record needs to be indexed / CPU.</li>
</ul>
</td>
<td>2/20/15</td>
</tr>
<tr class="row-odd"><td>1.3 Errata A</td>
<td><ul class="first last simple">
<li>1041 typo in HOB Overview</li>
<li>1067 PI1.3 Errata for SetBootMode</li>
<li>1068 Updates to PEI Service table/M1006</li>
<li>1069 SIO Errata - pnp end node definition</li>
<li>1070 Typo in SIO chapter</li>
<li>1072 Errata – SMM register protocol notify clarification/errata</li>
<li>1093 Extended File Size Errata</li>
<li>1095 typos/errata</li>
<li>1097 PI SMM GPI Errata</li>
<li>1098 Errata on I2C IO status code</li>
<li>1099 I2C Protocol stop behavior errata</li>
<li>1104 ACPI System Description Table Protocol Errata</li>
<li>1105 ACPI errata - supported table revision</li>
<li>1177 PI errata - make CPU IO optional</li>
<li>1178 errata - allow PEI to report an additional memory type</li>
<li>1283 Errata - clarify sequencing of events</li>
</ul>
</td>
<td>2/19/15</td>
</tr>
<tr class="row-even"><td>1.3</td>
<td><ul class="first last simple">
<li>945 Integrated Circuit (I2C) Bus Protocol</li>
<li>998 PI Status Code additions</li>
<li>999 PCI enumeration complete GUID</li>
<li>1005 NVMe Disk Info guid</li>
<li>1006 Security Ppi Fixes</li>
<li>1025 PI table revisions</li>
</ul>
</td>
<td>3/29/13</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="70%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.2.1 Errata A</td>
<td><ul class="first last simple">
<li>922 Add a “Boot with Manufacturing” boot mode setting</li>
<li>925 Errata on signed FV/Files</li>
<li>931 DXE Volume 2 - Clarify memory map construction from the GCD</li>
<li>936 Clarify memory usage in PEI on S3</li>
<li>937SMM report protocol notify issue errata</li>
<li>951 Root Handler Processing by SmiManage</li>
<li>958</li>
<li>969Vol 1 errata: TE Header parameters</li>
</ul>
</td>
<td>10/26/12</td>
</tr>
<tr class="row-odd"><td>1.2.1 Errata A</td>
<td><ul class="first last simple">
<li>922 Add a “Boot with Manufacturing” boot mode setting</li>
<li>925 Errata on signed FV/Files</li>
<li>931 DXE Volume 2 - Clarify memory map construction from the GCD</li>
<li>936 Clarify memory usage in PEI on S3</li>
<li>937 SMM report protocol notify issue errata</li>
<li>951 Root Handler Processing by SmiManage</li>
<li>958 Omissions in PI1.2.1 integration for M816 and M894</li>
<li>969Vol 1 errata: TE Header parameters</li>
</ul>
</td>
<td>10/26/12</td>
</tr>
<tr class="row-even"><td>1.2.1</td>
<td><ul class="first last simple">
<li>527 PI Volume 2 DXE Security Architecture Protocol (SAP) clarification</li>
<li>562 Add SetMemoryCapabilities to GCD interface</li>
<li>719 End of DXE event</li>
<li>731 Volume 4 SMM - clarify the meaning of NumberOfCpus</li>
<li>737 Remove SMM Communication ACPI Table definition .</li>
<li>753 SIO PEI and UEFI-Driver Model Architecture</li>
<li>769 Signed PI sections</li>
<li>813 Add a new EFI_GET_PCD_INFO_PROTOCOL and EFI_GET_PCD_INFO_PPI instance.</li>
<li>818 New SAP2 return code</li>
<li>822 Method to disable Temporary RAM when Temp RAM Migration is not required</li>
<li>833 Method to Reserve Interrupt and Exception Vectors</li>
<li>839 Add support for weakly aligned FVs</li>
<li>892 EFI_PCI_ENUMERATION_COMPLETE_GUID Protocol</li>
<li>894 SAP2 Update</li>
<li>895 Status Code Data Structures Errata</li>
<li>902 Errata on signed firmware volume/file</li>
<li>903 SmiManage Update</li>
<li>906 Volume 3 errata - Freeform type</li>
<li>916 Service table revisions</li>
</ul>
</td>
<td>05/02/12</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="72%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.2 Errata C</td>
<td><ul class="first last">
<li><p class="first">550 Naming conflicts w/ PI SMM</p>
</li>
<li><p class="first">571 duplicate definition of EFI_AP_PROCEDURE in DXE MP (volume2) and SMM (volume 4)</p>
</li>
<li><p class="first">654 UEFI PI specific handle for SMBIOS is now available</p>
</li>
<li><p class="first">688 Status Code errata</p>
</li>
<li><p class="first">690 Clarify agent in IDE Controller chapter</p>
</li>
<li><p class="first">691 SMM a priori file and SOR support</p>
</li>
<li><p class="first">692 Clarify the SMM SW Register API</p>
</li>
<li><p class="first">694 PEI Temp RAM PPI ambiguity</p>
</li>
<li><p class="first">703 End of PEI phase PPI publication for the S3 boot mode case</p>
</li>
<li><p class="first">706 GetPeiServicesTablePointer () changes for the ARM architecture</p>
</li>
<li><p class="first">714 PI Service Table Versions</p>
</li>
<li><p class="first">717 PI Extended File Size Errata</p>
</li>
<li><p class="first">718 PI Extended Header cleanup / Errata</p>
</li>
<li><p class="first">730 typo in EFI_SMM_CPU_PROTOCOL.ReadSaveState() return code</p>
</li>
<li><p class="first">737 Remove SMM Communication ACPI Table definition .</p>
</li>
<li><p class="first">738 Errata to Volume 2 of the PI1.2 specification</p>
</li>
<li><p class="first">739 Errata for PI SMM Volume 4 Control protocol</p>
</li>
<li><p class="first">742 Errata for SMBUS chapter in Volume 5</p>
</li>
<li><p class="first">743 Errata - PCD_PPI declaration</p>
</li>
<li><p class="first">745 Errata – PI Firmware Section declarations</p>
</li>
<li><p class="first">746 Errata - PI status code</p>
</li>
<li><p class="first">747 Errata - Text for deprecated HOB</p>
</li>
<li><p class="first">752 Binary Prefix change</p>
</li>
<li><p class="first">753 SIO PEI and UEFI-Driver Model Architecture</p>
</li>
<li><p class="first">764 PI Volume 4 SMM naming errata</p>
</li>
<li><p class="first">775 errata/typo in EFI_STATUS_CODE_EXCEP_SYSTEM_CONTEXT, Volume 3</p>
</li>
<li><p class="first">781 S3 Save State Protocol Errata</p>
</li>
<li><p class="first">782 Format Insert(), Compare() and Label() as for Write()</p>
</li>
<li><p class="first">783 TemporaryRamMigration Errata</p>
</li>
<li><p class="first">784 Typos in status code definitions</p>
</li>
<li><p class="first">787 S3 Save State Protocol Errata 2</p>
</li>
<li><p class="first">810 Set Memory Attributes return code clarification</p>
</li>
<li><p class="first">811 SMBIOS API Clarification</p>
</li>
<li><p class="first">814 PI SMBIOS Errata</p>
</li>
<li><p class="first">821Location conflict for</p>
<blockquote>
<div><p>EFI_RESOURCE_ATTRIBUTE_xxx_PROTECTABLE #defines</p>
</div></blockquote>
</li>
<li><p class="first">823 Clarify max length of SMBIOS Strings in SMBIOS Protocol</p>
</li>
<li><p class="first">824 EFI_SMM_SW_DISPATCH2_PROTOCOL.Register() Errata</p>
</li>
<li><p class="first">837 ARM Vector table can not support arbitrary 32-bit address</p>
</li>
<li><p class="first">838 Vol 3 EFI_FVB2_ALIGNMNET_512K should be EFI_FVB2_ALIGNMENT_512K</p>
</li>
<li><p class="first">840 Vol 3 Table 5 Supported FFS Alignments contains values not supported by FFS</p>
</li>
<li><p class="first">844 correct references to Platform Initialization Hand-Off Block Specification</p>
</li>
</ul>
</td>
<td>10/27/11</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="79%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.2 errata B</td>
<td><ul class="first last simple">
<li>628 ACPI SDT protocol errata</li>
<li>629 Typos in PCD GetSize()</li>
<li>630EFI_SMM_PCI_ROOT_BRIDGE_IO_PROTOCOL service clarification</li>
<li>631 System Management System Table (SMST) MP-related field clarification</li>
</ul>
</td>
<td>5/27/10</td>
</tr>
<tr class="row-odd"><td>1.2 errata A</td>
<td><ul class="first last simple">
<li>363 PI volume 1 errata</li>
<li>365 UEFI Capsule HOB</li>
<li>381 PI1.1 Errata on EFI_SMM_SAVE_STATE_IO_INFO</li>
<li>482 One other naming inconsistency in the PCD PPI declaration</li>
<li>483 PCD Protocol / PPI function name synchronization…..</li>
<li>496 Boot mode description</li>
<li>497 Status Code additions</li>
<li>548 Boot firmware volume clarification</li>
<li>551 Name conflicts w/ Legacy region</li>
<li>552 MP services</li>
<li>553 Update text to PEI</li>
<li>554 update return code from PEI AllocatePages</li>
<li>555 Inconsistency in the S3 protocol</li>
<li>561 Minor update to PCD-&gt;SetPointer</li>
<li>565 CANCEL_CALL_BACK should be CANCEL_CALLBACK</li>
<li>569 Recovery: EFI_PEI_GET_NUMBER_BLOCK_DEVICES decl has EFI_STATUS w/o return code &amp; errror on stage 3 recovery description</li>
<li>571 duplicate definition of EFI_AP_PROCEDURE in DXE MP (volume2) and SMM (volume 4)</li>
<li>581 EFI_HOB_TYPE_LOAD_PEIM ambiguity</li>
<li>591ACPI Protocol Name collision</li>
<li>592 More SMM name conflicts</li>
<li>593 A couple of ISA I/O clarifications</li>
<li>594 ATA/ATAPI clarification</li>
<li>595 SMM driver entry point clarification</li>
<li>596 Clarify ESAL return codes</li>
<li>602 SEC-&gt;PEI hand-off update</li>
<li>604 EFI_NOT_SUPPORTED versus EFI_UNSUPPORTED</li>
</ul>
</td>
<td>2/24/10</td>
</tr>
<tr class="row-even"><td>1.2</td>
<td><ul class="first last simple">
<li>407 Comment: additional change to LMA Pseudo-Register</li>
<li>441 Comment: PI Volume 3, Incorrect Struct Declaration (esp PCD_PPI)</li>
<li>455 Comment: Errata - Clarification of InstallPeiMemory()</li>
<li>465 Comment: Errata on PMI interface</li>
<li>466 Comment: Vol 4 EXTENDED_SAL_PROC definition</li>
<li>467 Comments: PI1.1 errata</li>
<li>480 Comment: FIX to PCD_PROTOCOL and PCD_PPI</li>
</ul>
</td>
<td>05/13/09</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="68%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.2</td>
<td><ul class="first last simple">
<li>401 SMM Volume 4 issue</li>
<li>402 SMM PI spec issue w.r.t. CRC</li>
<li>407 Add LMA Pseudo-Register to SMM Save State Protocol</li>
<li>409 PCD_PROTOCOL Errata</li>
<li>411 Draft Errata, Volume 5, Section 8</li>
<li>412 Comment: PEI_S3_RESUME_PPI should be EFI_PEI_S3_RESUME_PPI</li>
<li>414 Draft Chapter 7 Comments</li>
<li>415 Comment: Report Status Code Routers</li>
<li>416 EFI_CPU_IO_PROTOCOL2 Name should be EFI_CPU_IO2_PROTOCOL</li>
<li>417 Volume 5, Chapter 4 &amp; 5 order is reversed</li>
<li>423 Comment: Section 15.2.1 Formatting Issues vol5</li>
<li>424 Comments: Volume 5, Appendix A.1 formatting issues</li>
<li>425 Comment: Formatting in Section 6.1 of Volume 3</li>
<li>426 Comments: Volume 2</li>
<li>427 Comment: Volume 3, Section 6</li>
<li>433 Editorial issues in PI 1.2 draft</li>
</ul>
</td>
<td>02/23/09</td>
</tr>
<tr class="row-odd"><td>1.2</td>
<td><ul class="first last simple">
<li>271 Support For Large Firmware Files And Firmware File Sections</li>
<li>284 CPU I/O protocol update</li>
<li>286 Legacy Region protocol</li>
<li>289 Recovery API</li>
<li>292 PCD Specification Update</li>
<li>354 ACPI Manipulation Protocol</li>
<li>355 EFI_SIO_PROTOCOL Errata</li>
<li>365 UEFI Capsule HOB</li>
<li>382 IDE Controller Specification</li>
<li>385 Report Status Code Router Specification</li>
<li>386 Status Code Specification</li>
</ul>
</td>
<td>01/19/09</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="75%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.2 errata</td>
<td><ul class="first last">
<li><p class="first">345 PI1.0 errata</p>
</li>
<li><p class="first">468 Issues on proposed PI1.2 ACPI System Description Table Protocol</p>
</li>
<li><p class="first">492 Add Resource HOB Protectability Attributes</p>
</li>
<li><p class="first">494 Vol. 2 Appendix A Clean up</p>
</li>
<li><p class="first">495 Vol 1: update HOB reference</p>
</li>
<li><p class="first">380 PI1.1 errata from SMM development</p>
</li>
<li><p class="first">501 Clean Up SetMemoryAttributes() language Per Mantis 489 (from</p>
<blockquote>
<div><p>USWG)</p>
</div></blockquote>
</li>
<li><p class="first">502 Disk info</p>
</li>
<li><p class="first">503 typo</p>
</li>
<li><p class="first">504 remove support for fixed address resources</p>
</li>
<li><p class="first">509 PCI errata – execution phase</p>
</li>
<li><p class="first">510 PCI errata - platform policy</p>
</li>
<li><p class="first">511 PIC TE Image clarification/errata</p>
</li>
<li><p class="first">520 PI Errata</p>
</li>
<li><p class="first">521Add help text for EFI_PCD_PROTOCOL for GetNextTokenSpace</p>
</li>
<li><p class="first">525 Itanium ESAL, MCA/INIT/PMI errata</p>
</li>
<li><p class="first">526 PI SMM errata</p>
</li>
<li><p class="first">529 PCD issues in Volume 3 of the PI1.2 Specification</p>
</li>
<li><p class="first">541 Volume 5 Typo</p>
</li>
<li><p class="first">543 Clarification around usage of FV Extended header</p>
</li>
<li><p class="first">550 Naming conflicts w/ PI SMM</p>
</li>
</ul>
</td>
<td>12/16/09</td>
</tr>
<tr class="row-odd"><td>1.1 Errata</td>
<td><ul class="first last">
<li><p class="first">247 Clarification regarding use of dependency expression section types with firmware volume image files</p>
</li>
<li><p class="first">399 SMBIOS Protocol Errata</p>
</li>
<li><p class="first">405 PIWG Volume 5 incorrectly refers to</p>
<blockquote>
<div><p>EFI_PCI_OVERRIDE_PROTOCOL</p>
</div></blockquote>
</li>
<li><p class="first">422 TEMPORARY_RAM_SUPPORT_PPI is misnamed</p>
</li>
<li><p class="first">428 Volume 5 PCI issue</p>
</li>
<li><p class="first">430 Clarify behavior w/ the FV extended header</p>
</li>
</ul>
</td>
<td>02/23/09</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="73%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.1 Errata</td>
<td><ul class="first last">
<li><p class="first">204 Stack HOB update 1.1errata</p>
</li>
<li><p class="first">225 Correct references from EFI_FIRMWARE_VOLUME_PROTOCOL to EFI_FIRMWARE_VOLUME2_PROTOCOL</p>
</li>
<li><p class="first">226 Remove references to Framework</p>
</li>
<li><p class="first">227 Correct protocol name</p>
<blockquote>
<div><p>GUIDED_SECTION_EXTRACTION_PROTOCOL</p>
</div></blockquote>
</li>
<li><p class="first">228 insert”typedef” missing from some typedefs in Volume 3</p>
</li>
<li><p class="first">243 Define interface “EFI_PEI_FV_PPI” declaration in PI1.0 FfsFindNextVolume()</p>
</li>
<li><p class="first">285 Time quality of service in S3 boot script poll operation</p>
</li>
<li><p class="first">287 Correct MP spec, PIVOLUME 2:Chapter 13.3 and 13.4 - return error language</p>
</li>
<li><p class="first">290 PI Errata</p>
</li>
<li><p class="first">305 Remove Datahub reference</p>
</li>
<li><p class="first">336 SMM Control Protocol update</p>
</li>
<li><p class="first">345 PI Errata</p>
</li>
<li><p class="first">353 PI Errata</p>
</li>
<li><p class="first">360 S3RestoreConfig description is missing</p>
</li>
<li><p class="first">363 PI Volume 1 Errata</p>
</li>
<li><p class="first">367 PCI Hot Plug Init errata</p>
</li>
<li><p class="first">369 Volume 4 Errata</p>
</li>
<li><p class="first">380 SMM Development errata</p>
</li>
<li><p class="first">381 Errata on EFI_SMM_SAVE_STATE_IO_INFO</p>
<blockquote>
<div><ul class="simple">
<li></li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
<td>01/13/09</td>
</tr>
<tr class="row-odd"><td>1.1 Errata</td>
<td>Revises typographical errors and minor omissions–see Errata for details</td>
<td>04/25/08</td>
</tr>
<tr class="row-even"><td>1.1 correction</td>
<td>Restore (missing) MP protocol</td>
<td>03/12/08</td>
</tr>
<tr class="row-odd"><td>1.1</td>
<td><p class="first">Mantis tickets:</p>
<ul class="last simple">
<li>M39 (Updates PCI Hostbridge &amp; PCI Platform)</li>
<li>M41 (Duplicate 167)</li>
<li>M42 Add the definition of theDXE CIS Capsule AP &amp; Variable AP</li>
<li>M43 (SMbios)</li>
<li>M46 (SMM error codes)</li>
<li>M163 (Add Volume 4–SMM</li>
<li>M167 (Vol2: adds the DXE Boot Services Protocols–new Chapter 12)</li>
<li>M179 (S3 boot script)</li>
<li>M180 (PMI ECR)</li>
<li>M195 (Remove PMI references from SMM CIS)</li>
<li>M196 (disposable-section type to the FFS)</li>
</ul>
</td>
<td>11/05/07</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="71%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Revision</strong></th>
<th class="head"><strong>Mantis ID / Description</strong></th>
<th class="head"><strong>Date</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.0 errata</td>
<td><p class="first">Mantis tickets:</p>
<ul class="last simple">
<li>M47 dxe_dispatcher_load_image_behavior</li>
<li>M48 Make spec more consistent GUID &amp; filename.</li>
<li>M155 FV_FILE and FV_ONLY: Change subtype number back to th:e original one.</li>
<li>M171Remove 10 us lower bound restriction for the TickPeriod in the Metronome</li>
<li>M178 Remove references to tail in file header and made file checksum for the data</li>
<li>M183 Vol 1-Vol 5: Make spec more consistent.</li>
<li>M192 Change PAD files to have an undefined GUID file name and update all FV</li>
</ul>
</td>
<td>10/29/07</td>
</tr>
<tr class="row-odd"><td>1.0</td>
<td>Initial public release.</td>
<td>8/21/06</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Specification Volumes</strong></p>
<p>The <strong>Platform Initialization Specification</strong> is divided into
volumes to enable logical organization, future growth, and printing
convenience. The <strong>Platform Initialization Specification</strong> consists
of the following volumes:</p>
<p><a href="#id3"><span class="problematic" id="id4">**</span></a>Volume 1: Pre-EFI Initialization Core Interface **</p>
<p><a href="#id5"><span class="problematic" id="id6">**</span></a>Volume 2: Driver Execution Environment Core Interface **</p>
<p><strong>Volume 3: Shared Architectural Elements</strong></p>
<p><strong>Volume 4: System Management Mode</strong></p>
<p><a href="#id7"><span class="problematic" id="id8">**</span></a>Volume 5: Standards **</p>
<p>Each volume should be viewed in the context of all other volumes,
and readers are strongly encouraged to consult the entire
specification when researching areas of interest. Additionally, a
single-file version of the <strong>Platform Initialization Specification</strong>
is available to aid search functions through the entire
specification.</p>
</div></blockquote>
</div>
<div class="section" id="table-of-contents">
<h1>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline">¶</a></h1>
<p>Revision Historyiii</p>
<p>Table of Contentsxiv</p>
<p>List of Figuresxxi</p>
<p>List of Tablesxxii</p>
<ol class="arabic">
<li><p class="first"><strong>Introduction…………………………………………………………………………………………1</strong></p>
<ol class="arabic simple">
<li>Overview……………………………………………………………………………………………………………
1</li>
<li>Organization of the PEI
CIS………………………………………………………………………………….
1</li>
<li>Conventions Used in this
Document………………………………………………………………………
2<ol class="arabic">
<li>2</li>
<li>Procedure
Descriptions……………………………………………………………………………..
2</li>
<li>Instruction
Descriptions……………………………………………………………………………..
3</li>
<li>PPI
Descriptions……………………………………………………………………………………….
3</li>
<li>Pseudo-Code
Conventions………………………………………………………………………..
4</li>
<li>4</li>
</ol>
</li>
<li>Requirements……………………………………………………………………………………………………..
5</li>
<li>Conventions used in this
document……………………………………………………………………….
6<ol class="arabic">
<li>6</li>
</ol>
</li>
</ol>
</li>
<li><p class="first"><strong>Overview……………………………………………………………………………………………..8</strong></p>
<ol class="arabic simple">
<li>8</li>
<li>8</li>
<li>9</li>
<li>10</li>
<li>11</li>
<li>PEI
Dispatcher………………………………………………………………………………………………….
11</li>
<li>12</li>
<li>122.9 Firmware
Volumes…………………………………………………………………………………………….
13</li>
</ol>
</li>
<li><p class="first"><strong>PEI Services
Table……………………………………………………………………………..14</strong></p>
<ol class="arabic simple">
<li>14</li>
<li>143.2.1
EFI_PEI_SERVICES……………………………………………………………………………….
14</li>
</ol>
</li>
<li><p class="first"><strong>Services -
PEI…………………………………………………………………………………….20</strong></p>
<ol class="arabic simple">
<li>20</li>
<li>21
ReinstallPpi()………………………………………………………………………………………….
22</li>
</ol>
<blockquote>
<div><p>LocatePpi()…………………………………………………………………………………………….
23</p>
<p>NotifyPpi()………………………………………………………………………………………………
24</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Boot Mode
Services…………………………………………………………………………………………..
25</p>
<blockquote>
<div><p>GetBootMode()……………………………………………………………………………………….
25
SetBootMode()……………………………………………………………………………………….
27</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">28</p>
<blockquote>
<div><p>GetHobList()…………………………………………………………………………………………..
28</p>
<p>CreateHob()……………………………………………………………………………………………
29</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Firmware Volume
Services…………………………………………………………………………………
30FfsFindNextVolume()
………………………………………………………………………………
30
FfsFindNextFile()…………………………………………………………………………………….
31 FfsFindSectionData()
………………………………………………………………………………
32 FfsFindSectionData3()
…………………………………………………………………………….
33</p>
<blockquote>
<div><p>37
FfsGetVolumeInfo()…………………………………………………………………………………
38</p>
<p>RegisterForShadow()………………………………………………………………………………
40</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">41
AllocatePages()………………………………………………………………………………………
42
AllocatePool()…………………………………………………………………………………………
43
CopyMem()…………………………………………………………………………………………….
44</p>
<blockquote>
<div><p>45</p>
<p>SetMem()……………………………………………………………………………………………….
46</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">47</p>
<blockquote>
<div><p>47</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Reset
Services………………………………………………………………………………………………….
50</p>
<blockquote>
<div><p>ResetSystem()………………………………………………………………………………………..
50</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic simple">
<li>51</li>
</ol>
<ol class="arabic">
<li><p class="first"><strong>PEI
Foundation………………………………………………………………………………….52</strong></p>
<ol class="arabic simple">
<li>52<ol class="arabic">
<li>Prerequisites………………………………………………………………………………………….
52</li>
<li>52</li>
</ol>
</li>
<li>PEI Foundation Entry
Point…………………………………………………………………………………
54<ol class="arabic">
<li>PEI Foundation Entry
Point………………………………………………………………………
54</li>
</ol>
</li>
<li>PEI Calling Convention Processor
Binding……………………………………………………………
57</li>
<li>57<ol class="arabic">
<li>X86……………………………………………………………………………………………………….
57</li>
<li>58</li>
<li>Itanium Processor Family – Register
Mechanism……………………………………….. 58</li>
<li>ARM Processor Family – Register
Mechanism…………………………………………… 59</li>
<li>AArch64 Processor Family – Register
Mechanism……………………………………… 60</li>
<li>RISC-V Processor Family – Register Mechanism
………………………………………. 60</li>
</ol>
</li>
<li>61</li>
<li>Ordering…………………………………………………………………………………………………………..
61<ol class="arabic">
<li>Requirements…………………………………………………………………………………………
61</li>
<li>Requirement Representation and
Notation…………………………………………………
61</li>
<li>PEI a priori File
Overview…………………………………………………………………………
62PEI_APRIORI_FILE_NAME_GUID……………………………………………………………
63</li>
<li>64</li>
<li>PEIM Dependency
Expressions………………………………………………………………..
64</li>
<li>64</li>
</ol>
</li>
<li>64<ol class="arabic">
<li>66
AND………………………………………………………………………………………………………
68
OR………………………………………………………………………………………………………..
69
NOT………………………………………………………………………………………………………
70
TRUE…………………………………………………………………………………………………….
71
FALSE…………………………………………………………………………………………………..
72</li>
</ol>
</li>
</ol>
<blockquote>
<div><p>END………………………………………………………………………………………………………
73</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic simple">
<li>Dependency Expression with No Dependencies
………………………………………… 74</li>
<li>74</li>
<li>Dependency Expression Reverse Polish Notation
(RPN)…………………………….. 74</li>
</ol>
<ol class="arabic simple">
<li>Dispatch
Algorithm…………………………………………………………………………………………….
74<ol class="arabic">
<li>74</li>
<li>Requirements…………………………………………………………………………………………
75</li>
<li>Example Dispatch
Algorithm…………………………………………………………………….
77</li>
<li>78</li>
<li>PEIM
Dispatching……………………………………………………………………………………
795.8.6 PEIM
Authentication………………………………………………………………………………..
79</li>
</ol>
</li>
</ol>
<ol class="arabic">
<li><p class="first"><strong>Architectural
PPIs………………………………………………………………………………80</strong></p>
<ol class="arabic simple">
<li>80</li>
<li>Required Architectural
PPIs………………………………………………………………………………..
80<ol class="arabic">
<li>Master Boot Mode PPI
(Required)…………………………………………………………….
80</li>
</ol>
</li>
</ol>
<blockquote>
<div><p>EFI_PEI_MASTER_BOOT_MODE_PPI (Required)
……………………………………. 80</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">DXE IPL PPI
(Required)…………………………………………………………………………..
81EFI_DXE_IPL_PPI
(Required)………………………………………………………………….
81</p>
<blockquote>
<div><p>82</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">84</p>
<blockquote>
<div><p>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI
(Required)………………… 84</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Optional Architectural
PPIs…………………………………………………………………………………
85</p>
<ol class="arabic simple">
<li>Boot in Recovery Mode PPI (Optional)
……………………………………………………… 85</li>
</ol>
<blockquote>
<div><p>EFI_PEI_BOOT_IN_RECOVERY_MODE_PPI
(Optional)…………………………… 85</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">86</p>
<blockquote>
<div><p>EFI_PEI_END_OF_PEI_PHASE_PPI
(Optional)………………………………………… 86</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">PEI Reset
PPI………………………………………………………………………………………..
87</p>
<blockquote>
<div><p>87</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">87</p>
<blockquote>
<div><p>89</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Status Code PPI
(Optional)………………………………………………………………………
91</p>
<blockquote>
<div><p>EFI_PEI_PROGRESS_CODE_PPI
(Optional)……………………………………………. 91</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Security PPI
(Optional)…………………………………………………………………………….
92EFI_PEI_SECURITY2_PPI
(Optional)……………………………………………………….
92 EFI_PEI_SECURITY2_PPI.AuthenticationState()
………………………………………. 93</p>
</li>
<li><p class="first">Temporary RAM Support PPI
(Optional)…………………………………………………….
94 EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI (Optional)
………………………….. 94</p>
<blockquote>
<div><p>EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI.TemporaryRamMigration()……
96</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Temporary RAM Done PPI
(Optional)………………………………………………………..
97 EFI_PEI_TEMPORARY_RAM_DONE_PPI
(Optional)………………………………… 97</p>
<blockquote>
<div><p>EFI_PEI_TEMPORARY_RAM_DONE_PPI.TemporaryRamDone
()……………… 99</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first"><strong>PEIMs………………………………………………………………………………………………100</strong></p>
<ol class="arabic simple">
<li>100</li>
<li>PEIM
Structure………………………………………………………………………………………………..
100<ol class="arabic">
<li>PEIM Structure
Overview……………………………………………………………………….
100</li>
<li>101</li>
<li>102</li>
</ol>
</li>
<li>103<ol class="arabic">
<li>EFI_PEIM_ENTRY_POINT2…………………………………………………………………..
103</li>
</ol>
</li>
<li>PEIM
Descriptors…………………………………………………………………………………………….
104<ol class="arabic">
<li>105
EFI_PEI_NOTIFY_DESCRIPTOR…………………………………………………………..
106</li>
</ol>
</li>
</ol>
<blockquote>
<div><p>EFI_PEI_PPI_DESCRIPTOR………………………………………………………………….
108</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic simple">
<li>PEIM-to-PEIM
Communication………………………………………………………………………….
109<ol class="arabic">
<li>1097.5.2 Dynamic PPI
Discovery………………………………………………………………………….
110</li>
</ol>
</li>
</ol>
<ol class="arabic">
<li><p class="first"><strong>Additional
PPIs………………………………………………………………………………..111</strong></p>
<ol class="arabic simple">
<li>111</li>
<li>Required Additional
PPIs………………………………………………………………………………….
111<ol class="arabic">
<li>PCI Configuration PPI
(Required)……………………………………………………………
111
EFI_PEI_PCI_CFG2_PPI……………………………………………………………………….
113
EFI_PEI_PCI_CFG2_PPI.Read()…………………………………………………………….
115
EFI_PEI_PCI_CFG2_PPI.Write()…………………………………………………………….
117</li>
</ol>
</li>
</ol>
<blockquote>
<div><p>EFI_PEI_PCI_CFG2_PPI.Modify()…………………………………………………………..
118</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">119EFI_PEI_STALL_PPI
(Required)…………………………………………………………….
119</p>
<blockquote>
<div><p>EFI_PEI_STALL_PPI.Stall()……………………………………………………………………
120</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">121
EFI_PEI_READ_ONLY_VARIABLE2_PPI………………………………………………..
121
EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable………………………………
122</p>
<blockquote>
<div><p>EFI_PEI_READ_ONLY_VARIABLE2_PPI.NextVariableName…………………….
124</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">126</p>
<ol class="arabic simple">
<li>SEC Platform Information PPI
(Optional)………………………………………………….
126 EFI_SEC_PLATFORM_INFORMATION_PPI
(Optional)……………………………. 126
EFI_SEC_PLATFORM_INFORMATION_PPI.PlatformInformation()…………….
127 EFI_SEC_PLATFORM_INFORMATION2_PPI
(Optional)………………………….. 131</li>
</ol>
<blockquote>
<div><p>EFI_SEC_PLATFORM_INFORMATION2_PPI.PlatformInformation2()…………
132</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Loaded Image PPI
(Optional)………………………………………………………………….
134EFI_PEI_LOADED_IMAGE_PPI……………………………………………………………..
134</p>
</li>
<li><p class="first">134EFI_SEC_HOB_DATA_PPI……………………………………………………………………
134</p>
<blockquote>
<div><p>EFI_SEC_HOB_DATA_PPI.GetHobs()…………………………………………………….
136</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Recovery…………………………………………………………………………………………….
136EFI_PEI_RECOVERY_MODULE_PPI……………………………………………………..
137
EFI_PEI_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()………………….
139
EFI_PEI_DEVICE_RECOVERY_MODULE_PPI……………………………………….
139</p>
<blockquote>
<div><p>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.</p>
<p>141</p>
<p>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI. GetRecoveryCapsuleInfo()..
142</p>
<p>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI. LoadRecoveryCapsule() …..
144</p>
<p>EFI_PEI_RECOVERY_BLOCK_IO_PPI…………………………………………………..
145 EFI_PEI_RECOVERY_BLOCK_IO_PPI.
GetNumberOfBlockDevices()……….. 146
EFI_PEI_RECOVERY_BLOCK_IO_PPI.GetBlockDeviceMediaInfo()
………….. 147</p>
<p>EFI_PEI_RECOVERY_BLOCK_IO_PPI.ReadBlocks()
…………………………….. 149</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">150
EFI_PEI_RECOVERY_BLOCK_IO2_PPI…………………………………………………
151
EFI_PEI_RECOVERY_BLOCK_IO2_PPI.GetNumberOfBlockDevices()……….
152 EFI_PEI_RECOVERY_BLOCK_IO2_PPI.GetBlockDeviceMediaInfo()
………… 153</p>
<blockquote>
<div><p>EFI_PEI_RECOVERY_BLOCK_IO2_PPI.ReadBlocks()
……………………………. 156</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">EFI PEI Vector Handoff Info
PPI……………………………………………………………..
157</p>
<blockquote>
<div><p>EFI_PEI_VECTOR_HANDOFF_INFO_PPI (Optional)
………………………………. 158</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">159EFI_PEI_CPU_IO_PPI
(Optional)……………………………………………………………
159</p>
<blockquote>
<div><p>165
EFI_PEI_CPU_IO_PPI.IoRead8()……………………………………………………………
166
EFI_PEI_CPU_IO_PPI.IoRead16()………………………………………………………….
167</p>
<p>EFI_PEI_CPU_IO_PPI.IoRead32()………………………………………………………….
168</p>
<p>EFI_PEI_CPU_IO_PPI.IoRead64()………………………………………………………….
169
EFI_PEI_CPU_IO_PPI.IoWrite8()……………………………………………………………
170
EFI_PEI_CPU_IO_PPI.IoWrite16()………………………………………………………….
171</p>
<p>EFI_PEI_CPU_IO_PPI.IoWrite32()………………………………………………………….
172</p>
<p>EFI_PEI_CPU_IO_PPI.IoWrite64()………………………………………………………….
173
EFI_PEI_CPU_IO_PPI.MemRead8()……………………………………………………….
174
EFI_PEI_CPU_IO_PPI.MemRead16()……………………………………………………..
175</p>
<p>EFI_PEI_CPU_IO_PPI.MemRead32()……………………………………………………..
176</p>
<p>EFI_PEI_CPU_IO_PPI.MemRead64()……………………………………………………..
177
EFI_PEI_CPU_IO_PPI.MemWrite8()……………………………………………………….
178
EFI_PEI_CPU_IO_PPI.MemWrite16()……………………………………………………..
179</p>
<p>EFI_PEI_CPU_IO_PPI.MemWrite32()……………………………………………………..
180</p>
<p>EFI_PEI_CPU_IO_PPI.MemWrite64()……………………………………………………..
181</p>
<p>181 EFI_PEI_CAPSULE_PPI
(Optional)…………………………………………………………
182 EFI_PEI_CAPSULE_PPI.Coalesce
…………………………………………………………
183</p>
<p>EFI_PEI_CAPSULE_CHECK_CAPSULE_UDPATE.CheckCapsuleUpdate().. 184
EFI_PEI_CAPSULE_CHECK_CAPSULE_UDPATE.CapsuleCreateState() ….
185</p>
<p>8.3.9 EFI MP Services
PPI……………………………………………………………………………..
185 EFI_MP_SERVICES_PPI
(Optional)………………………………………………………..
186
EFI_MP_SERVICES_PPI.GetNumberOfProcessors()……………………………….
188
EFI_MP_SERVICES_PPI.GetProcessorInfo()…………………………………………..
190 EFI_MP_SERVICES_PPI.StartupAllAPs
()………………………………………………. 191
EFI_MP_SERVICES_PPI.StartupThisAP
()……………………………………………… 193
EFI_MP_SERVICES_PPI.SwitchBSP
()………………………………………………….. 195</p>
<p>EFI_MP_SERVICES_PPI.WhoAmI
()………………………………………………………
198</p>
<p>8.4 Graphics PEIM
Interfaces…………………………………………………………………………………
199</p>
<p>8.4.1 Pei Graphics
PPI…………………………………………………………………………………..
199
GraphicsPpiInit……………………………………………………………………………………..
200</p>
<p>GraphicsPpiGetMode…………………………………………………………………………….
201</p>
<p>8.4.2 EFI PEI Graphics INFO
HOB………………………………………………………………….
205
EFI_PEI_GRAPHICS_INFO_HOB…………………………………………………………..
206</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic" start="9">
<li><p class="first"><strong>PEI to DXE Handoff
………………………………………………………………………….208</strong></p>
<ol class="arabic simple">
<li>208</li>
<li>Discovery and Dispatch of the DXE
Foundation…………………………………………………..
208</li>
<li>Passing the Hand-Off Block (HOB)
List………………………………………………………………
208 9.4 Handoff Processor State to the DXE IPL PPI
………………………………………………………
209</li>
</ol>
</li>
<li><p class="first"><strong>Boot
Paths……………………………………………………………………………………..210</strong></p>
<ol class="arabic simple">
<li>210</li>
<li>Code
Flow…………………………………………………………………………………………………….
210<ol class="arabic">
<li>Reset Boot
Paths………………………………………………………………………………..
210</li>
</ol>
</li>
<li>Normal Boot
Paths………………………………………………………………………………………..
211<ol class="arabic">
<li>Basic G0-to-S0 and S0 Variation Boot
Paths…………………………………………. 211</li>
<li>S-State Boot
Paths………………………………………………………………………………
212</li>
</ol>
</li>
<li>Recovery
Paths……………………………………………………………………………………………..
212<ol class="arabic">
<li>213</li>
<li>General Recovery
Architecture……………………………………………………………..
213</li>
</ol>
</li>
<li>213</li>
<li>213</li>
<li>214</li>
<li>Architectural Boot Mode
PPIs………………………………………………………………………….
214</li>
<li>Recovery………………………………………………………………………………………………………
215<ol class="arabic">
<li>Scope………………………………………………………………………………………………..
215</li>
<li>215</li>
<li>General Recovery
Architecture……………………………………………………………..
215 10.9.4 Finding and Loading the Recovery DXE
Image………………………………………. 216</li>
</ol>
</li>
</ol>
</li>
<li><p class="first"><strong>PEI Physical Memory
Usage……………………………………………………………219</strong></p>
<ol class="arabic simple">
<li>219</li>
<li>Before Permanent Memory Is
Installed……………………………………………………………..
219<ol class="arabic">
<li>Discovering Physical
Memory……………………………………………………………….
219</li>
<li>Using Physical
Memory………………………………………………………………………..
219</li>
</ol>
</li>
<li>After Permanent Memory Is
Installed………………………………………………………………..
220<ol class="arabic">
<li>220</li>
<li>Allocating Memory Using GUID Extension
HOBs……………………………………. 220 11.3.3
Allocating Memory Using PEI
Service…………………………………………………….
220</li>
</ol>
</li>
</ol>
</li>
<li><p class="first"><strong>Special Paths Unique to the</strong></p>
<p><strong>Itanium:sup:`®` Processor
Family………………………………………………………………221</strong></p>
</li>
</ol>
<ol class="arabic">
<li><p class="first">221</p>
</li>
<li><p class="first">Unique Boot Paths for Itanium
Architecture……………………………………………………….
221</p>
</li>
<li><p class="first">Min-State Save
Area………………………………………………………………………………………
222</p>
<blockquote>
<div><p>EFI_PEI_MIN_STATE_DATA…………………………………………………………………
224</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic simple">
<li>Dispatching Itanium Processor Family
PEIMs…………………………………………………… 226</li>
</ol>
<ol class="arabic simple" start="9">
<li><strong>Security (SEC) Phase Information
…………………………………………………..228</strong><ol class="arabic">
<li>228</li>
<li>Responsibilities……………………………………………………………………………………………..
228<ol class="arabic">
<li>Handling All Platform Restart
Events……………………………………………………..
228</li>
<li>Creating a Temporary Memory
Store……………………………………………………..
228</li>
<li>Serving As the Root of Trust in the System
……………………………………………. 229</li>
<li>Passing Handoff Information to the PEI
Foundation………………………………… 229</li>
</ol>
</li>
<li>229</li>
<li>229</li>
<li>Health Flag Bit
Format……………………………………………………………………………………
229<ol class="arabic">
<li>Self-Test State
Parameter…………………………………………………………………….
231</li>
</ol>
</li>
<li>Processor-Specific
Details………………………………………………………………………………
232<ol class="arabic">
<li>232 13.6.2 SEC Phase in the Itanium Processor Family
………………………………………….. 232</li>
</ol>
</li>
</ol>
</li>
<li><strong>Dependency Expression
Grammar………………………………………………….234</strong><ol class="arabic">
<li>Dependency Expression
Grammar…………………………………………………………………..
234<ol class="arabic">
<li>Example Dependency Expression BNF
Grammar…………………………………… 234 14.1.2
Sample Dependency Expressions
…………………………………………………………
235</li>
</ol>
</li>
</ol>
</li>
<li><strong>TE
Image………………………………………………………………………………………..236</strong><ol class="arabic">
<li>236</li>
<li>PE32
Headers……………………………………………………………………………………………….
236 TE
Header……………………………………………………………………………………………
238</li>
</ol>
</li>
<li><strong>TE Image
Creation………………………………………………………………………….240</strong><ol class="arabic">
<li>240</li>
<li>240 16.3 TE Image
Relocations…………………………………………………………………………………….
240</li>
</ol>
</li>
<li><strong>TE Image
Loading…………………………………………………………………………..241</strong><ol class="arabic">
<li>241</li>
<li>241</li>
<li>Relocated
Images………………………………………………………………………………………….
241</li>
<li>241</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="list-of-figures">
<h1>List of Figures<a class="headerlink" href="#list-of-figures" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>Figure 1. PEI Operations
Diagram…………………………………………………………………………….
10 Figure 2. Typical PEIM Layout in a Firmware File
…………………………………………………….. 101
Figure 3. Itanium Processor Boot Path (INIT and MCHK)
………………………………………….. 222 Figure 4.
Min-State Buffer Organization
…………………………………………………………………..
223 Figure 5. Boot Path in Itanium Processors
……………………………………………………………….
227 Figure 6. Health Flag Bit
Format……………………………………………………………………………..
230 Figure 7. PEI Initialization Steps in
IA-32………………………………………………………………….
232 Figure 8. Security (SEC) Phase in the Itanium Processor Family
……………………………….. 233</div></blockquote>
</div>
<div class="section" id="list-of-tables">
<h1>List of Tables<a class="headerlink" href="#list-of-tables" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Table 1. Organization of the PEI
CIS…………………………………………………………………………..
1 Table 2. SI
prefixes…………………………………………………………………………………………………..
7 Table 3. Binary prefixes
……………………………………………………………………………………………
7 Table 4. PEI Foundation Classes of Service
………………………………………………………………
11 Table 5. PEI Services
……………………………………………………………………………………………..
20</p>
<p>27 Table 7. Dependency Expression Opcode
Summary…………………………………………………..
66 Table 8. PUSH Instruction Encoding
…………………………………………………………………………
67 Table 9. AND Instruction
Encoding……………………………………………………………………………
68</p>
<p>Table 10. OR Instruction
Encoding……………………………………………………………………………
69 Table 11. NOT Instruction
Encoding………………………………………………………………………….
70 Table 12. TRUE Instruction
Encoding………………………………………………………………………..
71 Table 13. FALSE Instruction
Encoding………………………………………………………………………
72 Table 14. END Instruction
Encoding………………………………………………………………………….
73</p>
<p>Table 15. Example Dispatch
Map……………………………………………………………………………..
78 Table 16. PEI PPI Services List
Descriptors……………………………………………………………..
109 Table 17. Organization of the Code Definitions Section
…………………………………………….. 137 Table 18.
Required HOB Types in the HOB
List………………………………………………………..
208 Table 19. Handoff Processor State to the DXE IPL PPI
…………………………………………….. 209 Table 20.
Boot Path
Assumptions……………………………………………………………………………
214 Table 21. Architectural Boot Mode
PPIs…………………………………………………………………..
215 Table 22. Device Recovery Module Functions
………………………………………………………….
218 Table 23. Device Recovery Block I/O
Functions………………………………………………………..
218 Table 24. Health Flag Bit Field
Description……………………………………………………………….
230 Table 25. Self-Test State Bit
Values………………………………………………………………………..
231 Table 26. COFF Header Fields Required for TE
Images……………………………………………. 236</p>
<p>Table 27. Optional Header Fields Required for TE
Images………………………………………… 236</p>
</div></blockquote>
</div>
<div class="section" id="introduction">
<h1>1 Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>1.1 Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>This specification defines the core code and services that are
required for an implementation of the Pre-EFI Initialization (PEI)
phase of the Platform Initialization (PI) specifications (hereafter
referred to as the “PI Architecture”). This PEI core interface
specification (CIS) does the following:</div></blockquote>
<ul class="simple">
<li>Describes the basic components of the PEI phase</li>
<li>Provides code definitions for services and functions that are
architecturally required by the UEFI PI working group (PIWG)</li>
<li>Describes the machine preparation that is required for subsequent
phases of firmware execution</li>
<li>Discusses state variables that describe the system restart type See
“Organization of the PEI CIS,” below, for more information.</li>
</ul>
</div>
<div class="section" id="organization-of-the-pei-cis">
<h2>1.2 Organization of the PEI CIS<a class="headerlink" href="#organization-of-the-pei-cis" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This PEI core interface specification is organized as shown in
<em>Table 1</em>. Because the PEI Foundation is just one component of a PI
Architecture-based firmware solution, there are a number of
additional specifications that are referred to throughout this
document.</p>
<p><strong>Table 1. Organization of the PEI CIS</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Section</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>“Overview” on page 8</em></td>
<td>Describes the major components of PEI, including the PEI Services, boot mode, PEI Dispatcher, and PEIMs.</td>
</tr>
<tr class="row-odd"><td><em>“PEI Services Table” on page 14</em></td>
<td>Describes the data structure that maintains the PEI Services.</td>
</tr>
<tr class="row-even"><td><em>“Services - PEI” on page 20</em></td>
<td>Details each of the functions that comprise the PEI Services.</td>
</tr>
<tr class="row-odd"><td><em>“PEI Foundation” on page 52</em></td>
<td>Describes the PEI Foundation and its methods of operation and the PEI Dispatcher and its associated dependency expression grammar..</td>
</tr>
<tr class="row-even"><td><em>“PEIMs” on page 100</em></td>
<td>Describes the format and use of the Pre-EFI Initialization Module (PEIM).</td>
</tr>
<tr class="row-odd"><td><em>“Architectural PPIs” on page 80</em></td>
<td>Contains PEIM-to-PEIM Interfaces (PPIs) that are used by the PEI Foundation.</td>
</tr>
<tr class="row-even"><td><em>“Additional PPIs” on page 111</em></td>
<td>Contains PPIs that can exist on a platform.</td>
</tr>
<tr class="row-odd"><td><em>“PEI to DXE Handoff” on page 208</em></td>
<td>Describes the state of the machine and memory when the PEI phase invokes the DXE phase.</td>
</tr>
<tr class="row-even"><td><em>“Boot Paths” on page 210</em></td>
<td>Describes the restart modalities and behavior supported in the PEI phase.</td>
</tr>
<tr class="row-odd"><td><em>“PEI Physical Memory Usage” on page 219</em></td>
<td>Describes the memory map and memory usage during the PEI phase.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Section</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><p class="first"><a href="#id9"><span class="problematic" id="id10">*</span></a>“Special Paths Unique to the *</p>
<p class="last"><em>Itanium:sup:`®` Processor Family” on page 221</em></p>
</td>
<td>Contains flow during PEI that is unique to the Itanium® processor family.</td>
</tr>
<tr class="row-odd"><td><em>“Security (SEC) Phase Information” on page 228</em></td>
<td>Contains an overview of the phase of execution that occurs prior to PEI.</td>
</tr>
<tr class="row-even"><td><em>“Dependency Expression Grammar” on page 234</em></td>
<td>Describes the BNF grammar for a tool that can convert a text file containing a dependency expression into a dependency section of a PEIM stored in a firmware volume.</td>
</tr>
<tr class="row-odd"><td><em>“TE Image” on page 236</em></td>
<td>Describes the format of the TE executable.</td>
</tr>
<tr class="row-even"><td><em>“TE Image Creation” on page 240</em></td>
<td>Describes how TE executables are created from PE32+ executables.</td>
</tr>
<tr class="row-odd"><td><em>“TE Image Loading” on page 241</em></td>
<td>Describes how TE executables are loaded into memory.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="conventions-used-in-this-document">
<h2>1.3 Conventions Used in this Document<a class="headerlink" href="#conventions-used-in-this-document" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>This document uses the typographic and illustrative conventions
described below.</div></blockquote>
<div class="section" id="data-structure-descriptions">
<h3>1.3.1 Data Structure Descriptions<a class="headerlink" href="#data-structure-descriptions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Supported processors are “little endian” machines. This distinction
means that the low-order byte of a multibyte data item in memory is
at the lowest address, while the high-order byte is at the highest
address. Some supported processors may be configured for both
“little endian” and “big endian” operation. All implementations
designed to conform to this specification will use “little endian”
operation.</p>
<p>In some memory layout descriptions, certain fields are marked
<em>reserved</em>. Software must initialize such fields to zero and ignore
them when read. On an update operation, software must preserve any
reserved field.</p>
<p>The data structures described in this document generally have the
following format:</p>
</div></blockquote>
<p><strong>STRUCTURE NAME:</strong> The formal name of the data structure.</p>
<p><strong>Summary:</strong> A brief description of the data structure.</p>
<p><strong>Prototype:</strong> A “C-style” type declaration for the data structure.</p>
<p><strong>Parameters:</strong> A brief description of each field in the data structure
prototype.</p>
<blockquote>
<div><p><strong>Description:</strong> A description of the functionality provided by the
data structure, including any limitations and caveats of which the
caller should be aware.</p>
<p><strong>Related Definitions:</strong> The type declarations and constants that
are used only by this data structure.</p>
</div></blockquote>
</div>
<div class="section" id="procedure-descriptions">
<h3>1.3.2 Procedure Descriptions<a class="headerlink" href="#procedure-descriptions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The procedures described in this document generally have the
following format:</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Introduction</strong></p>
<p><strong>ProcedureName():</strong> The formal name of the procedure.</p>
<p><strong>Summary:</strong> A brief description of the procedure.</p>
<blockquote>
<div><p><strong>Prototype:</strong> A “C-style” procedure header defining the calling
sequence. <strong>Parameters:</strong> A brief description of each field in the
procedure prototype. <strong>Description:</strong> A description of the
functionality provided by the interface, including any limitations
and caveats of which the caller should be aware. <strong>Related
Definitions:</strong> The type declarations and constants that are used
only by this procedure.</p>
<p><strong>Status Codes Returned:</strong> A description of any codes returned by
the interface. The</p>
<p>procedure is required to implement any status codes listed in this
table. Additional error codes may be returned, but they will not be
tested by standard compliance tests, and any software that uses the
procedure cannot depend on any of the extended error codes that an
implementation may provide.</p>
</div></blockquote>
</div>
<div class="section" id="instruction-descriptions">
<h3>1.3.3 Instruction Descriptions<a class="headerlink" href="#instruction-descriptions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>A dependency expression instruction description generally has the
following format:</div></blockquote>
<p><strong>InstructionName</strong> The formal name of the instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Syntax:</strong></th>
<th class="head">A brief description of the instruction.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>Description:</strong></td>
<td>A description of the functionality provided by the instruction accompanied by a table that details the instruction encoding.</td>
</tr>
<tr class="row-odd"><td><strong>Operation:</strong></td>
<td>Details the operations performed on operands.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Behaviors and Restrictions:</strong></p>
<p>An item-by-item description of the behavior of each operand involved
in the instruction and any restrictions that apply to the operands
or the instruction.</p>
</div></blockquote>
</div>
<div class="section" id="ppi-descriptions">
<h3>1.3.4 PPI Descriptions<a class="headerlink" href="#ppi-descriptions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>A PEIM-to-PEIM Interface (PPI) description generally has the
following format:</div></blockquote>
<p><strong>PPI Name:</strong> The formal name of the PPI.</p>
<p><strong>Summary:</strong> A brief description of the PPI.</p>
<p><strong>GUID:</strong> The 128-bit Globally Unique Identifier (GUID) for the PPI.</p>
<blockquote>
<div><strong>Protocol Interface Structure:</strong> </div></blockquote>
<p>A “C-style” procedure template defining the PPI calling structure.</p>
<p><strong>Parameters:</strong> A brief description of each field in the PPI structure.</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Description</strong>:</th>
<th class="head">A description of the functionality provided by the interface, including any limitations and caveats of which the caller should be aware.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>Related Definitions:</strong></td>
<td>The type declarations and constants that are used only by this interface.</td>
</tr>
<tr class="row-odd"><td><strong>Status Codes Returned:</strong></td>
<td>A description of any codes returned by the interface. The PPI is required to implement any status codes listed in this table. Additional error codes may be returned, but they will not be tested by standard compliance tests, and any software that uses the procedure cannot depend on any of the extended error codes that an implementation may provide.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pseudo-code-conventions">
<h3>1.3.5 Pseudo-Code Conventions<a class="headerlink" href="#pseudo-code-conventions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Pseudo code is presented to describe algorithms in a more concise
form. None of the algorithms in this document are intended to be
compiled directly. The code is presented at a level corresponding to
the surrounding text.</p>
<p>In describing variables, a <em>list</em> is an unordered collection of
homogeneous objects. A <em>queue</em> is an ordered list of homogeneous
objects. Unless otherwise noted, the ordering is assumed to be First
In First Out (FIFO).</p>
<p>Pseudo code is presented in a C-like format, using C conventions
where appropriate. The coding style, particularly the indentation
style, is used for readability and does not necessarily comply with
an implementation of the <em>Unified Extensible Firmware Interface
Specification</em> (UEFI 2.0 specification).</p>
</div></blockquote>
</div>
<div class="section" id="typographic-conventions">
<h3>1.3.6 Typographic Conventions<a class="headerlink" href="#typographic-conventions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This document uses the typographic and illustrative conventions
described below:</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Plain text</th>
<th class="head">The normal text typeface is used for the vast majority of the descriptive text in a specification.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>Plain text (blue)</em></td>
<td>In the online help version of this specification, any <em>plain text</em> that is underlined and in blue indicates an active link to the cross-reference. Click on the word to follow the hyperlink. Note that these links are <em>not</em> active in the PDF of the specification.</td>
</tr>
<tr class="row-odd"><td><strong>Bold</strong></td>
<td>In text, a <strong>Bold</strong> typeface identifies a processor register name. In other instances, a <strong>Bold</strong> typeface can be used as a running head within a paragraph.</td>
</tr>
<tr class="row-even"><td><em>Italic</em></td>
<td>In text, an <em>Italic</em> typeface can be used as emphasis to introduce a new term or to indicate a manual or specification name.</td>
</tr>
<tr class="row-odd"><td><strong>BOLD Monospace</strong></td>
<td>Computer code, example code segments, and all prototype code segments use a <strong>BOLD Monospace</strong> typeface with a dark red color. These code listings normally appear in one or more separate paragraphs, though words or segments can also be embedded in a normal text paragraph.</td>
</tr>
</tbody>
</table>
<p><strong>Platform Initialization Specification, Vol. 1 Introduction</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>*Bold Monospace*</strong></th>
<th class="head"><p class="first">In the online help version of this specification, words in a</p>
<p><strong>*Bold Monospace*</strong> typeface that is underlined and in blue indicate an active hyperlink to the code definition for that function or type definition. Click on the word to follow the hyperlink. Note that these links are <em>not</em></p>
<p class="last">active in the PDF of the specification. Also, these inactive links in the PDF may instead have a <strong>*Bold Monospace*</strong> appearance that is underlined but in dark red. Again, these links are not active in the PDF of the specification.</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>Italic Monospace</em></td>
<td>In code or in text, words in <em>Italic Monospace</em> indicate placeholder names for variable information that must be supplied (i.e., arguments).</td>
</tr>
<tr class="row-odd"><td>Plain Monospace</td>
<td>In code, words in a Plain Monospace typeface that is a dark red color but is not bold or italicized indicate pseudo code or example code. These code segments typically occur in one or more separate paragraphs.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="requirements">
<h2>1.4 Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This document is an architectural specification that is part of the
Platform Initialization Architecture (PI Architecture) family of
specifications defined and published by the Unified EFI Forum. The
primary intent of the PI Architecture is to present an
interoperability surface for firmware components that may originate
from different providers. As such, the burden to conform to this
specification falls both on the producer and the consumer of
facilities described as part of the specification.</p>
<p>In general, it is incumbent on the producer implementation to ensure
that any facility that a conforming consumer firmware component
might attempt to use is present in the implementation. Equally, it
is incumbent on a developer of a firmware component to ensure that
its implementation relies only on facilities that are defined as
part of the PI Architecture. Maximum interoperability is assured
when collections of conforming components are designed to use only
the required facilities defined in the PI Architecture family of
specifications.</p>
<p>As this document is an architectural specification, care has been
taken to specify architecture in ways that allow maximum flexibility
in implementation for both producer and consumer. However, there are
certain requirements on which elements of this specification must be
implemented to ensure a consistent and predictable environment for
the operation of code designed to work with the architectural
interfaces described here.</p>
<p>For the purposes of describing these requirements, the specification
includes facilities that are required, such as interfaces and data
structures, as well as facilities that are marked as optional.</p>
<p>In general, for an implementation to be conformant with this
specification, the implementation must include functional elements
that match in all respects the complete description of the required
facility descriptions presented as part of the specification. Any
part of the specification that is not explicitly marked as
“optional” is considered a required facility.</p>
<p>Where parts of the specification are marked as “optional,” an
implementation may choose to provide matching elements or leave them
out. If an element is provided by an implementation for a facility,
then it must match in all respects the corresponding complete
description.</p>
<p>In practical terms, this means that for any facility covered in the
specification, any instance of an implementation may only claim to
conform if it follows the normative descriptions completely and
exactly. This does not preclude an implementation that provides
additional functionality, over and above that described in the
specification. Furthermore, it does not preclude an implementation
from leaving out facilities that are marked as optional in the
specification.</p>
<p>By corollary, modular components of firmware designed to function
within an implementation that conforms to the PI Architecture are
conformant only if they depend only on facilities described in this
and related PI Architecture specifications. In other words, any
modular component that is free of any external dependency that falls
outside of the scope of the PI Architecture specifications is
conformant. A modular component is not conformant if it relies for
correct and complete operation upon a reference to an interface or
data structure that is neither part of its own image nor described
in any PI Architecture specifications.</p>
<p>It is possible to make a partial implementation of the specification
where some of the required facilities are not present. Such an
implementation is non-conforming, and other firmware components that
are themselves conforming might not function correctly with it.
Correct operation of non-conforming implementations is explicitly
out of scope for the PI Architecture and this specification.</p>
</div></blockquote>
</div>
<div class="section" id="id11">
<h2>1.5 Conventions used in this document<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<div class="section" id="number-formats">
<h3>1.5.1 Number formats<a class="headerlink" href="#number-formats" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A binary number is represented in this standard by any sequence of
digits consisting of only the Western-Arabic numerals 0 and 1
immediately followed by a lower-case b (e.g., 0101b). Underscores or
spaces may be included between characters in binary number
representations to increase readability or delineate field
boundaries (e.g., 0 0101 1010b or 0_0101_1010b).</p>
<p>A hexadecimal number is represented in this standard by 0x preceding
any sequence of digits consisting of only the Western-Arabic
numerals 0 through 9 and/or the upper-case English letters A through
F (e.g., 0xFA23). Underscores or spaces may be included between
characters in hexadecimal number representations to increase
readability or delineate field boundaries (e.g., 0xB FD8C FA23 or
0xB_FD8C_FA23).</p>
<p>A decimal number is represented in this standard by any sequence of
digits consisting of only the Arabic numerals 0 through 9 not
immediately followed by a lower-case b or lower-case h (e.g., 25).</p>
<p>This standard uses the following conventions for representing
decimal numbers:</p>
</div></blockquote>
<ul class="simple">
<li>the decimal separator (i.e., separating the integer and fractional
portions of the number) is a period;</li>
<li>the thousands separator (i.e., separating groups of three digits in a
portion of the number) is a comma;</li>
<li>the thousands separator is used in the integer portion and is not
used in the fraction portion of a number.</li>
</ul>
</div>
<div class="section" id="binary-prefixes">
<h3>1.5.2 Binary prefixes<a class="headerlink" href="#binary-prefixes" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This standard uses the prefixes defined in the International System
of Units (SI) (see <a class="reference external" href="http://www.bipm.org/en/si/si_brochure/chapter3/prefixes.html">*http://
www.bipm.org/en/si/si_brochure/chapter3/prefixes.html*</a>)
for values that are powers of ten.</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Introduction</strong></p>
<blockquote>
<div><strong>Table 2. SI prefixes</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="27%" />
<col width="22%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a href="#id12"><span class="problematic" id="id13">**</span></a>Factor **</th>
<th class="head"><a href="#id14"><span class="problematic" id="id15">**</span></a>Factor **</th>
<th class="head"><a href="#id16"><span class="problematic" id="id17">**</span></a>Name **</th>
<th class="head"><a href="#id18"><span class="problematic" id="id19">**</span></a>Symbol **</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>103</td>
<td>1,000</td>
<td>kilo</td>
<td>K</td>
</tr>
<tr class="row-odd"><td>10<sup>6</sup></td>
<td>1,000,000</td>
<td>mega</td>
<td>M</td>
</tr>
<tr class="row-even"><td>109</td>
<td>1,000,000,000</td>
<td>giga</td>
<td>G</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This standard uses the binary prefixes defined in ISO/IEC 80000-13
<em>Quantities and units – Part 13: Information science and
technology</em> and IEEE 1514 <em>Standard for Prefixes for Binary
Multiples</em> for values that are powers of two.</p>
<p><strong>Table 3. Binary prefixes</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="27%" />
<col width="22%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a href="#id20"><span class="problematic" id="id21">**</span></a>Factor **</th>
<th class="head"><a href="#id22"><span class="problematic" id="id23">**</span></a>Factor **</th>
<th class="head"><a href="#id24"><span class="problematic" id="id25">**</span></a>Name **</th>
<th class="head"><a href="#id26"><span class="problematic" id="id27">**</span></a>Symbol **</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><sub>2</sub>10</td>
<td>1,024</td>
<td>kibi</td>
<td>Ki</td>
</tr>
<tr class="row-odd"><td><sub>2</sub>20</td>
<td>1,048,576</td>
<td>mebi</td>
<td>Mi</td>
</tr>
<tr class="row-even"><td><sub>2</sub>30</td>
<td>1,073,741,824</td>
<td>gibi</td>
<td>Gi</td>
</tr>
</tbody>
</table>
<blockquote>
<div>For example, 4 KB means 4,000 bytes and 4 KiB means 4,096 bytes.</div></blockquote>
<p>Version 1.7 July 2018</p>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
</div>
<div class="section" id="id28">
<h1>2 Overview<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id29">
<h2>2.1 Introduction<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The Pre-EFI Initialization (PEI) phase of the PI Architecture
specifications (hereafter referred to as the “PI Architecture”) is
invoked quite early in the boot flow. Specifically, after some
preliminary processing in the Security (SEC) phase, any machine
restart event will invoke the PEI phase.</p>
<p>The PEI phase will initially operate with the platform in a nascent
state, leveraging only onprocessor resources, such as the processor
cache as a call stack, to dispatch Pre-EFI Initialization Modules
(PEIMs). These PEIMs are responsible for the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Initializing some permanent memory complement</p>
</li>
<li><p class="first">Describing the memory in Hand-Off Blocks (HOBs)</p>
</li>
<li><p class="first">Describing the firmware volume locations in HOBs</p>
</li>
<li><p class="first">Passing control into the Driver Execution Environment (DXE) phase</p>
<blockquote>
<div><p>Philosophically, the PEI phase is intended to be the thinnest amount
of code to achieve the ends listed above. As such, any more
sophisticated algorithms or processing should be deferred to the DXE
phase of execution.</p>
<p>The PEI phase is also responsible for crisis recovery and resuming
from the S3 sleep state. For crisis recovery, the PEI phase should
reside in some small, fault-tolerant block of the firmware store. As
a result, it is imperative to keep the footprint of the PEI phase as
small as possible. In addition, for a successful S3 resume, the
speed of the resume is of utmost importance, so the code path
through the firmware should be minimized. These two boot flows also
speak to the need to keep the processing and code paths in the PEI
phase to a minimum.</p>
<p>The implementation of the PEI phase is more dependent on the
processor architecture than any other phase. In particular, the more
resources the processor provides at its initial or near initial
state, the richer the interface between the PEI Foundation and
PEIMs. As such, there are several parts of the following discussion
that note requirements on the architecture but are otherwise left
architecturally dependent.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="design-goals">
<h2>2.2 Design Goals<a class="headerlink" href="#design-goals" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The PI Architecture requires the PEI phase to configure a system to
meet the minimum prerequisites for the Driver Execution Environment
(DXE) phase of the PI Architecture architecture. In general, the PEI
phase is required to initialize a linear array of RAM large enough
for the successful execution of the DXE phase elements.</p>
<p>The PEI phase provides a framework to allow vendors to supply
separate initialization modules for each functionally distinct piece
of system hardware that must be initialized prior to the DXE phase
of execution in the PI Architecture. The PEI phase provides a common
framework through which the separate initialization modules can be
independently designed, developed, and updated. The PEI phase was
developed to meet the following goals in the PI architecture:</p>
</div></blockquote>
<p>Version 1.7 July 2018 8 <strong>Platform Initialization Specification, Vol. 1
Overview</strong></p>
<ul class="simple">
<li>Enable maintenance of the “chain of trust.” This includes protection
against unauthorized updates to the PEI phase or its modules, as well
as a form of authentication of the PEI Foundation and its modules
during the PEI phase.</li>
<li>Provide a core PEI module (the PEI Foundation) that will remain more
or less constant for a particular processor architecture but that
will support add-in modules from various vendors, particular for
processors, chipsets, RAM initialization, and so on.</li>
<li>Allow independent development of early initialization modules.</li>
</ul>
</div>
<div class="section" id="pre-efi-initialization-pei-phase">
<h2>2.3 Pre-EFI Initialization (PEI) Phase<a class="headerlink" href="#pre-efi-initialization-pei-phase" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The design for the Pre-EFI Initialization (PEI) phase of a PI
Architecture-compliant boot is as an essentially miniature version
of the DXE phase of the PI Architecture and addresses many of the
same issues. The PEI phase is designed to be developed in several
parts. The PEI phase consists of the following:</div></blockquote>
<ul>
<li><p class="first">Some core code known as the PEI Foundation</p>
</li>
<li><p class="first">Specialized plug-ins known as Pre-EFI Initialization Modules (PEIMs)</p>
<blockquote>
<div><p>Unlike DXE, the PEI phase cannot assume the availability of
reasonable amounts of RAM, so the richness of the features in DXE
does not exist in PEI. The PEI phase limits its support to the
following actions:</p>
</div></blockquote>
</li>
<li><p class="first">Locating, validating, and dispatching PEIMs</p>
</li>
<li><p class="first">Facilitating communication between PEIMs</p>
</li>
<li><p class="first">Providing handoff data to subsequent phases</p>
<blockquote>
<div><p><em>Figure 1</em> below shows a diagram of the process completed during the
PEI phase.</p>
</div></blockquote>
</li>
</ul>
<p>Version 1.7 July 2018</p>
<p><strong>Overview Platform Initialization Specification, Vol. 1</strong></p>
<p><a class="reference internal" href="media/image2.jpg"><img alt="image1" src="media/image2.jpg" style="width: 6.50000in; height: 4.83265in;" /></a></p>
</div>
<div class="section" id="pei-services">
<h2>2.4 PEI Services<a class="headerlink" href="#pei-services" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The PEI Foundation establishes a system table named the PEI Services
Table that is visible to all Pre-EFI Initialization Modules (PEIMs)
in the system. A PEI Service is defined as a function, command, or
other capability manifested by the PEI Foundation when that
service’s initialization requirements are met. Because the PEI phase
has no permanent memory available until nearly the end of the phase,
the range of services created during the PEI phase cannot be as rich
as those created during later phases. Because the location of the
PEI Foundation and its temporary RAM is not known at build time, a
pointer to the PEI Services Table is passed into each PEIM’s entry
point and also to part of each PEIM-to-PEIM Interface (PPI).</p>
<p>The PEI Foundation provides the classes of services listed in <em>Table
4</em>.</p>
</div></blockquote>
<p>10 July 2018 Version 1.7 <strong>Platform Initialization Specification, Vol. 1
Overview</strong></p>
<blockquote>
<div><strong>Table 4. PEI Foundation Classes of Service</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">PPI Services:</th>
<th class="head">Manages PPIs to facilitate intermodule calls between PEIMs. Interfaces are installed and tracked on a database maintained in temporary RAM.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Boot Mode Services:</td>
<td>Manages the boot mode (S3, S5, normal boot, diagnostics, etc.) of the system.</td>
</tr>
<tr class="row-odd"><td>HOB Services:</td>
<td>Creates data structures called Hand-Off Blocks (HOBs) that are used to pass information to the next phase of the PI Architecture.</td>
</tr>
<tr class="row-even"><td>Firmware Volume Services:</td>
<td>Finds PEIMs and other firmware files in the firmware volumes.</td>
</tr>
<tr class="row-odd"><td>PEI Memory Services:</td>
<td>Provides a collection of memory management services for use both before and after permanent memory has been discovered.</td>
</tr>
<tr class="row-even"><td>Status Code Services:</td>
<td>Provides common progress and error code reporting services (for example, port 080h or a serial port for simple text output for debug).</td>
</tr>
<tr class="row-odd"><td>Reset Services:</td>
<td>Provides a common means by which to initiate a warm or cold restart of the system.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pei-foundation">
<h2>2.5 PEI Foundation<a class="headerlink" href="#pei-foundation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The PEI Foundation is the entity that is responsible for the
following:</div></blockquote>
<ul>
<li><p class="first">Successfully dispatching Pre-EFI Initialization Modules (PEIMs)</p>
</li>
<li><p class="first">Maintaining the boot mode</p>
</li>
<li><p class="first">Initializing permanent memory</p>
</li>
<li><p class="first">Invoking the Driver Execution Environment (DXE) loader</p>
<blockquote>
<div><p>The PEI Foundation is written to be portable across all platforms of
a given instruction-set architecture. As such, a binary for 32-bit
Intel<sup>®</sup> architecture (IA-32) should work across all
Pentium<sup>®</sup> processors, from the Pentium II processor with
MMX™ technology through the latest</p>
<p>Pentium 4 processors. Similarly, the PEI Foundation binary for the
Itanium<sup>®</sup> processor family should work across all Itanium
processors.</p>
<p>Regardless of the processor microarchitecture, the set of services
exposed by the PEI Foundation should be the same. This uniform
surface area around the PEI Foundation allows PEIMs to be written in
the C programming language and compiled across any
microarchitecture.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="pei-dispatcher">
<h2>2.6 PEI Dispatcher<a class="headerlink" href="#pei-dispatcher" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The PEI Dispatcher is essentially a state machine that is
implemented in the PEI Foundation. The PEI Dispatcher evaluates the
dependency expressions in Pre-EFI Initialization Modules (PEIMs)
that are in the firmware volume(s) being examined.</p>
<p>The dependency expressions are logical combinations of PEIM-to-PEIM
Interfaces (PPIs). These expressions describe the PPIs that must be
available before a given PEIM can be invoked. To evaluate the
dependency expression for the PEIM, the PEI Dispatcher references
the PPI database in the PEI Foundation to determine which PPIs have
been installed. If the PPI has been installed, the</p>
</div></blockquote>
<p>Version 1.7 July 2018</p>
<p><strong>Overview Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p>dependency expression will evaluate to <strong>TRUE</strong>, which tells the PEI
Dispatcher it can run the PEIM. At this point, the PEI Foundation
passes control to the PEIM with a true dependency expression.</p>
<p>Once the PEI Dispatcher has evaluated all of the PEIMs in all of the
exposed firmware volumes and no more PEIMs can be dispatched (i.e.,
the dependency expressions do not evaluate from <strong>FALSE</strong> to
<strong>TRUE</strong>), the PEI Dispatcher will exit. It is at this point that
the PEI Dispatcher cannot invoke any additional PEIMs. The PEI
Foundation then reassumes control from the PEI Dispatcher and
invokes the DXE IPL PPI to pass control to the DXE phase of
execution.</p>
</div></blockquote>
</div>
<div class="section" id="pre-efi-initialization-modules-peims">
<h2>2.7 Pre-EFI Initialization Modules (PEIMs)<a class="headerlink" href="#pre-efi-initialization-modules-peims" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Pre-EFI Initialization Modules (PEIMs) are specialized drivers that
personalize the PEI Foundation to the platform. They are analogous
to DXE drivers and generally correspond to the components being
initialized. It is the responsibility of the PEI Foundation code to
dispatch the PEIMs in a sequenced order and provide basic services.
The PEIMs are intended to mirror the components being initialized.</p>
<p>Communication between PEIMs is not easy in a “memory poor”
environment. Nonetheless, PEIMs cannot be coded without some
interaction between one another and, even if they could, it would be
inefficient to do so. The PEI phase provides mechanisms for PEIMs to
locate and invoke interfaces from other PEIMs.</p>
<p>Because the PEI phase exists in an environment where minimal
hardware resources are available and execution is performed from the
boot firmware device, it is strongly recommended that PEIMs do the
minimum necessary work to initialize the system to a state that
meets the prerequisites of the DXE phase.</p>
<p>It is expected that, in the future, common practice will be that the
vendor of a software or hardware component will provide the PEIM
(possibly in source form) so the customer can debug integration
problems quickly.</p>
</div></blockquote>
</div>
<div class="section" id="peim-to-peim-interfaces-ppis">
<h2>2.8 PEIM-to-PEIM Interfaces (PPIs)<a class="headerlink" href="#peim-to-peim-interfaces-ppis" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>PEIMs communicate with each other using a structure called a
PEIM-to-PEIM Interface (PPI). PPIs are contained in a
<strong>EFI_PEI_PPI_DESCRIPTOR</strong> data structure, which is composed of a
GUID/ pointer pair. The GUID “names” the interface and the
associated pointer provides the associated data structure and/or
service set for that PPI. A consumer of a PPI must use the PEI
Service</p>
<p><strong>LocatePpi()</strong> to discover the PPI of interest. The producer of a
PPI publishes the available PPIs in its PEIM using the PEI Services
<strong>InstallPpi()</strong> or <strong>ReinstallPpi()</strong>.</p>
<p>All PEIMs are registered and located in the same fashion, namely
through the PEI Services listed above. Within this name space of
PPIs, there are two classes of PPIs:</p>
</div></blockquote>
<ul>
<li><p class="first">Architectural PPIs</p>
</li>
<li><p class="first">Additional PPIs</p>
<blockquote>
<div><p>An <em>architectural PPI</em> is a PPI whose GUID is described in the PEI
CIS and is a GUID known to the</p>
<p>PEI Foundation. These architectural PPIs typically provide a common
interface to the PEI Foundation of a service that has a
platform-specific implementation, such as the PEI Service</p>
<p><strong>ReportStatusCode()</strong>.</p>
</div></blockquote>
</li>
</ul>
<p>12 Version 1.7 <strong>Overview</strong></p>
<blockquote>
<div><em>Additional PPIs</em> are PPIs that are important for interoperability
but are not depended upon by the PEI Foundation. They can be
classified as mandatory or optional. Specifically, to have a large
class of interoperable PEIMs, it would be good to signal that the
final boot mode was installed in some standard fashion so that PEIMs
could use this PPI in their dependency expressions. The alternative
to defining these additional PPIs in the PEI CIS would be to have a
proliferation of similar services under different names.</div></blockquote>
</div>
<div class="section" id="firmware-volumes">
<h2>2.9 Firmware Volumes<a class="headerlink" href="#firmware-volumes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Pre-EFI Initialization Modules (PEIMs) reside in firmware volumes
(FVs). The PEI phase supports the ability for PEIMs to reside in
multiple firmware volumes.. Other PEIMs can expose firmware volumes
for use by the PEI Foundation.</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
<div class="section" id="pei-services-table">
<h1>3 PEI Services Table<a class="headerlink" href="#pei-services-table" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id30">
<h2>3.1 Introduction<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The PEI Foundation establishes a system table named the PEI Services
Table that is visible to all Pre-EFI Initialization Modules (PEIMs)
in the system. A PEI Service is defined as a function, command, or
other capability manifested by the PEI Foundation when that
service’s initialization requirements are met. Because the PEI phase
has no permanent memory available until nearly the end of the phase,
the range of services created during the PEI phase cannot be as rich
as those created during later phases. Because the location of the
PEI Foundation and its temporary RAM is not known at build time, a
pointer to the PEI Services Table is passed into each PEIM’s entry
point and also to part of each PEIM-to-PEIM Interface (PPI).</div></blockquote>
<p><strong>*Note:</strong> In the PEI Foundation use of the* <strong>EFI_TABLE_HEADER</strong> <em>for
the PEI Services Table, there is special treatment of the CRC32 field.
This value is ignorable for PEI and should be set to zero.</em></p>
</div>
<div class="section" id="id31">
<h2>3.2 PEI Services Table<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<div class="section" id="efi-pei-services">
<h3>3.2.1 EFI_PEI_SERVICES<a class="headerlink" href="#efi-pei-services" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The PEI Services Table includes a list of function pointers in a
table. The table is located in the temporary or permanent memory,
depending upon the capabilities and phase of execution of PEI. The
functions in this table are defined in <em>“Services - PEI” on page
20</em>.</p>
<p><strong>Related Definitions</strong></p>
<p><strong>//</strong></p>
<p><strong>// PEI Specification Revision information</strong></p>
<p><strong>//</strong></p>
<p><strong>#define PEI_SPECIFICATION_MAJOR_REVISION 1</strong></p>
<p><strong>#define PEI_SPECIFICATION_MINOR_REVISION 70</strong></p>
<p><strong>//</strong></p>
<p><strong>// UEFI PEI Services Table</strong></p>
<p><strong>//</strong></p>
<p><strong>#define PEI_SERVICES_SIGNATURE 0x5652455320494550</strong></p>
<p><a href="#id32"><span class="problematic" id="id33">**</span></a>#define ((PEI_SPECIFICATION_MAJOR_REVISION&lt;&lt;17) | **</p>
<p><strong>(PEI_SPECIFICATION_MINOR_REVISION))</strong></p>
<p><strong>typedef EFI_PEI_SERVICES {</strong></p>
<p><strong>EFI_TABLE_HEADER</strong> <em>Hdr;</em></p>
<p><strong>//</strong></p>
<p><strong>// PPI Functions</strong></p>
</div></blockquote>
<p>Version 1.7 14</p>
<p><strong>//</strong></p>
<p><strong>EFI_PEI_INSTALL_PPI</strong> <em>InstallPpi;</em></p>
<p><strong>EFI_PEI_REINSTALL_PPI</strong> <em>ReInstallPpi;</em></p>
<p><strong>EFI_PEI_LOCATE_PPI</strong> <em>LocatePpi;</em></p>
<p><strong>EFI_PEI_NOTIFY_PPI</strong> <em>NotifyPpi;</em></p>
<p><strong>//</strong></p>
<p><strong>// Boot Mode Functions</strong></p>
<p><strong>//</strong></p>
<p><strong>EFI_PEI_GET_BOOT_MODE</strong> <em>GetBootMode;</em></p>
<p><strong>EFI_PEI_SET_BOOT_MODE</strong> <em>SetBootMode;</em></p>
<p><strong>//</strong></p>
<p><strong>// HOB Functions</strong></p>
<p><strong>//</strong></p>
<p><strong>EFI_PEI_GET_HOB_LIST</strong> <em>GetHobList;</em></p>
<p><strong>EFI_PEI_CREATE_HOB</strong> <em>CreateHob;</em></p>
<p><strong>//</strong></p>
<p><strong>// Firmware Volume Functions</strong></p>
<p><strong>//</strong></p>
<p><strong>EFI_PEI_FFS_FIND_NEXT_VOLUME2</strong> <em>FfsFindNextVolume;</em></p>
<p><strong>EFI_PEI_FFS_FIND_NEXT_FILE2</strong> <em>FfsFindNextFile;</em></p>
<p><strong>EFI_PEI_FFS_FIND_SECTION_DATA2</strong> <em>FfsFindSectionData;</em></p>
<p><strong>//</strong></p>
<p><strong>// PEI Memory Functions</strong></p>
<p><strong>//</strong></p>
<p><strong>EFI_PEI_INSTALL_PEI_MEMORY</strong> <em>InstallPeiMemory;</em></p>
<p><strong>EFI_PEI_ALLOCATE_PAGES</strong> <em>AllocatePages;</em></p>
<p><strong>EFI_PEI_ALLOCATE_POOL</strong> <em>AllocatePool;</em></p>
<p><strong>EFI_PEI_COPY_MEM</strong> <em>CopyMem;</em></p>
<p><strong>EFI_PEI_SET_MEM</strong> <em>SetMem;</em></p>
<p><strong>//</strong></p>
<p><strong>// Status Code</strong></p>
<p><strong>EFI_PEI_REPORT_STATUS_CODE</strong> <em>ReportStatusCode;</em></p>
<p><strong>//</strong></p>
<p><a href="#id34"><span class="problematic" id="id35">**</span></a>// Reset **</p>
<p><strong>//</strong></p>
<p><strong>EFI_PEI_RESET_SYSTEM</strong> <em>ResetSystem;</em></p>
<p></p>
<p><strong>//</strong></p>
<p><strong>// (the following interfaces are installed by publishing PEIM)</strong></p>
<p><strong>//</strong></p>
<p><strong>// I/O Abstractions</strong></p>
<p><strong>PEI Services Table Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>//</strong></p>
<p><strong>EFI_PEI_CPU_IO_PPI</strong> <em>*CpuIo;</em></p>
<p><strong>EFI_PEI_PCI_CFG2_PPI</strong> <em>*PciCfg;</em></p>
<p></p>
<p><strong>//</strong></p>
<p><strong>// Additional File System-Related Services</strong></p>
<p><strong>//</strong></p>
<p><strong>EFI_PEI_FFS_FIND_BY_NAME</strong> <em>FfsFindFileByName</em>;</p>
<p><strong>EFI_PEI_FFS_GET_FILE_INFO</strong> <em>FfsGetFileInfo</em>;</p>
<p><strong>EFI_PEI_FFS_GET_VOLUME_INFO</strong> <em>FfsGetVolumeInfo</em>;</p>
<p><strong>EFI_PEI_REGISTER_FOR_SHADOW</strong> <em>RegisterForShadow</em>;</p>
<p><strong>EFI_PEI_FFS_FIND_SECTION_DATA3</strong> <em>FindSectionData3</em><strong>;</strong></p>
<p><strong>EFI_PEI_FFS_GET_FILE_INFO2</strong> <em>FfsGetFileInfo2</em><strong>;</strong></p>
<p><strong>EFI_PEI_RESET2_SYSTEM</strong> <em>ResetSystem2</em><strong>;</strong></p>
<p><strong>EFI_PEI_FREE_PAGES FreePages;</strong></p>
<p><strong>} EFI_PEI_SERVICES;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Hdr</em></p>
<p>The table header for the PEI Services Table. This header contains
the</p>
<p><strong>PEI_SERVICES_SIGNATURE</strong> and <strong>PEI_SERVICES_REVISION</strong> values
along</p>
<p>with the size of the <strong>EFI_PEI_SERVICES</strong> structure and a 32-bit
CRC to verify that the contents of the PEI Foundation Services Table
are valid.</p>
<p><em>InstallPpi</em></p>
<p>Installs an interface in the PEI PEIM-to-PEIM Interface (PPI)
database by GUID. See the <strong>InstallPpi()</strong> function description in
this document.</p>
<p><em>ReInstallPpi</em></p>
<p>Reinstalls an interface in the PEI PPI database by GUID. See the
<strong>ReinstallPpi()</strong> function description in this document.</p>
<p><a href="#id36"><span class="problematic" id="id37">*</span></a>LocatePpi *</p>
<p>Locates an interface in the PEI PPI database by GUID. See the
<strong>LocatePpi()</strong> function description in this document.</p>
<p><a href="#id38"><span class="problematic" id="id39">*</span></a>NotifyPpi *</p>
<p>Installs the notification service to be called back upon the
installation or reinstallation of a given interface. See the
<strong>NotifyPpi()</strong> function description in this document.</p>
<p><a href="#id40"><span class="problematic" id="id41">*</span></a>GetBootMode *</p>
<p>Returns the present value of the boot mode. See the
<strong>GetBootMode()</strong> function description in this document.</p>
<p><a href="#id42"><span class="problematic" id="id43">*</span></a>SetBootMode *</p>
<p>Sets the value of the boot mode. See the <strong>SetBootMode()</strong> function
description in this document.</p>
</div></blockquote>
<p>16 Version 1.7</p>
<p><a href="#id44"><span class="problematic" id="id45">*</span></a>GetHobList *</p>
<blockquote>
<div>Returns the pointer to the list of Hand-Off Blocks (HOBs) in memory.
See the <strong>GetHobList()</strong> function description in this document.</div></blockquote>
<p><a href="#id46"><span class="problematic" id="id47">*</span></a>CreateHob *</p>
<blockquote>
<div>Abstracts the creation of HOB headers. See the <strong>CreateHob()</strong>
function description in this document.</div></blockquote>
<p><a href="#id48"><span class="problematic" id="id49">*</span></a>FfsFindNextVolume *</p>
<p>Discovers instances of firmware volumes in the system. See the
<strong>FfsFindNextVolume()</strong> function description in this document.
<a href="#id50"><span class="problematic" id="id51">*</span></a>FfsFindNextFile *</p>
<blockquote>
<div>Discovers instances of firmware files in the system. See the
<strong>FfsFindNextFile()</strong> function description in this document.</div></blockquote>
<p><a href="#id52"><span class="problematic" id="id53">*</span></a>FfsFindSectionData *</p>
<blockquote>
<div>Searches for a section in a firmware file. See the
<strong>FfsFindSectionData()</strong> function description in this document.</div></blockquote>
<p><a href="#id54"><span class="problematic" id="id55">*</span></a>InstallPeiMemory *</p>
<blockquote>
<div>Registers the found memory configuration with the PEI Foundation.
See the <strong>InstallPeiMemory()</strong> function description in this
document.</div></blockquote>
<p><a href="#id56"><span class="problematic" id="id57">*</span></a>AllocatePages *</p>
<blockquote>
<div>Allocates memory ranges that are managed by the PEI Foundation. See
the <strong>AllocatePages()</strong> function description in this document.</div></blockquote>
<p><a href="#id58"><span class="problematic" id="id59">*</span></a>AllocatePool *</p>
<blockquote>
<div>Frees memory ranges that are managed by the PEI Foundation. See the
<strong>AllocatePool()</strong> function description in this document.</div></blockquote>
<p><a href="#id60"><span class="problematic" id="id61">*</span></a>CopyMem *</p>
<blockquote>
<div>Copies the contents of one buffer to another buffer. See the
<strong>CopyMem()</strong> function description in this document.</div></blockquote>
<p><a href="#id62"><span class="problematic" id="id63">*</span></a>SetMem *</p>
<blockquote>
<div>Fills a buffer with a specified value. See the <strong>SetMem()</strong> function
description in this document.</div></blockquote>
<p><a href="#id64"><span class="problematic" id="id65">*</span></a>ReportStatusCode *</p>
<blockquote>
<div>Provides an interface that a PEIM can call to report a status code.
See the <strong>ReportStatusCode()</strong> function description in this
document. This is installed by provider PEIM by copying the
interface into the PEI Service table.</div></blockquote>
<p><em>ResetSystem</em></p>
<blockquote>
<div>Resets the entire platform. See the <strong>ResetSystem()</strong> function
description in this document. This is installed by provider PEIM by
copying the interface into the PEI Service table.</div></blockquote>
<p><strong>PEI Services Table Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><em>ResetSystem2</em></p>
<p>Resets the entire platform. See the <strong>ResetSystem2()</strong> function
description in this document. This is installed by provider PEIM by
copying the interface into the PEI Service table.</p>
<p><a href="#id66"><span class="problematic" id="id67">*</span></a>CpuIo *</p>
<p>Provides an interface that a PEIM can call to execute an I/O
transaction. This interface is installed by provider PEIM by copying
the interface into the PEI Service table.</p>
<p><em>PciCfg</em></p>
<p>Provides an interface that a PEIM can call to execute PCI
Configuration transactions. This interface is installed by provider
PEIM by copying the interface into the</p>
<p><strong>EFI_PEI_SERVICES</strong> table.</p>
<p><em>FfsFindFileByName</em></p>
<p>Discovers firmware files within a volume by name. See
<strong>FfsFindFileByName()</strong> in this document.</p>
<p><em>FfsGetFileInfo</em></p>
<p>Return information about a particular file. See <strong>FfsGetFileInfo()</strong>
in this document.</p>
<p><em>FfsGetFileInfo2</em></p>
<p>Return information about a particular file. See
<strong>FfsGetFileInfo2()</strong> in this document.</p>
<p><em>FfsGetVolumeInfo</em></p>
<p>Return information about a particular volume. See
<strong>FfsGetVolumeInfo()</strong> in this document.</p>
<p><em>RegisterForShadow</em></p>
<p>Register a driver to be re-loaded when memory is available. See
<strong>RegisterForShadow()</strong> in this document.</p>
<p><em>FindSectionData3</em></p>
<p>Searches for a section in a firmware file. See the
<strong>FfsFindSectionData3()</strong> function description in this document.</p>
<p><em>FreePages</em></p>
<p>Releases memory previously allocated using AllocatePages().</p>
<p><strong>Description</strong></p>
<p><strong>EFI_PEI_SERVICES</strong> is a collection of functions whose
implementation is provided by the PEI Foundation. These services
fall into various classes, including the following:</p>
</div></blockquote>
<ul class="simple">
<li>Managing the boot mode</li>
</ul>
<p>18 Version 1.7</p>
<ul>
<li><p class="first">Allocating both early and permanent memory</p>
</li>
<li><p class="first">Supporting the Firmware File System (FFS)</p>
</li>
<li><p class="first">Abstracting the PPI database abstraction</p>
</li>
<li><p class="first">Creating Hand-Off Blocks (HOBs)</p>
<blockquote>
<div><p>A pointer to the <strong>EFI_PEI_SERVICES</strong> table is passed into each
PEIM when the PEIM is invoked by the PEI Foundation. As such, every
PEIM has access to these services. Unlike the UEFI Boot Services,
the PEI Services have no calling restrictions, such as the UEFI 2.0
Task Priority Level (TPL) limitations. Specifically, a service can
be called from a PEIM or notification service.</p>
<p>Some of the services are also a proxy to platform-provided services,
such as the Reset Services, Status Code Services, and I/O
abstractions. This partitioning has been designed to provide a
consistent interface to all PEIMs without encumbering a PEI
Foundation implementation with platform-specific knowledge. Any
callable services beyond the set in this table should be invoked
using a PPI. The latter PEIM-installed services will return
<strong>EFI_NOT_AVAILABLE_YET</strong> until a PEIM copies an instance of the
interface into the <strong>EFI_PEI_SERVICES</strong> table.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
</div>
<div class="section" id="services-pei">
<h1>4 Services - PEI<a class="headerlink" href="#services-pei" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id68">
<h2>4.1 Introduction<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A PEI Service is defined as a function, command, or other capability
created by the PEI Foundation during a phase that remains available
after the phase is complete. Because the PEI phase has no permanent
memory available until nearly the end of the phase, the range of PEI
Foundation Services created during the PEI phase cannot be as rich
as those created during later phases.</p>
<p><em>Table 5</em> shows the PEI Services described in this section:</p>
<p><strong>Table 5. PEI Services</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">PPI Services:</th>
<th class="head">Manages PEIM-to-PEIM Interface (PPIs) to facilitate intermodule calls between PEIMs. Interfaces are installed and tracked on a database maintained in temporary RAM.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Boot Mode Services:</td>
<td>Manages the boot mode (S3, S5, normal boot, diagnostics, etc.) of the system.</td>
</tr>
<tr class="row-odd"><td>HOB Services:</td>
<td>Creates data structures called Hand-Off Blocks (HOBs) that are used to pass information to the next phase of the PI Architecture.</td>
</tr>
<tr class="row-even"><td>Firmware Volume Services</td>
<td>Walks the Firmware File Systems (FFS) in firmware volumes to find PEIMs and other firmware files in the flash device.</td>
</tr>
<tr class="row-odd"><td>PEI Memory Services:</td>
<td>Provides a collection of memory management services for use both before and after permanent memory has been discovered.</td>
</tr>
<tr class="row-even"><td>Status Code Services:</td>
<td>Provides common progress and error code reporting services (for example, port 080h or a serial port for simple text output for debug).</td>
</tr>
<tr class="row-odd"><td>Reset Services:</td>
<td>Provides a common means by which to initiate a warm or cold restart of the system.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The calling convention for PEI Services is similar to PPIs. See
<em>“PEIM-to-PEIM Communication” on page 109</em> for more details on PPIs.</p>
<p>The means by which to bind a service call into a service involves a
dispatch table, <strong>EFI_PEI_SERVICES.</strong>A pointer to the table is
passed into the PEIM entry point.</p>
</div></blockquote>
</div>
<div class="section" id="ppi-services">
<h2>4.2 PPI Services<a class="headerlink" href="#ppi-services" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The following services provide the interface set for abstracting the
PPI database:</div></blockquote>
<ul class="simple">
<li>InstallPpi()</li>
<li>ReinstallPpi()</li>
<li>LocatePpi()</li>
<li>NotifyPpi()</li>
</ul>
<p>Version 1.7 20</p>
<div class="section" id="installppi">
<h3>InstallPpi()<a class="headerlink" href="#installppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service is the first one provided by the PEI Foundation. This
function installs an interface in the PEI PPI database by GUID. The
purpose of the service is to publish an interface that other parties
can use to call additional PEIMs.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_INSTALL_PPI) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_PPI_DESCRIPTOR</strong> <em>*PpiList</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>PpiList</em></p>
<p>A pointer to the list of interfaces that the caller shall install.
Type</p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR</strong> is defined in <em>“PEIM Descriptors” on
page 104</em>.</p>
<p><strong>Description</strong></p>
<p>This service enables a given PEIM to register an interface with the
PEI Foundation. The interface takes a pointer to a list of records
that adhere to the format of a <strong>EFI_PEI_PPI_DESCRIPTOR</strong>.</p>
<p>Since the PEI Foundation maintains a pointer to the list rather than
copying the list, the list must either be in the body of the PEIM or
else allocated from temporary or permanent RAM.</p>
<p>The length of the list of described by the
<strong>EFI_PEI_PPI_DESCRIPTOR</strong> that has the</p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST</strong> flag set in its
<em>Flags</em> field. There shall be at least one
<strong>EFI_PEI_PPI_DESCRIPTOR</strong> in the list.</p>
<p>There are two types of <strong>EFI_PEI_PPI_DESCRIPTOR</strong>s that can be
installed, including the
<strong>EFI_PEI_PPI_DESCRIPTOR_NOTIFY_DISPATCH</strong> and
<strong>EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK</strong>.</p>
</div></blockquote>
<p><strong>Services - PEI Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The interface was successfully installed.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>The <em>PpiList</em> pointer is <strong>NULL</strong>.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><p class="first">Any of the PEI PPI descriptors in the list do not have the</p>
<p class="last"><strong>EFI_PEI_PPI_DESCRIPTOR_PPI</strong> bit set in the <em>Flags</em> field.</p>
</td>
</tr>
<tr class="row-even"><td>EFI_OUT_OF_RESOURCES</td>
<td>There is no additional space in the PPI database.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reinstallppi">
<h3>ReinstallPpi()<a class="headerlink" href="#reinstallppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This function reinstalls an interface in the PEI PPI database by
GUID. The purpose of the service is to publish an interface that
other parties can use to replace an interface of the same name in
the protocol database with a different interface.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_REINSTALL_PPI) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_PPI_DESCRIPTOR</strong> <em>*OldPpi,</em></p>
<p><strong>IN CONST EFI_PEI_PPI_DESCRIPTOR</strong> <em>*NewPpi</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>OldPpi</em></p>
<p>A pointer to the former PPI in the database. Type
<strong>EFI_PEI_PPI_DESCRIPTOR</strong> is defined in <em>“PEIM Descriptors” on
page 104</em>.</p>
<p><em>NewPpi</em></p>
<p>A pointer to the new interfaces that the caller shall install.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to replace an entry in the PPI database
with an alternate entry.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The interface was successfully installed.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>The <em>OldPpi or NewPpi</em> pointer is <strong>NULL</strong>.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><p class="first">Any of the PEI PPI descriptors in the list do not have the</p>
<p class="last"><strong>EFI_PEI_PPI_DESCRIPTOR_PPI</strong> bit set in the <em>Flags</em> field.</p>
</td>
</tr>
<tr class="row-even"><td>EFI_OUT_OF_RESOURCES</td>
<td>There is no additional space in the PPI database.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>The PPI for which the reinstallation was requested has not been installed.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="locateppi">
<h3>LocatePpi()<a class="headerlink" href="#locateppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This function locates an interface in the PEI PPI database by GUID.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_LOCATE_PPI) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_GUID</strong> <em>*Guid,</em></p>
<p><strong>IN UINTN</strong> <em>Instance,</em></p>
<p><strong>IN OUT EFI_PEI_PPI_DESCRIPTOR</strong> <em>**PpiDescriptor</em>
<strong>OPTIONAL</strong><em>,</em></p>
<p><strong>IN OUT VOID</strong> <em>**Ppi</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>Guid</em></p>
<p>A pointer to the GUID whose corresponding interface needs to be
found.</p>
<p><em>Instance</em></p>
<p>The N-th instance of the interface that is required.</p>
<p><em>PpiDescriptor</em></p>
<p>A pointer to instance of the <strong>EFI_PEI_PPI_DESCRIPTOR</strong>. <em>Ppi</em></p>
<p>A pointer to the instance of the interface.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to discover a given instance of an
interface. This interface differs from the interface discovery
mechanism in the UEFI 2.0 specification<em>,</em> namely
<strong>HandleProtocol()</strong>, in</p>
</div></blockquote>
<p><strong>Services - PEI Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p>that the PEI PPI database does not expose the handle’s name space.
Instead, PEI manages the interface set by maintaining a partial
order on the interfaces such that the <em>Instance</em> of the interface,
among others, can be traversed.</p>
<p><strong>LocatePpi()</strong> provides the ability to traverse all of the
installed instances of a given GUID-named PPI. For example, there
can be multiple instances of a PPI named <em>Foo</em> in the PPI database.
An</p>
<p><em>Instance</em> value of 0 will provide the first instance of the PPI
that is installed. Correspondingly, an <em>Instance</em> value of 2 will
provide the second, 3 the third, and so on. The <em>Instance</em> value
designates when a PPI was installed. For an implementation that must
reference all possible manifestations of a given GUID-named PPI, the
code should invoke <strong>LocatePpi()</strong> with a monotonically increasing
<em>Instance</em> number until <strong>EFI_NOT_FOUND</strong> is returned.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The interface was successfully returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The PPI descriptor is not found in the database.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="notifyppi">
<h3>NotifyPpi()<a class="headerlink" href="#notifyppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This function installs a notification service to be called back when
a given interface is installed or reinstalled. The purpose of the
service is to publish an interface that other parties can use to
call additional PPIs that may materialize later.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_NOTIFY_PPI) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_NOTIFY_DESCRIPTOR</strong> <em>*NotifyList</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>NotifyList</em></p>
<p>A pointer to the list of notification interfaces that the caller
shall install. Type</p>
</div></blockquote>
<p><strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong> is defined in <em>“PEIM Descriptors” on
page 104</em>.</p>
<blockquote>
<div><p><strong>Description</strong></p>
<p>This service enables PEIMs to register a given service to be invoked
when another service is installed or reinstalled. This service will
fire notifications on PPIs installed prior to this service
invocation. This is different behavior than the
RegisterProtocolNotify of UEFI2.0, for example
<strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong> is defined in <em>“PEIM Descriptors”
on page 104</em>.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<blockquote>
<div><p>In addition, the PPI pointer is passed back to the agent that
registered for the notification so that it can deference private
data, if so needed.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The interface was successfully installed.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>The <em>NotifyList</em> pointer is <strong>NULL</strong>.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><p class="first">Any of the PEI notify descriptors in the list do not have the</p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR_NOTIFY_TYPES</strong> bit</p>
<p class="last">set in the <em>Flags</em> field.</p>
</td>
</tr>
<tr class="row-even"><td>EFI_OUT_OF_RESOURCES</td>
<td>There is no additional space in the PPI database.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="boot-mode-services">
<h2>4.3 Boot Mode Services<a class="headerlink" href="#boot-mode-services" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>These services provide abstraction for ascertaining and updating the
boot mode:</div></blockquote>
<ul>
<li><p class="first">GetBootMode()</p>
</li>
<li><p class="first">SetBootMode()</p>
<blockquote>
<div><p>See <em>“Boot Paths” on page 210</em> for additional information on the
boot mode.</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="getbootmode">
<h3>GetBootMode()<a class="headerlink" href="#getbootmode" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This function returns the present value of the boot mode.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GET_BOOT_MODE) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>OUT EFI_BOOT_MODE</strong> <em>*BootMode</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>BootMode</em></p>
<p>A pointer to contain the value of the boot mode. Type
<strong>EFI_BOOT_MODE</strong> is defined in “Related Definitions” below.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to ascertain the present value of the
boot mode. The list of possible boot modes is described in “Related
Definitions” below.</p>
</div></blockquote>
<p><strong>Services - PEI Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>Related Definitions</strong></p>
<p><strong>//************************************************************</strong></p>
<p><strong>// EFI_BOOT_MODE</strong></p>
<p><strong>//************************************************************
typedef UINT32 EFI_BOOT_MODE;</strong></p>
<p><strong>#define BOOT_WITH_FULL_CONFIGURATION 0x00</strong></p>
<p><strong>#define BOOT_WITH_MINIMAL_CONFIGURATION 0x01</strong></p>
<p><strong>#define BOOT_ASSUMING_NO_CONFIGURATION_CHANGES 0x02</strong></p>
<p><strong>#define BOOT_WITH_FULL_CONFIGURATION_PLUS_DIAGNOSTICS 0x03</strong></p>
<p><strong>#define BOOT_WITH_DEFAULT_SETTINGS 0x04</strong></p>
<p><strong>#define BOOT_ON_S4_RESUME 0x05</strong></p>
<p><strong>#define BOOT_ON_S5_RESUME 0x06</strong></p>
<p><strong>#define BOOT_WITH_MFG_MODE_SETTINGS 0x07</strong></p>
<p><strong>#define BOOT_ON_S2_RESUME 0x10</strong></p>
<p><strong>#define BOOT_ON_S3_RESUME 0x11</strong></p>
<p><strong>#define BOOT_ON_FLASH_UPDATE 0x12</strong></p>
<p><strong>#define BOOT_IN_RECOVERY_MODE 0x20</strong></p>
<p><strong>0x21 – 0xF..F Reserved Encodings</strong></p>
<p><em>Table 6</em> describes the bit values in the Boot Mode Register.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<blockquote>
<div><strong>Table 6. Boot Mode Register</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="19%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Register Bits</strong></th>
<th class="head"><strong>Values</strong></th>
<th class="head"><strong>Descriptions</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MSBit-0</td>
<td>000000b</td>
<td>Boot with full configuration</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>000001b</td>
<td>Boot with minimal configuration</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>000010b</td>
<td>Boot assuming no configuration changes from last boot</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>000011b</td>
<td>Boot with full configuration plus diagnostics</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>000100b</td>
<td>Boot with default settings</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>000101b</td>
<td>Boot on S4 resume</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>000110b</td>
<td>Boot in S5 resume</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>000111b</td>
<td>Boot with manufacturing mode settings</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>000111b-001111b</td>
<td>Reserved for boot paths that configure memory</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>010000b</td>
<td>Boot on S2 resume</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>010001b</td>
<td>Boot on S3 resume</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>010010b</td>
<td>Boot on flash update restart</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>010011c-011111b</td>
<td>Reserved for boot paths that preserve memory context</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>100000b</td>
<td>Boot in recovery mode</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>100001b-111111b</td>
<td>Reserved for special boots</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EFI_SUCCESS</td>
<td>The boot mode was returned successfully.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="setbootmode">
<h3>SetBootMode()<a class="headerlink" href="#setbootmode" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This function sets the value of the boot mode.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_SET_BOOT_MODE) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_BOOT_MODE</strong> <em>BootMode</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>BootMode</em></p>
<p>The value of the boot mode to set. Type <strong>EFI_BOOT_MODE</strong> is
defined in <strong>GetBootMode()</strong>.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to update the boot mode variable. This
would be used by either the boot mode PPIs described in
<em>“Architectural PPIs” on page 80</em> or by a PEIM that needs to
engender a recovery condition. It is permissible to change the boot
mode at any point during the PEI phase.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EFI_SUCCESS</td>
<td>The value was successfully updated.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="hob-services">
<h2>4.4 HOB Services<a class="headerlink" href="#hob-services" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The following services describe the capabilities in the PEI
Foundation for providing Hand-Off Block (HOB) manipulation:</div></blockquote>
<ul>
<li><p class="first">GetHobList()</p>
</li>
<li><p class="first">CreateHob()</p>
<blockquote>
<div><p>The purpose of the abstraction is to automate the common case of HOB
creation and manipulation. See the <em>Volume 3</em> for details on HOBs
and their type definitions.</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="gethoblist">
<h3>GetHobList()<a class="headerlink" href="#gethoblist" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This function returns the pointer to the list of Hand-Off Blocks
(HOBs) in memory.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GET_HOB_LIST) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN OUT VOID</strong> <em>**HobList</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>HobList</em></p>
<p>A pointer to the list of HOBs that the PEI Foundation will
initialize.</p>
<p><strong>Description</strong></p>
<p>This service enables a PEIM to ascertain the address of the list of
HOBs in memory. This service should not be required by many modules
in that the creation of HOBs is provided by the PEI Service</p>
<p><strong>CreateHob()</strong>.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The list was successfully returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_AVAILABLE_YET</td>
<td>The HOB list is not yet published.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="createhob">
<h3>CreateHob()<a class="headerlink" href="#createhob" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service published by the PEI Foundation abstracts the creation
of a Hand-Off Block’s (HOB’s) headers.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CREATE_HOB) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN UINT16</strong> <em>Type,</em></p>
<p><strong>IN UINT16</strong> <em>Length,</em></p>
<p><strong>IN OUT VOID</strong> <em>**Hob</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>Type</em></p>
<p>The type of HOB to be installed. See the <em>Volume 3</em> for a definition
of this type.</p>
<p><em>Length</em></p>
<p>The length of the HOB to be added.</p>
<p><em>Hob</em></p>
<p>The address of a pointer that will contain the HOB header.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to create various types of HOBs. This
service handles the common work of allocating memory on the HOB
list, filling in the type and length fields, and building the end of
the HOB list. The final aspect of this service is to return a
pointer to the newly allocated HOB. At this point, the caller can
fill in the type-specific data. This service is always available
because the HOBs can also be created on temporary memory.</p>
<p>There will be no error checking on the <em>Length</em> input argument.
Instead, the PI Architecture implementation of this service will
round up the allocation size that is specified in the <em>Length</em> field
to be a multiple of 8 bytes in length. This rounding is consistent
with the requirement that all of the HOBs, including the PHIT HOB,
begin on an 8-byte boundary. See the PHIT HOB definition in the
<em>Platform Initialization Specification,</em> Volume 3, for more
information.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The HOB was successfully created.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_OUT_OF_RESOURCES</td>
<td>There is no additional space for HOB creation.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="firmware-volume-services">
<h2>4.5 Firmware Volume Services<a class="headerlink" href="#firmware-volume-services" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The following services abstract traversing the Firmware File System
(FFS):</div></blockquote>
<ul>
<li><p class="first">FfsFindNextVolume()</p>
</li>
<li><p class="first">FfsFindNextFile()</p>
</li>
<li><p class="first">FfsFindSectionData()</p>
</li>
<li><p class="first">FfsFindFileByName()</p>
</li>
<li><p class="first">FfsGetFileInfo()</p>
</li>
<li><p class="first">FfsGetVolumeInfo()</p>
<blockquote>
<div><p>The description of the FFS can be found in the <em>Platform
Initialization Specification</em>, Volume 3<a href="#id69"><span class="problematic" id="id70">*</span></a>. *</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="ffsfindnextvolume">
<h3>FfsFindNextVolume()<a class="headerlink" href="#ffsfindnextvolume" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The purpose of the service is to abstract the capability of the PEI
Foundation to discover instances of firmware volumes in the system.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FFS_FIND_NEXT_VOLUME2) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN UINTN</strong> <em>Instance,</em></p>
<p><strong>OUT EFI_PEI_FV_HANDLE *</strong><em>VolumeHandle</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>Instance</em></p>
<p>This instance of the firmware volume to find. The value 0 is the
Boot Firmware Volume (BFV). <em>VolumeHandle</em></p>
<p>On exit, points to the next volume handle or <strong>NULL</strong> if it does not
exist.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to discover additional firmware volumes.
The core uses</p>
<p><strong>EFI_PEI_FIRMWARE_VOLUME_INFO_PPI</strong> to discover these volumes.
The service returns a volume handle of type
<strong>EFI_PEI_FV_HANDLE</strong>, which must be unique within the system.</p>
<p><strong>Related Definitions typedef VOID *EFI_PEI_FV_HANDLE;</strong></p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The volume was found.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The volume was not found.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><em>VolumeHandle</em> is <strong>NULL</strong></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ffsfindnextfile">
<h3>FfsFindNextFile()<a class="headerlink" href="#ffsfindnextfile" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Searches for the next matching file in the firmware volume.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FFS_FIND_NEXT_FILE2) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_FV_FILETYPE</strong> <em>SearchType,</em></p>
<p><strong>IN CONST EFI_PEI_FV_HANDLE</strong> <em>FvHandle,</em></p>
<p><strong>IN OUT EFI_PEI_FILE_HANDLE</strong> <em>*FileHandle</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>SearchType</em></p>
<p>A filter to find files only of this type. Type <strong>EFI_FV_FILETYPE</strong>
is defined in the <em>Platform Initialization Specification,</em> Volume
3<em>.</em> Type <strong>EFI_FV_FILETYPE_ALL</strong> causes no filtering to be
done.</p>
<p><em>FvHandle</em></p>
<p>Handle of firmware volume in which to search. The type
<strong>EFI_PEI_FV_HANDLE</strong> is defined in the PEI Services
<strong>FfsFindNextVolume()</strong>. <em>FileHandle</em></p>
<p>On entry, points to the current handle from which to begin searching
or NULL to start at the beginning of the firmware volume. On exit,
points the file handle of the next file</p>
<p>in the volume or NULL if there are no more files. The type</p>
<p><strong>EFI_PEI_FILE_HANDLE</strong> is defined in “Related Defintions” below.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to discover firmware files within a
specified volume. To find the first instance of a firmware file,
pass a <em>FileHandle</em> value of <strong>NULL</strong> into the service.</p>
<p>The service returns a file handle of type
<strong>EFI_PEI_FILE_HANDLE</strong>, which must be unique within the system.</p>
<p>The behavior of files with file types
<strong>EFI_FV_FILETYPE_FFS_MIN</strong> and</p>
<p><strong>EFI_FV_FILETYPE_FFS_MAX</strong> depends on the firmware file system.
For more information on the specific behavior for the standard PI
firmware file system, see section 1.1.4.1.6 of the PI Specification,
Volume 3.</p>
<p><strong>Related Definitions typedef VOID *EFI_PEI_FILE_HANDLE;</strong></p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The file was found.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The file was not found.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>The header checksum was not zero.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ffsfindsectiondata">
<h3>FfsFindSectionData()<a class="headerlink" href="#ffsfindsectiondata" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Searches for the next matching section within the specified file.
Prototype</p>
<p><strong>typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FFS_FIND_SECTION_DATA2) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_SECTION_TYPE</strong> <em>SectionType,</em></p>
<p><strong>IN EFI_PEI_FILE_HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT VOID</strong> <em>**SectionData</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>SectionType</em></p>
<p>The value of the section type to find. Type <strong>EFI_SECTION_TYPE</strong>
is defined in the <em>Platform Initialization Specification,</em> Volume
3<em>.</em></p>
<p><em>FileHandle</em></p>
<p>Handle of the firmware file to search. Type
<strong>EFI_PEI_FILE_HANDLE</strong> is defined in <strong>FfsFindNextFile()</strong>,
“Related Definitions.” A pointer to the file header that contains
the set of sections to be searched.</p>
<p><em>SectionData</em></p>
<p>A pointer to the discovered section, if successful.</p>
<p><strong>Description</strong></p>
<p>This service enables PEI modules to discover the first section of a
given type within a valid file. This service will search within
encapsulation sections (compression and GUIDed) as well. It will
search inside of a GUIDed section or a compressed section, but may
not, for example, search a GUIDed section inside a GUIDes section.</p>
<p>This service will not search within compression sections or GUIDed
sections which require extraction if memory is not present.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The section was found.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The section was not found.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ffsfindsectiondata3">
<h3>FfsFindSectionData3()<a class="headerlink" href="#ffsfindsectiondata3" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Searches for the next matching section within the specified file.</p>
</div></blockquote>
<p><strong>Services - PEI Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FFS_FIND_SECTION_DATA3) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_SECTION_TYPE</strong> <em>SectionType,</em></p>
<p><strong>In UINTN</strong> <em>SectionInstance</em></p>
<p><strong>IN EFI_PEI_FILE_HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT VOID</strong> <em>**SectionData</em></p>
<p><strong>OUT UINT32</strong> <em>*AuthenticationStatus</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>SectionType</em></p>
<p>The value of the section type to find. Type <strong>EFI_SECTION_TYPE</strong>
is defined in the <em>Platform Initialization Specification,</em> Volume
3<em>.</em></p>
<p><em>SectionInstance</em></p>
<p>Section instance to find.</p>
<p><em>FileHandle</em></p>
<p>Handle of the firmware file to search. Type
<strong>EFI_PEI_FILE_HANDLE</strong> is defined in <strong>FfsFindNextFile()</strong>,
“Related Definitions.” A pointer to the file header that contains
the set of sections to be searched.</p>
<p><em>SectionData</em></p>
<p>A pointer to the discovered section, if successful.</p>
<p><em>AuthenticationStatus</em></p>
<p>A pointer to the authentication status for this section.</p>
<p><strong>Description</strong></p>
<p>This service enables PEI modules to discover the section of a given
type within a valid file. This service will search within
encapsulation sections (compression and GUIDed) as well. It will
search inside of a GUIDed section or a compressed section, but may
not, for example, search a GUIDed section inside a GUIDes section.</p>
<p>This service will not search within compression sections or GUIDed
sections which require extraction if memory is not present.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The section was found.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The section was not found.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ffsfindfilebyname">
<h3>FfsFindFileByName()<a class="headerlink" href="#ffsfindfilebyname" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Find a file within a volume by its name.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FFS_FIND_BY_NAME) (</strong></p>
<p><strong>IN CONST EFI_GUID</strong> <em>*FileName,</em></p>
<p><strong>IN EFI_PEI_FV_HANDLE</strong> <em>VolumeHandle,</em></p>
<p><strong>OUT EFI_PEI_FILE_HANDLE</strong> <em>*FileHandle</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>FileName</em></p>
<p>A pointer to the name of the file to find within the firmware
volume.</p>
<p><em>VolumeHandle</em></p>
<p>The firmware volume to search</p>
<p><em>FileHandle</em></p>
<p>Upon exit, points to the found file’s handle or <strong>NULL</strong> if it could
not be found.</p>
<p><strong>Description</strong></p>
<p>This service searches for files with a specific name, within either
the specified firmware volume or all firmware volumes.</p>
<p>The service returns a file handle of type
<strong>EFI_PEI_FILE_HANDLE</strong>, which must be unique within the system.</p>
<p>The behavior of files with file types
<strong>EFI_FV_FILETYPE_FFS_MIN</strong> and</p>
<p><strong>EFI_FV_FILETYPE_FFS_MAX</strong> depends on the firmware file system.
For more information on the specific behavior for the standard PI
firmware file system, see section 1.1.4.1.6 of the PI Specification,
Volume 3.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">File was found.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>File was not found.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><em>VolumeHandle</em> or <em>FileHandle</em> or <em>FileName</em> was <strong>NULL</strong>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ffsgetfileinfo">
<h3>FfsGetFileInfo()<a class="headerlink" href="#ffsgetfileinfo" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Returns information about a specific file.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FFS_GET_FILE_INFO) ( IN
EFI_PEI_FILE_HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>OUT EFI_FV_FILE_INFO</strong> <em>*FileInfo</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>FileHandle</em></p>
<p>Handle of the file.</p>
<p><em>FileInfo</em></p>
<p>Upon exit, points to the file’s information.</p>
<p><strong>Description</strong></p>
<p>This function returns information about a specific file, including
its file name, type, attributes, starting address and size. If the
firmware volume is not memory mapped then the <em>Buffer</em> member will
be NULL.</p>
<p><strong>Related Definitions typedef struct {</strong></p>
<p><strong>EFI_GUID</strong> <em>FileName;</em></p>
<p><strong>EFI_FV_FILETYPE</strong> <em>FileType;</em></p>
<p><strong>EFI_FV_FILE_ATTRIBUTES</strong> <em>FileAttributes;</em></p>
<p><strong>VOID</strong> <em>*Buffer;</em></p>
<p><strong>UINT32</strong> <em>BufferSize;</em></p>
<p><strong>} EFI_FV_FILE_INFO;</strong></p>
<p><em>FileName</em></p>
<p>Name of the file.</p>
<p><em>FileType</em></p>
<p>File type. See <strong>EFI_FV_FILETYPE</strong>, which is defined in the
<em>Platform Initialization Firmware Storage Specification</em>.</p>
<p><em>FileAttributes</em></p>
<p>Attributes of the file. Type <strong>EFI_FV_FILE_ATTRIBUTES</strong> is
defined in the <em>Platform Initialization Firmware Storage
Specification</em>.</p>
<p><em>Buffer</em></p>
<p>Points to the file’s data (not the header). Not valid if</p>
<p><strong>EFI_FV_FILE_ATTRIB_MEMORY_MAPPED</strong> is zero.</p>
<p><em>BufferSize</em></p>
<p>Size of the file’s data.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">File information returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>If <em>FileHandle</em> does not represent a valid file.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td>If <em>FileInfo</em> is NULL</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ffsgetfileinfo2">
<h3>FfsGetFileInfo2()<a class="headerlink" href="#ffsgetfileinfo2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Returns information about a specific file.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FFS_GET_FILE_INFO2) (</strong></p>
<p><strong>IN EFI_PEI_FILE_HANDLE</strong> <em>FileHandle</em><strong>,</strong></p>
<p><strong>OUT EFI_FV_FILE_INFO2 *</strong><em>FileInfo</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>FileHandle</em></p>
<p>Handle of the file.</p>
<p><em>FileInfo</em></p>
<p>Upon exit, points to the file’s information.</p>
<p><strong>Description</strong></p>
<p>This function returns information about a specific file, including
its file name, type, attributes, starting address, size and
authentication status. If the firmware volume is not memory mapped
then the <em>Buffer</em> member will be NULL.</p>
<p><strong>Related Definitions typedef struct { EFI_GUID FileName;</strong></p>
<p><strong>EFI_FV_FILETYPE</strong> <em>FileType</em><strong>;</strong></p>
<p><strong>EFI_FV_FILE_ATTRIBUTES</strong> <em>FileAttributes</em><strong>;</strong></p>
<p><strong>VOID *</strong><em>Buffer</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>BufferSize</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>AuthenticationStatus</em><strong>;</strong></p>
<p><strong>} EFI_FV_FILE_INFO2;</strong> <em>FileName</em></p>
<p>Name of the file.</p>
<p><em>FileType</em></p>
<p>File type. See <strong>EFI_FV_FILETYPE</strong>, which is defined in the
<em>Platform Initialization Firmware Storage Specification</em>.</p>
<p><em>FileAttributes</em></p>
<p>Attributes of the file. Type <strong>EFI_FV_FILE_ATTRIBUTES</strong> is
defined in the P<em>latform Initialization Firmware Storage
Specification</em>.</p>
<p><em>Buffer</em></p>
<p>Points to the file’s data (not the header). Not valid if</p>
<p><strong>EFI_FV_FILE_ATTRIB_MEMORY_MAPPED</strong> is zero.</p>
<p><em>BufferSize</em></p>
<p>Size of the file’s data.</p>
<p><em>AuthenticationStatus</em></p>
<p>Authentication status for this file.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">File information returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>If <em>FileHandle</em> does not represent a valid file.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td>If <em>FileInfo</em> is NULL</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ffsgetvolumeinfo">
<h3>FfsGetVolumeInfo()<a class="headerlink" href="#ffsgetvolumeinfo" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Returns information about the specified volume.</p>
</div></blockquote>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<blockquote>
<div><p><strong>(EFIAPI *EFI_PEI_FFS_GET_VOLUME_INFO) (</strong></p>
<p><strong>IN EFI_PEI_FV_HANDLE</strong> <em>VolumeHandle,</em></p>
<p><strong>OUT EFI_FV_INFO</strong> <em>*VolumeInfo</em></p>
<p><strong>);</strong></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><em>VolumeHandle</em></p>
<p>Handle of the volume.</p>
<p><em>VolumeInfo</em></p>
<p>Upon exit, points to the volume’s information.</p>
</div></blockquote>
<p><strong>Related Definitions typedef struct {</strong></p>
<blockquote>
<div><p><strong>EFI_FVB_ATTRIBUTES_2</strong> <em>FvAttributes;</em></p>
<p><strong>EFI_GUID</strong> <em>FvFormat;</em></p>
<p><strong>EFI_GUID</strong> <em>FvName;</em></p>
<p><strong>VOID*</strong> <em>FvStart;</em></p>
<p><strong>UINT64</strong> <em>FvSize;</em></p>
<p><strong>} EFI_FV_INFO;</strong></p>
<p><em>FvAttributes</em></p>
<p>Attributes of the firmware volume. Type <strong>EFI_FVB_ATTRIBUTES_2</strong>
is defined in the <em>Platform Initialization Firmware Storage
Specficiation</em>.</p>
<p><em>FvFormat</em></p>
<p>Format of the firmware volume. For PI Architecture Firmware Volumes,
this can be copied from <em>FileSystemGuid</em> in
<strong>EFI_FIRMWARE_VOLUME_HEADER</strong>. <em>FvName</em></p>
<p>Name of the firmware volume. For PI Architecture Firmware Volumes,
this can be copied from <em>VolumeName</em> in the extended header of</p>
<p><strong>EFI_FIRMWARE_VOLUME_HEADER</strong>.</p>
<p><em>FvStart</em></p>
<p>Points to the first byte of the firmware volume, if bit
<strong>EFI_FVB_MEMORY_MAPPED</strong> is set in <em>FvAttributes</em>. <em>FvSize</em></p>
<p>Size of the firmware volume.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function returns information about a specific firmware volume,
including its name, type, attributes, starting address and size.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">Volume information returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>If <em>VolumeHandle</em> does not represent a valid volume.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td>If <em>VolumeInfo</em> is <strong>NULL</strong>.</td>
</tr>
<tr class="row-even"><td>EFI_SUCCESS</td>
<td>Information successfully returned</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td>The volume designated by the VolumeHandle is not available</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="registerforshadow">
<h3>RegisterForShadow()<a class="headerlink" href="#registerforshadow" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Register a PEIM so that it will be shadowed and called again.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_REGISTER_FOR_SHADOW) (</strong></p>
<p><strong>IN EFI_PEI_FILE_HANDLE</strong> <em>FileHandle</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>FileHandle</em></p>
<p>PEIM’s file handle. Must be the currently executing PEIM.</p>
<p><strong>Description</strong></p>
<p>This service registers a file handle so that after memory is
available, the PEIM will be re-loaded into permanent memory and
re-initialized. The PEIM registered this way will always be
initialized twice. The first time, this function call will return
<strong>EFI_SUCCESS</strong>. The second time, this function call will return
<strong>EFI_ALREADY_STARTED</strong>.</p>
<p>Depending on the order in which PEIMs are dispatched, the PEIM
making this call may be initialized after permanent memory is
installed, even the first time.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The PEIM was successfully registered for shadowing.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_ALREADY_STARTED</td>
<td>The PEIM was previously registered for shadowing.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>The <em>FileHandle</em> does not refer to a valid file handle.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="pei-memory-services">
<h2>4.6 PEI Memory Services<a class="headerlink" href="#pei-memory-services" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The following services are a collection of memory management
services for use both before and after permanent memory has been
discovered:</div></blockquote>
<ul class="simple">
<li>InstallPeiMemory()</li>
<li>AllocatePages()</li>
<li>AllocatePool()</li>
<li>CopyMem()</li>
<li>SetMem()</li>
<li>FreePages()</li>
</ul>
<div class="section" id="installpeimemory">
<h3>InstallPeiMemory()<a class="headerlink" href="#installpeimemory" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This function registers the found memory configuration with the PEI
Foundation.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_INSTALL_PEI_MEMORY) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_PHYSICAL_ADDRESS</strong> <em>MemoryBegin,</em></p>
<p><strong>IN UINT64</strong> <em>MemoryLength</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>MemoryBegin</em></p>
<p>The value of a region of installed memory.</p>
<p><em>MemoryLength</em></p>
<p>The corresponding length of a region of installed memory.</p>
<p><strong>Description</strong></p>
<p>This service enables PEIMs to register the permanent memory
configuration that has been initialized with the PEI Foundation. The
result of this call-set is the creation of the appropriate Hand-Off
Block (HOB) describing the physical memory.</p>
<p>The usage model is that the PEIM that discovers the permanent memory
shall invoke this service. The memory reported is a single
contiguous run. It should be enough to allocate a PEI stack and some
HOB list. The full memory map will be reported using the appropriate
memory HOBs. The</p>
<p>PEI Foundation will follow up with an installation of</p>
<p><strong>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI</strong>.</p>
<p>Any invocations of this service after the first invocation which
returns EFI_SUCCESS will be ignored.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The region was successfully installed in a HOB or this service was successfully invoked earlier and no HOB modification will occur.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><p class="first"><em>MemoryBegin</em> and <em>MemoryLength</em> are illegal for this</p>
<p class="last">system.</p>
</td>
</tr>
<tr class="row-odd"><td>EFI_OUT_OF_RESOURCES</td>
<td>There is no additional space for HOB creation.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="allocatepages">
<h3>AllocatePages()<a class="headerlink" href="#allocatepages" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The purpose of the service is to publish an interface that allows
PEIMs to allocate memory ranges that are managed by the PEI
Foundation.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_ALLOCATE_PAGES) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_MEMORY_TYPE</strong> <em>MemoryType,</em></p>
<p><strong>IN UINTN</strong> <em>Pages,</em></p>
<p><strong>OUT EFI_PHYSICAL_ADDRESS</strong> <em>*Memory,</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>MemoryType</em></p>
<p>The type of memory to allocate. The only types allowed are
<strong>EfiLoaderCode</strong>, <strong>EfiLoaderData</strong>, <strong>EfiRuntimeServicesCode</strong>,</p>
<p><strong>EfiRuntimeServicesData</strong>, <strong>EfiBootServicesCode</strong>,
<strong>EfiBootServicesData</strong>, <strong>EfiACPIReclaimMemory,
EfiReservedMemoryType</strong>, and <strong>EfiACPIMemoryNVS</strong>.</p>
<p><em>Pages</em></p>
<p>The number of contiguous 4 KiB pages to allocate. Type</p>
<p><strong>EFI_PHYSICAL_ADDRESS</strong> is defined in <strong>AllocatePages()</strong> in the
UEFI 2.0 specification<em>.</em></p>
<p><em>Memory</em></p>
<p>Pointer to a physical address. On output, the address is set to the
base of the page range that was allocated.</p>
<p><strong>Description</strong></p>
<p>This service allocates the requested number of pages and returns a
pointer to the base address of the page range in the location
referenced by Memory. The service scans the available memory to
locate free pages. When it finds a physically contiguous block of
pages that is large enough it creates a memory allocation HOB
describing the region with the requested MemoryType.</p>
<p>Allocation made prior to permanent memory will be migrated to
permanent memory and the HOB updated.</p>
<p>The expectation is that the implementation of this service will
automate the creation of the Memory Allocation HOB types. As such,
this is in the same spirit as the PEI Services to create the FV HOB,
for example.</p>
<p>Prior to InstallPeiMemory() being called, PEI will allocate pages
from the heap. After</p>
<p>InstallPeiMemory() is called, PEI will allocate pages within the
region of memory provided by InstallPeiMemory() service in a
best-effort fashion. Location-specific allocations are not managed
by the PEI foundation code.</p>
<p>The service also supports the creation of Memory Allocation HOBs
that describe the stack, bootstrap processor (BSP) BSPStore
(“Backing Store Pointer Store”), and the DXE Foundation allocation.
This additional information is conveyed through the final two
arguments in this API and the description of the appropriate HOB
types can be found in the <em>Platform Initialization Specification</em>,
Volume 3<em>.</em></p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The memory range was successfully allocated.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_OUT_OF_RESOURCES</td>
<td>The pages could not be allocated.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><p class="first">Type is not equal to <strong>EfiLoaderCode</strong>,</p>
<p><strong>EfiLoaderData</strong>, <strong>EfiRuntimeServicesCode</strong>,</p>
<p><strong>EfiRuntimeServicesData</strong>,</p>
<p><strong>EfiBootServicesCode</strong>,</p>
<p class="last"><strong>EfiBootServicesData</strong>, <strong>EfiACPIReclaimMemory</strong>, <strong>EfiReservedMemoryType,</strong> or <strong>EfiACPIMemoryNVS</strong>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="allocatepool">
<h3>AllocatePool()<a class="headerlink" href="#allocatepool" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The purpose of this service is to publish an interface that allows
PEIMs to allocate memory ranges that are managed by the PEI
Foundation.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><a href="#id71"><span class="problematic" id="id72">**</span></a>(EFIAPI *EFI_PEI_ALLOCATE_POOL) ( **</p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN UINTN</strong> <em>Size,</em></p>
<p><strong>OUT VOID</strong> <em>**Buffer</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>Size</em></p>
<p>The number of bytes to allocate from the pool.</p>
<p><em>Buffer</em></p>
</div></blockquote>
<p>If the call succeeds, a pointer to a pointer to the allocated buffer;
undefined otherwise.</p>
<blockquote>
<div><p><strong>Description</strong></p>
<p>This service allocates memory from the Hand-Off Block (HOB) heap.
Because HOBs can be allocated from either temporary or permanent
memory, this service is available throughout the entire PEI phase.</p>
<p>This service allocates memory in multiples of eight bytes to
maintain the required HOB alignment. The early allocations from
temporary memory will be migrated to permanent memory when permanent
main memory is installed; this migration shall occur when the HOB
list is migrated to permanent memory.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The allocation was successful.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_OUT_OF_RESOURCES</td>
<td>There is not enough heap to allocate the requested size.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="copymem">
<h3>CopyMem()<a class="headerlink" href="#copymem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service copies the contents of one buffer to another buffer.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><a href="#id73"><span class="problematic" id="id74">**</span></a>(EFIAPI *EFI_PEI_COPY_MEM) ( **</p>
<p><strong>IN VOID</strong> <em>*Destination,</em></p>
<p><strong>IN VOID</strong> <em>*Source,</em></p>
<p><strong>IN UINTN</strong> <em>Length</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Destination</em></p>
<p>Pointer to the destination buffer of the memory copy.</p>
<p><em>Source</em></p>
<p>Pointer to the source buffer of the memory copy.</p>
<p><em>Length</em></p>
<p>Number of bytes to copy from <em>Source</em> to <em>Destination</em>.</p>
<p><strong>Description</strong></p>
</div></blockquote>
<p>This function copies <em>Length</em> bytes from the buffer <em>Source</em> to the
buffer <em>Destination</em>.</p>
<blockquote>
<div><p><strong>Status Codes Returned</strong></p>
<p>None.</p>
</div></blockquote>
</div>
<div class="section" id="freepages">
<h3>FreePages()<a class="headerlink" href="#freepages" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Frees memory pages.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_FREE_PAGES) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **PeiServices,</strong></p>
<p><strong>IN EFI_PHYSICAL_ADDRESS Memory</strong></p>
<p><strong>IN UINTN Pages</strong></p>
<p><a href="#id75"><span class="problematic" id="id76">**</span></a>); **</p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the EFI_PEI_SERVICES table published by the
PEI Foundation.</p>
<p><em>Memory</em></p>
<p>The base physical address of the pages to be freed. Type
EFI_PHYSICAL_ADDRESS is defined in the
EFI_BOOT_SERVICES.AllocatePages()function description.</p>
<p><em>Pages</em></p>
<p>The number of contiguous 4KiB pages to free.</p>
<p><strong>Description</strong></p>
<p>The FreePages() function returns memory allocated by AllocatePages()
to the firmware.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The requested memory pages were freed.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The requested memory pages were not allocated with AllocatePages().</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td>Memory is not a page-aligned address or Pages is invalid.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="setmem">
<h3>SetMem()<a class="headerlink" href="#setmem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The service fills a buffer with a specified value.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><a href="#id77"><span class="problematic" id="id78">**</span></a>(EFIAPI *EFI_PEI_SET_MEM) ( **</p>
<p><strong>IN VOID</strong> <em>*Buffer,</em></p>
<p><strong>IN UINTN</strong> <em>Size,</em></p>
<p><strong>IN UINT8</strong> <em>Value</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Buffer</em></p>
<p>Pointer to the buffer to fill.</p>
<p><em>Size</em></p>
<p>Number of bytes in <em>Buffer</em> to fill.</p>
<p><em>Value</em></p>
<p>Value to fill <em>Buffer</em> with.</p>
<p><strong>Description</strong></p>
<p>This function fills <em>Size</em> bytes of <em>Buffer</em> with <em>Value</em>.</p>
<p><strong>Status Codes Returned</strong></p>
<p>None.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="status-code-service">
<h2>4.7 Status Code Service<a class="headerlink" href="#status-code-service" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The PEI Foundation publishes the following status code service:</div></blockquote>
<ul>
<li><p class="first">ReportStatusCode()</p>
<blockquote>
<div><p>This service will report <strong>EFI_NOT_AVAILABLE_YET</strong> until a PEIM
publishes the services for other modules. For the GUID of the PPI,
see <strong>EFI_PEI_PROGRESS_CODE_PPI</strong>.</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="reportstatuscode">
<h3>ReportStatusCode()<a class="headerlink" href="#reportstatuscode" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service publishes an interface that allows PEIMs to report
status codes.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_REPORT_STATUS_CODE) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_STATUS_CODE_TYPE</strong> <em>Type,</em></p>
<p><strong>IN EFI_STATUS_CODE_VALUE</strong> <a href="#id79"><span class="problematic" id="id80">*</span></a>Value, *</p>
<p><strong>IN UINT32</strong> <em>Instance,</em></p>
<p><strong>IN CONST EFI_GUID</strong> <em>*CallerId</em> <a href="#id81"><span class="problematic" id="id82">**</span></a>OPTIONAL, **</p>
<p><strong>IN CONST EFI_STATUS_CODE_DATA</strong> <em>*Data</em> <strong>OPTIONAL );</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><em>Type</em></p>
<p>Indicates the type of status code being reported. The type</p>
<p><strong>EFI_STATUS_CODE_TYPE</strong> is defined in “Related Definitions”
below.</p>
<p><em>Value</em></p>
<p>Describes the current status of a hardware or software entity. This
includes information about the class and subclass that is used to
classify the entity as well as an operation. For progress codes, the
operation is the current activity. For error codes, it</p>
<p>is the exception. For debug codes, it is not defined at this time.
Type</p>
<p><strong>EFI_STATUS_CODE_VALUE</strong> is defined in “Related Definitions”
below.</p>
</div></blockquote>
<p><strong>Services - PEI Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><em>Instance</em></p>
<p>The enumeration of a hardware or software entity within the system.
A system may</p>
<p>contain multiple entities that match a class/subclass pairing. The
instance differentiates between them. An instance of 0 indicates
that instance information is unavailable, not meaningful, or not
relevant. Valid instance numbers start with 1.</p>
<p><em>CallerId</em></p>
<p>This optional parameter may be used to identify the caller. This
parameter allows the status code driver to apply different rules to
different callers.</p>
<p><em>Data</em></p>
<p>This optional parameter may be used to pass additional data. Type</p>
<p><strong>EFI_STATUS_CODE_DATA</strong> is defined in “Related Definitions“
below. The contents of this data type may have additional
GUID-specific data.</p>
<p><strong>Description</strong></p>
<p><strong>ReportStatusCode()</strong> is called by PEIMs that wish to report status
information on their progress. The principal use model is for a PEIM
to emit one of the standard 32-bit error codes<em>.</em> This will allow
a platform owner to ascertain the state of the system, especially
under conditions where the full consoles might not have been
installed.</p>
<p>This is the entry point that PEIMs shall use. This service can use
all platform PEI Services, and when main memory is available, it can
even construct a GUIDed HOB that conveys the pre-DXE data. This
service can also publish an interface that is usable only from the
DXE phase. This entry point should not be the same as that published
to the PEIMs, and the implementation of this code path should
<strong>not</strong> do the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Use any PEI Services or PPIs from other modules.</p>
</li>
<li><p class="first">Make any presumptions about global memory allocation.</p>
<blockquote>
<div><p>It can only operate on its local stack activation frame and must be
careful about using I/O and memory-mapped I/O resources. These
concerns, including the latter warning, arise because this service
could be used during the “blackout” period between the termination
of PEI and the beginning of DXE, prior to the loading of the DXE
progress code driver. As such, the ownership of the memory map and
platform resource allocation is indeterminate at this point in the
platform evolution.</p>
<p><strong>Related Definitions</strong></p>
<p><strong>//</strong></p>
<p><strong>// Status Code Type Definition</strong></p>
<p><strong>// typedef UINT32 EFI_STATUS_CODE_TYPE;</strong></p>
<p><strong>//</strong></p>
<p><a href="#id83"><span class="problematic" id="id84">**</span></a>// A Status Code Type is made up of the code type and severity //
All values masked by EFI_STATUS_CODE_RESERVED_MASK are **</p>
<p><strong>// reserved for use by this specification.</strong></p>
<p><strong>//</strong></p>
<p><strong>#define EFI_STATUS_CODE_TYPE_MASK 0x000000FF</strong></p>
</div></blockquote>
</li>
</ul>
<p>July 2018 Version 1.7</p>
<p><strong>#define EFI_STATUS_CODE_SEVERITY_MASK 0xFF000000</strong></p>
<p><strong>#define EFI_STATUS_CODE_RESERVED_MASK 0x00FFFF00</strong></p>
<p><strong>//</strong></p>
<p><a href="#id85"><span class="problematic" id="id86">**</span></a>// Definition of code types, all other values masked by //
EFI_STATUS_CODE_TYPE_MASK are reserved for use by **</p>
<p><strong>// this specification.</strong></p>
<p><strong>//</strong></p>
<p><strong>#define EFI_PROGRESS_CODE 0x00000001</strong></p>
<p><strong>#define EFI_ERROR_CODE 0x00000002</strong></p>
<p><strong>#define EFI_DEBUG_CODE 0x00000003</strong></p>
<p><strong>//</strong></p>
<p><a href="#id87"><span class="problematic" id="id88">**</span></a>// Definitions of severities, all other values masked by **</p>
<p><a href="#id89"><span class="problematic" id="id90">**</span></a>// EFI_STATUS_CODE_SEVERITY_MASK are reserved for use by **</p>
<p><strong>// this specification.</strong></p>
<p><a href="#id91"><span class="problematic" id="id92">**</span></a>// Uncontained errors are major errors that could not contained **</p>
<p><strong>// to the specific component that is reporting the error // For
example, if a memory error was not detected early enough, // the bad
data could be consumed by other drivers.</strong></p>
<p><a href="#id93"><span class="problematic" id="id94">**</span></a>// **</p>
<p><strong>#define EFI_ERROR_MINOR 0x40000000</strong></p>
<p><strong>#define EFI_ERROR_MAJOR 0x80000000</strong></p>
<p><strong>#define EFI_ERROR_UNRECOVERED 0x90000000</strong></p>
<p><strong>#define EFI_ERROR_UNCONTAINED 0xa0000000</strong></p>
<p><strong>//</strong></p>
<p><strong>// Status Code Value Definition</strong></p>
<p><strong>// typedef UINT32 EFI_STATUS_CODE_VALUE;</strong></p>
<p><strong>//</strong></p>
<p><a href="#id95"><span class="problematic" id="id96">**</span></a>// A Status Code Value is made up of the class, subclass, and **</p>
<p><strong>// an operation.</strong></p>
<p><strong>//</strong></p>
<p><strong>#define EFI_STATUS_CODE_CLASS_MASK 0xFF000000</strong></p>
<p><strong>#define EFI_STATUS_CODE_SUBCLASS_MASK 0x00FF0000</strong></p>
<p><strong>#define EFI_STATUS_CODE_OPERATION_MASK 0x0000FFFF</strong></p>
<p><strong>//</strong></p>
<p><strong>// Definition of Status Code extended data header.</strong></p>
<p><strong>// The data will follow</strong> <em>HeaderSize</em> <a href="#id97"><span class="problematic" id="id98">**</span></a>bytes from the beginning of
**</p>
<p><strong>// the structure and is</strong> <em>Size</em> <strong>bytes long.</strong></p>
<p><strong>//</strong></p>
<p><strong>typedef struct { UINT16</strong> <em>HeaderSize;</em></p>
<p><strong>UINT16</strong> <em>Size;</em></p>
<p><strong>Services - PEI Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>EFI_GUID</strong> <em>Type;</em></p>
<p><strong>} EFI_STATUS_CODE_DATA;</strong></p>
<p><em>HeaderSize</em></p>
<p>The size of the structure. This is specified to enable future
expansion.</p>
<p><em>Size</em></p>
</div></blockquote>
<p>The size of the data in bytes. This does not include the size of the
header structure.</p>
<blockquote>
<div><p><em>Type</em></p>
<p>The GUID defining the type of the data.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The function completed successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_AVAILABLE_YET</td>
<td>No progress code provider has installed an interface in the system.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="reset-services">
<h2>4.8 Reset Services<a class="headerlink" href="#reset-services" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The PEI Foundation publishes the following reset service:</div></blockquote>
<ul class="simple">
<li>ResetSystem()</li>
</ul>
<p><strong>ResetSystem()</strong></p>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Resets the entire platform.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_RESET_SYSTEM) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the <strong>EFI_PEI_SERVICES</strong> table published by
the PEI Foundation.</p>
<p><strong>Description</strong></p>
<p>This service resets the entire platform, including all processors
and devices, and reboots the system. It is important to have a
standard variant of this function for cases such as the following:</p>
</div></blockquote>
<ul class="simple">
<li>Resetting the processor to change frequency settings</li>
<li>Restarting hardware to complete chipset initialization</li>
</ul>
<p>July 2018 Version 1.7</p>
<ul>
<li><p class="first">Responding to exceptions from a catastrophic errorReturned Status
Codes</p>
<blockquote>
<div><p><strong>Status Codes Returned</strong></p>
</div></blockquote>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EFI_NOT_AVAILABLE_YET</td>
<td>The service has not been installed yet.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="i-o-and-pci-services">
<h2>4.9 I/O and PCI Services<a class="headerlink" href="#i-o-and-pci-services" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The PEI Foundation publishes CPU I/O and PCI Configuration services.</li>
</ul>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
<div class="section" id="id99">
<h1>5 PEI Foundation<a class="headerlink" href="#id99" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id100">
<h2>5.1 Introduction<a class="headerlink" href="#id100" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The PEI Foundation centers around the PEI Dispatcher. The
dispatcher’s job is to hand control to the PEIMs in an orderly
manner. The PEI Foundation also assists in PEIM-to-PEIM
communication. The central resource for the module-to-module
communication involves the PPI. The marshalling of references to
PPIs can occur using the installable or notification interface. The
PEI Foundation is constructed as an autonomous binary image that is
of file type <strong>EFI_FV_FILETYPE_PEI_CORE</strong> and is composed of the
following:</div></blockquote>
<ul>
<li><p class="first">An authentication section</p>
</li>
<li><p class="first">A code image that is possibly PE32+</p>
<blockquote>
<div><p>See the <em>Platform Initialization Specification,</em> Volume 3<em>,</em> for
information on section and file types. If the code that comprises
the PEI Foundation is not a PE32+ image, then it is a raw binary
whose lowest address is the entry point to the PEI Foundation. The
PEI Foundation is discovered and authenticated by the Security (SEC)
phase.</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="prerequisites">
<h3>5.1.1 Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The PEI phase is handed control from the Security (SEC) phase of the
PI Architecture-compliant boot process. The PEI phase must satisfy
the following minimum prerequisites before it can begin execution:</div></blockquote>
<ul>
<li><p class="first">Processor execution mode</p>
</li>
<li><p class="first">Access to the firmware volume that contains the PEI Foundation</p>
<blockquote>
<div><p>It is expected that the SEC infrastructure code and PEI Foundation
are not linked together as a single ROMable executable image. The
entry point from SEC into PEI is not architecturally fixed but is
instead dependent on the PEI Foundation location within FV0, or the
Boot Firmware Volume.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="processor-execution-mode">
<h3>5.1.2 Processor Execution Mode<a class="headerlink" href="#processor-execution-mode" title="Permalink to this headline">¶</a></h3>
<div class="section" id="processor-execution-mode-in-ia-32-intel-architecture">
<h4>5.1.2.1 Processor Execution Mode in IA-32 Intel<sup>®</sup> Architecture<a class="headerlink" href="#processor-execution-mode-in-ia-32-intel-architecture" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>In IA-32 Intel architecture, the Security (SEC) phase of the PI
Architecture is responsible for placing the processor in a native
linear address mode by which the full address range of the processor
is accessible for code, data, and stack. For example, “flat 32” is
the IA-32 processor generation mode in which the PEI phase will
execute. The processor must be in its most privileged “ring 0” mode,
or equivalent, and be able to access all memory and I/O space.</p>
<p>This prerequisite is strictly dependent on the processor generation
architecture.</p>
</div></blockquote>
</div>
<div class="section" id="processor-execution-mode-in-itanium-processor-family">
<h4>5.1.2.2 Processor Execution Mode in Itanium<sup>®</sup> Processor Family<a class="headerlink" href="#processor-execution-mode-in-itanium-processor-family" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The PEI Foundation will begin executing after the Security (SEC)
phase has completed. The SEC phase subsumed the System Abstraction
Layer entry point (SALE_ENTRY) in Itanium<sup>®</sup></div></blockquote>
<p>Version 1.7 52</p>
<blockquote>
<div>architecture. In addition, the SEC phase makes the appropriate
Processor Abstraction Layer (PAL) calls or platform services to
enable the temporary memory store. The SEC passes its handoff state
to the PEI Foundation in physical mode with some configured memory
stack, such as the processor cache configured as memory.</div></blockquote>
</div>
<div class="section" id="access-to-the-boot-firmware-volume-bfv-and-other-boot-critical-fvs">
<h4>5.1.2.3 Access to the Boot Firmware Volume (BFV) and other boot-critical FVs<a class="headerlink" href="#access-to-the-boot-firmware-volume-bfv-and-other-boot-critical-fvs" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The program that the Security (SEC) phase hands control to is known
as the PEI Foundation. PEIMs may reside in the BFVor other FVs. A
“special” PEIM must be resident in the BFV to provide information
about the location of the other FVs.</p>
<p>Each file that is required to boot, in the BFV and other critical
FVs (like where the PEI foundation is located), must be able to be
discovered and validated by the PEI phase. This allows the PEI phase
to determine if those FVs have been corrupted.</p>
<p>The PEI Foundation and the PEIMs are expected to be stored in some
reasonably tamper-proof (albeit not necessarily in the strict
security-based definition of the term) nonvolatile storage (NVS).
The storage is expected to be fairly analogous to a flat file system
with the unique IDs substituting for names. Rules for using the
particular NVS might affect certain storage considerations, but a
standard data-only mechanism for locating PEIMs by ID is required.
The PI Architecture architecture describes the PI Firmware Volume
format and PI Firmware File System format, with the GUID convention
of naming files. These standards are architectural for PEI inasmuch
as the PEI phase needs to directly support this file system.</p>
<p>The BFV can only be constructed of type
<strong>EFI_FIRMWARE_FILE_SYSTEM2_GUID</strong>.</p>
<p>The PEI Foundation, and some PEIMs required for recovery, must be
either locked into a nonupdateable FVor must be able to be updated
via a “fault-tolerant” mechanism. The fault-tolerant mechanism is
designed such that, if the system halts at any point, either the old
(preupdate) PEIM or the newly updated PEIM is entirely valid and
that the PEI phase can determine which is valid.</p>
</div></blockquote>
</div>
<div class="section" id="access-to-the-boot-firmware-volume-in-ia-32-intel-architecture">
<h4>5.1.2.4 Access to the Boot Firmware Volume in IA-32 Intel Architecture<a class="headerlink" href="#access-to-the-boot-firmware-volume-in-ia-32-intel-architecture" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>In IA-32 Intel architecture, the Security (SEC) file is at the top
of the Boot Firmware Volume (BFV).</p>
<p>This SEC file will have the 16-byte entry point for IA-32 and
restarts at address 0xFFFFFFF0.</p>
</div></blockquote>
</div>
<div class="section" id="access-to-the-boot-firmware-volume-in-itanium-processor-family">
<h4>5.1.2.5 Access to the Boot Firmware Volume in Itanium Processor Family<a class="headerlink" href="#access-to-the-boot-firmware-volume-in-itanium-processor-family" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>In the Itanium processor family, the microcode starts up the
Processor Abstraction Layer A (PAL-A) code, which is the first layer
of PAL code and is provided by the processor vendor, that resides in
the Boot Firmware Volume (BFV). This code minimally initializes the
processor and then finds and authenticates the second layer of PAL
code, called PAL-B. The location of both PAL-A and PAL-B can be
found by consulting either of the following:</div></blockquote>
<ul>
<li><p class="first">The architected pointers in the ROM (near the 4 GiB region)</p>
</li>
<li><p class="first">The Firmware Interface Table (FIT) pointer in the ROM</p>
<blockquote>
<div><p>The PAL layer communicates with the OEM boot firmware using a single
entry point called the</p>
<p>System Abstraction Layer entry point (SALE_ENTRY). The PEI
Foundation will be located at the SALE_ENTRY point on the boot
firmware device for an Itanium-based system. The Itanium processor
family PEIMs, like other PEIMs, may reside in the BFV or other
firmware volumes. A “special” PEIM must be resident in the BFV to
provide information about the location of the other firmware
volumes; this will be described in the context of the
<strong>EFI_PEI_FIND_FV_PPI</strong> description. It must also be noted that
in an Itanium-based system, all the processors in each node start up
and execute the PAL code and subsequently enter the PEI Foundation.
The BFV of a particular node must be accessible by all the
processors running in that node. This also means that some of the
PEIMs in the Itanium® architecture boot path will be multiprocessor
(MP) aware.</p>
<p>In an Itanium-based system, it is also imperative that the
organization of firmware modules in the BFV must be such that at
least the PAL-A is contained in the fault-tolerant regions. This
processorspecific PAL-A code authenticates the PAL-B code, which is
usually contained in the non-faulttolerant regions of the firmware
system. The PAL-A and PAL-B binary components are always visible to
all the processors in a node at the time of power-on; the system
fabric should not need to be initialized.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="pei-foundation-entry-point">
<h2>5.2 PEI Foundation Entry Point<a class="headerlink" href="#pei-foundation-entry-point" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id101">
<h3>5.2.1 PEI Foundation Entry Point<a class="headerlink" href="#id101" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The Security (SEC) phase calls the entry point to the PEI Foundation
with the following information:</div></blockquote>
<ul>
<li><p class="first">A set of PPIs</p>
</li>
<li><p class="first">Size and location of the Boot Firmware Volume (BFV)</p>
</li>
<li><p class="first">Size and location of other boot-critical FVs, by adding the firmware
volume into the PpiList with <strong>EFI_PEI_FIRMWARE_VOLUME_PPI</strong>
type.</p>
</li>
<li><p class="first">Size and location of the temporary RAM</p>
</li>
<li><p class="first">Size and location of the temporary RAM available for use by the PEI
Foundation</p>
</li>
<li><p class="first">Size and location of the stack</p>
<blockquote>
<div><p>The entry point is described in “Code Definitions” below.</p>
<p><strong>Prototype typedef VOID</strong></p>
<p><strong>EFIAPI</strong></p>
<p><strong>(*EFI_PEI_CORE_ENTRY_POINT)(</strong></p>
<p><strong>IN CONST EFI_SEC_PEI_HAND_OFF</strong> <em>*SecCoreData,</em></p>
<p><strong>IN CONST EFI_PEI_PPI_DESCRIPTOR</strong> <em>*PpiList</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>SecCoreData</em></p>
<p>Points to a data structure containing information about the PEI
core’s operating environment, such as the size and location of
temporary RAM, the stack location and the BFV location. The type
<strong>EFI_SEC_PEI_HAND_OFF</strong> is defined in “Related Definitions”
below.</p>
<p><em>PpiList</em></p>
<p>Points to a list of one or more PPI descriptors. These PPI
descriptors can be a combination of descriptors of type
<strong>EFI_PEI_PPI_DESCRIPTOR</strong> for PPIs to be installed initially by
the PEI core and descriptors of type</p>
<p><strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong> for notifications in which the PEI
Core will notify when the PPI service is installed. An empty PPI
list consists of a single descriptor with the end-tag
<strong>EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST</strong>. Types
<strong>EFI_PEI_PPI_DESCRIPTOR</strong> and <strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong>
are defined in “PEIM Descriptors.” As part of its initialization
phase, the PEI Foundation will add these SEC-hosted PPIs to its PPI
database, such that both the PEI Foundation and any modules can
leverage the associated service calls and/or code in these early
PPIs. This should contain all the boot critical FVs that would be
passed from SEC to PEI Foundation thorough the
<strong>EFI_PEI_FIRMWARE_VOLUME_PPI</strong>.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is the entry point for the PEI Foundation, which
allows the SEC phase to pass information about the stack, temporary
RAM and the Boot Firmware Volume. In addition, it also allows the
SEC phase to pass services and data forward for use during the PEI
phase in the form of one or more PPIs. These PPI’s will be installed
and/or immediately signaled if they are notification type.</p>
<p>There is no limit to the number of additional PPIs that can be
passed from SEC into the PEI Foundation. As part of its
initialization phase, the PEI Foundation will add these SEC-hosted
PPIs to its PPI database such that both the PEI Foundation and any
modules can leverage the associated service calls and/or code in
these early PPIs.</p>
<p>Finally, later phases of platform evolution might need many of the
features and data that the SEC phase might possibly have. To support
this, the SEC phase can construct a</p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR</strong> and pass its address into the PEI
Foundation as the final argument.</p>
<p>Among these PPIs, the SEC can pass an optional PPI,</p>
<p><strong>EFI_SEC_PLATFORM_INFORMATION_PPI</strong>, as part of the PPI list
that is passed to the PEI</p>
<p>Foundation entry point. This PPI abstracts platform-specific
information that the PEI Foundation needs to discover where to begin
dispatching PEIMs. Other possible values to pass into the PEI
Foundation would include any security or verification services, such
as the Trusted Computing Group (TCG) access services, because the
SEC would constitute the Core Root-of-Trust Module (CRTM) in a
TCG-conformant system.</p>
<p>Further, SEC can pass the <strong>EFI_SEC_HOB_DATA_PPI</strong> as a part of
the PPI list. This PPI can retrieve zero or more HOBs to be added to
the HOB list before any PEIMs are dispatched.</p>
</div></blockquote>
<p><strong>Related Definitions typedef struct _EFI_SEC_PEI_HAND_OFF {</strong></p>
<blockquote>
<div><p><strong>UINT16</strong> <em>DataSize;</em></p>
<p><strong>VOID</strong> <em>*BootFirmwareVolumeBase;</em></p>
<p><strong>UINTN</strong> <em>BootFirmwareVolumeSize;</em></p>
<p><strong>VOID</strong> <em>*TemporaryRamBase;</em></p>
<p><strong>UINTN</strong> <em>TemporaryRamSize;</em></p>
<p><strong>VOID</strong> <em>*PeiTemporaryRamBase;</em></p>
<p><strong>UINTN</strong> <em>PeiTemporaryRamSize;</em></p>
<p><strong>VOID</strong> <em>*StackBase;</em></p>
<p><strong>UINTN</strong> <em>StackSize;</em></p>
<p><strong>} EFI_SEC_PEI_HAND_OFF;</strong></p>
<p><em>DataSize</em></p>
<p>Size of the data structure.</p>
<p><em>BootFirmwareVolumeBase</em></p>
<p>Points to the first byte of the boot firmware volume, which the PEI
Dispatcher should search for PEI modules.</p>
<p><em>BootFirmwareVolumeSize</em></p>
<p>Size of the boot firmware volume, in bytes.</p>
<p><em>TemporaryRamBase</em></p>
<p>Points to the first byte of the temporary RAM.</p>
<p><em>TemporaryRamSize</em></p>
<p>Size of the temporary RAM, in bytes.</p>
<p><em>PeiTemporaryRamBase</em></p>
<p>Points to the first byte of the temporary RAM available for use by
the PEI Foundation.</p>
<p>The area described by <em>PeiTemporaryRamBase</em> and
<em>PeiTemporaryRamSize</em> must not extend outside beyond the area
described by <em>TemporaryRamBase</em> &amp;</p>
<p><em>TemporaryRamSize</em>. This area should not overlap with the area
reported by <em>StackBase</em> and <em>StackSize</em>. <em>PeiTemporaryRamSize</em></p>
<p>Size of the available temporary RAM available for use by the PEI
Foundation, in bytes.</p>
<p><em>StackBase</em></p>
<p>Points to the first byte of the stack. This are may be part of the
memory described by <em>TemporaryRamBase</em> and <em>TemporaryRamSize</em> or may
be an entirely separate area.</p>
<p><em>StackSize</em></p>
<p>Size of the stack, in bytes.</p>
<p>The information from SEC is <em>mandatory</em> information that is placed
on the stack by the SEC phase to invoke the PEI Foundation.</p>
<p>The SEC phase provides the required processor and/or platform
initialization such that there is a temporary RAM region available
to the PEI phase. This temporary RAM could be a particular
configuration of the processor cache, SRAM, or other source. What is
important with respect to this handoff is that the PEI ascertain the
available amount of cache as RAM from this data structure.</p>
<p>Similarly, the PEI Foundation needs to receive <em>a priori</em>
information about where to commence the dispatch of PEIMs. A
platform can have various size BFVs. As such, the</p>
<p><em>BootFirmwareVolume</em> value tells the PEI Foundation where it can
expect to discover a firmware volume header data structure, and it
is this firmware volume that contains the PEIMs necessary to perform
the basic system initialization.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="pei-calling-convention-processor-binding">
<h2>5.3 PEI Calling Convention Processor Binding<a class="headerlink" href="#pei-calling-convention-processor-binding" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Unless otherwise specified, the calling convention used for PEI
functions is the same as the one specified in the UEFI
specification. However, for certain processors, an alternate calling
convention is recommended for new PPI definitions.</div></blockquote>
</div>
<div class="section" id="pei-services-table-retrieval">
<h2>5.4 PEI Services Table Retrieval<a class="headerlink" href="#pei-services-table-retrieval" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>This section describes processor-specific mechanisms for retrieving
a pointer to a pointer to the PEI Services Table
(<strong>EFI_PEI_SERVICES**</strong>) such as is commonly used in PEIMs. The
means of storage and retrieval are processor specific.</div></blockquote>
<div class="section" id="x86">
<h3>5.4.1 X86<a class="headerlink" href="#x86" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For X86 processors, the <strong>EFI_PEI_SERVICES**</strong> is stored in the
4 bytes immediately preceding the Interrupt Descriptor Table.</p>
<p>The <strong>EFI_PEI_SERVICES**</strong> can be retrieved with the following
code fragment, which should be placed in a library routine for
portability between architectures:</p>
<p><strong>IDTR32 STRUCT</strong></p>
<p><strong>Limit DW 1 DUP (?)</strong></p>
<p><strong>BaseAddress DD 1 DUP (?) IDTR32 ENDS</strong></p>
<p><strong>sub esp, SIZEOF IDTR32 sidt FWORD PTR ss:[esp] mov eax,
[esp].IDTR32.BaseAddress mov eax, DWORD PTR [eax – 4] add esp,
SIZEOF IDTR32</strong></p>
</div></blockquote>
<p><strong>5.4.1.1 Interrupt Descriptor Table Initialization and Ownership
Rules.</strong></p>
<ol class="arabic simple">
<li><dl class="first docutils">
<dt>The SEC Core must initialize the IDT using the lidt command and</dt>
<dd>ensure that the four-bytes field immediately preceding the IDT
base address resides within temporary memory.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The PEI Foundation initializes or updates the four-byte field</dt>
<dd>immediately preceding the currently loaded IDT base address.</dd>
</dl>
</li>
<li>Any PEIM can reinitialize the IDT with the following restrictions:<ul>
<li>The four-bytes field immediately prior to new IDT base address
must reside within the temporary or permanent memory.</li>
<li>The four-byte field immediately preceding the old IDT base address
must be copied to the four-byte field immediately preceding the
new IDT base address.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="x64">
<h3>5.4.2 x64<a class="headerlink" href="#x64" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For x64 processors, the <strong>EFI_PEI_SERVICES**</strong> is stored in
eight bytes immediately preceding the Interrupt Descriptor Table</p>
<p>The <strong>EFI_PEI_SERVICES**</strong> can be retrieved with the following
code fragment, which should be placed in a library routine for
portability between architectures:</p>
<p><strong>IDTR64 STRUCT</strong></p>
<p><strong>Limit DW 1 DUP (?)</strong></p>
<p><strong>BaseAddress DQ 1 DUP (?) IDTR64 ENDS</strong></p>
<p><strong>sub rsp, SIZEOF IDTR64 sidt [rsp]</strong></p>
<p><strong>mov rax, [rsp].IDTR64.BaseAddress mov rax, QWORD PTR [rax – 8] add
rsp, SIZEOF IDTR64</strong></p>
</div></blockquote>
<p><strong>5.4.2.1 Interrupt Descriptor Table Initialization and Ownership
Rules.</strong></p>
<ol class="arabic simple">
<li><dl class="first docutils">
<dt>The SEC Core must initialize the IDT using the lidt command and</dt>
<dd>ensure that the eight-bytes field immediately preceding the IDT
base address resides within temporary memory.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The PEI initializes or updates the eight-byte field immediately</dt>
<dd>preceding the currently loaded IDT base address.</dd>
</dl>
</li>
<li>Any PEIM can reinitialize the IDT with the following restrictions:<ul>
<li>The eight-bytes field immediately prior to new IDT base address
must reside within the temporary or permanent memory</li>
<li>The eight-byte field immediately preceding the old IDT base
address must be copied to the eight-byte field immediately
preceding the new IDT base address.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="itanium-processor-family-register-mechanism">
<h3>5.4.3 Itanium Processor Family – Register Mechanism<a class="headerlink" href="#itanium-processor-family-register-mechanism" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For Itanium Processor Family processors, the
<strong>EFI_PEI_SERVICES**</strong> <a class="reference external" href="http://www.intel.com/design/itanium/downloads/245358.htm">is stored in kernel
register</a></p>
<p><a class="reference external" href="http://www.intel.com/design/itanium/downloads/245358.htm">7 (ar.kr7). Information on the kernel registers for IPF can be
found
at</a>
<em>http://www.intel.com/design/ itanium/downloads/245358.htm</em>.</p>
<p>The <strong>EFI_PEI_SERVICES**</strong> can be retrieved with the following
code fragment, which may be placed in a library routine for
portability between architectures:</p>
<p><strong>AsmReadKr7 mov r8, ar.kr7;; br.ret b0;; EFI_PEI_SERVICES **</strong></p>
<p><strong>GetPeiServicesTablePointer (</strong></p>
<p><strong>VOID</strong></p>
<p><strong>) {</strong></p>
<p><strong>return (EFI_PEI_SERVICES **)(UINTN)AsmReadKr7 ();</strong></p>
<p><strong>}</strong></p>
</div></blockquote>
<p><strong>*Note:</strong> Compilers should not be using KRs, they are reserved for OS
use (i.e.,this is the overlap w/ the Software Development Manual). Also,
priv. level 3 code can only read KRs and not write them anyway, only PL0
code can write these.*</p>
</div>
<div class="section" id="arm-processor-family-register-mechanism">
<h3>5.4.4 ARM Processor Family – Register Mechanism<a class="headerlink" href="#arm-processor-family-register-mechanism" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For the ARM Processor Family processors, the
<strong>EFI_PEI_SERVICES**</strong> is stored in a the</p>
<p>TPIDRURW read/write Software Thread ID register defined in the
<em>ARMv7-A Architectural Reference Manual</em>.</p>
<p>The <strong>EFI_PEI_SERVICES**</strong> can be retrieved with the following
code fragment, which may be placed in a library routine for
portability between architectures:</p>
<p><strong>CpuReadTPIDRURW:</strong></p>
<p><strong>MRC p15, 0, r0, c13, c0, 2 bx lr</strong></p>
<p><a href="#id102"><span class="problematic" id="id103">**</span></a>EFI_PEI_SERVICES ** **</p>
<p><strong>GetPeiServicesTablePointer (</strong></p>
<p><strong>VOID</strong></p>
<p><strong>) {</strong></p>
<p><strong>return (EFI_PEI_SERVICES **)(UINTN)CpuReadTPIDRURW (); }</strong></p>
</div></blockquote>
<div class="section" id="arm-vector-table">
<h4>5.4.4.1 ARM Vector Table<a class="headerlink" href="#arm-vector-table" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>For ARM processors the vector table entries are instructions, and
thus are limited to 24-bit relative offset of a branch instruction.
The PI specification requires that the 8 defined vectors contain the
following instruction LDR pc, [pc, #0x20]. This means the 32-bit
address of the handler is contained at a 32-byte offset from the
address of the vector. When PI code hooks into the vector table it
must ensure that the 32-bit absolute address offset 32-bytes from
the vector is what is updated. The first code in the platform that
initializes the vector table must fill it with 8 LDR pc, [pc, #0x20]
instructions.</div></blockquote>
</div>
</div>
<div class="section" id="aarch64-processor-family-register-mechanism">
<h3>5.4.5 AArch64 Processor Family – Register Mechanism<a class="headerlink" href="#aarch64-processor-family-register-mechanism" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>For AArch64 architecture processors, the <strong>EFI_PEI_SERVICES**</strong>
is stored in the TPIDR_EL0 register. Information on this register
can be found in the “<em>ARM Architecture Reference Manual ARMv8, for
ARMv8-A architecture profile</em>”.</div></blockquote>
</div>
<div class="section" id="risc-v-processor-family-register-mechanism">
<h3>5.4.6 RISC-V Processor Family – Register Mechanism<a class="headerlink" href="#risc-v-processor-family-register-mechanism" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For the RISC-V processor, the <strong>EFI_PEI_SERVICES **</strong> is stored
in the</p>
<p><strong>RISCV_MACHINE_MODE_CONTEXT</strong> structure and the pointer to this
structure is stored in the Machine mode Control and Status register
<strong>MSCRATCH. EFI_PEI_SERVICES **</strong> is one of the structure member
in <strong>RISCV_MACHINE_MODE_CONTEXT</strong>. The contents in this structure
will be kept across all UEFI execution phases during the entire
system life. <strong>MSCRATCH</strong> is a readable and writable CSR which is
initiated to maintain various pointers for each UEFI execution
phase. The pointers in this structure includes <strong>EFI_PEI_SERVICES
**</strong> and the interrupt handlers of each RISC-V privilege level.</p>
<p><strong>/// Machine mode context used for saving hart-local context.
typedef struct _RISCV_MACHINE_MODE_CONTEXT {
EFI_PHYSICAL_ADDRESS PeiService;/// PEI service.</strong></p>
<p><a href="#id104"><span class="problematic" id="id105">**</span></a>EFI_PHYSICAL_ADDRESS MachineModeTrapHandler;/// Machine mode
trap **</p>
<p><strong>/// handler.</strong></p>
<p><strong>EFI_PHYSICAL_ADDRESS HypervisorModeTrapHandler;/// Hypervisor
mode trap</strong></p>
<p><strong>/// handler.</strong></p>
<p><a href="#id106"><span class="problematic" id="id107">**</span></a>EFI_PHYSICAL_ADDRESS SupervisorModeTrapHandler;/// Supervisor
mode trap **</p>
<p><strong>/// handler.</strong></p>
<p><strong>EFI_PHYSICAL_ADDRESS UserModeTrapHandler;/// User mode trap
handler.</strong></p>
<p><strong>TRAP_HANDLER_CONTEXT MModeHandler;/// Handler for machine</strong></p>
<p><strong>/// mode.</strong></p>
<p><strong>} RISCV_MACHINE_MODE_CONTEXT;</strong></p>
<p><strong>EFI_PEI_SERVICES ** can be retrieved through below function
which is provided by RISC-V library.</strong></p>
<p><strong>CONST EFI_PEI_SERVICES **</strong></p>
<p><strong>EFIAPI</strong></p>
<p><strong>GetPeiServicesTablePointer (</strong></p>
<p><strong>VOID</strong></p>
<p><strong>)</strong></p>
<p><strong>{</strong></p>
<p><strong>RISCV_MACHINE_MODE_CONTEXT *Context;</strong></p>
<p><strong>EFI_PEI_SERVICES **PeiServices;</strong></p>
<p><a href="#id108"><span class="problematic" id="id109">**</span></a>Context = (RISCV_MACHINE_MODE_CONTEXT *) UINTN) **</p>
<p><strong>RiscVGetScratch ();</strong></p>
<p><strong>PeiServices = (EFI_PEI_SERVICES **) Context-&gt;PeiService;
return (CONST EFI_PEI_SERVICES **)PeiServices; }</strong></p>
</div></blockquote>
</div>
</div>
<div class="section" id="pei-dispatcher-introduction">
<h2>5.5 PEI Dispatcher Introduction<a class="headerlink" href="#pei-dispatcher-introduction" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The PEI Dispatcher’s job is to hand control to the PEIMs in an
orderly manner. The PEI Dispatcher</p>
<p>consists of a single phase. It is during this phase that the PEI
Foundation will examine each file in the firmware volumes that
contain files of type <strong>EFI_FV_FILETYPE_PEIM</strong> or</p>
<p><strong>EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER</strong> (see the <em>Platform
Initialization Specification</em>,</p>
<p>Volume 3, for file type definitions). It will examine the dependency
expression (depex) and the optional <em>a priori</em> file within each
firmware file to decide when a PEIM is eligible to be dispatched.
The binary encoding of the depex will be the same as that of a depex
associated with a PEIM.</p>
</div></blockquote>
</div>
<div class="section" id="ordering">
<h2>5.6 Ordering<a class="headerlink" href="#ordering" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id110">
<h3>5.6.1 Requirements<a class="headerlink" href="#id110" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Except for the order imposed by an <em>a priori</em> file, it is not
reasonable to expect PEIMs to be executed in any order. A chipset
initialization PEIM usually requires processor initialization and a
memory initialization PEIM usually requires chipset initialization.
On the other hand, the PEIMs that satisfy these requirements might
have been authored by different organizations and might reside in
different FVs. The requirement is thus to, without memory, create a
mechanism to allow for the definition of ordering among the
different PEIMs so that, by the time a PEIM executes, all of the
requirements for it to execute have been met.</p>
<p>Although the update and build processes assist in resolving ordering
issues, they cannot be relied upon completely. Consider a system
with a removable processor card containing a processor and firmware
volume that plugs into a main system board. If the processor card is
upgraded, it is entirely reasonable that the user should expect the
system to work even though no update program was executed.</p>
</div></blockquote>
</div>
<div class="section" id="requirement-representation-and-notation">
<h3>5.6.2 Requirement Representation and Notation<a class="headerlink" href="#requirement-representation-and-notation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Requirements are represented by GUIDs, with each GUID representing a
particular requirement. The requirements are represented by two sets
of data structures:</div></blockquote>
<ul>
<li><p class="first">The dependency expression (depex) of a given PEIM</p>
</li>
<li><p class="first">The installed set of PPIs maintained by the PEI Foundation in the PPI
database</p>
<blockquote>
<div><p>This mechanism provides for a “weak ordering” among PEIMs. If PEIMs
A and B consume X (written AcX and BcX), once a PEIM (C) that
produces X (CpX) is executed, A and B can be executed. There is no
definition about the order in which A and B are executed.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="pei-a-priori-file-overview">
<h3>5.6.3 PEI <em>a priori</em> File Overview<a class="headerlink" href="#pei-a-priori-file-overview" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The PEI <em>a priori</em> file is a special file that may optionally be
present in a firmware volume, and its main purpose is to provide a
greater degree of flexibility in the firmware design of a platform.
Specifically, the <em>a priori</em> file complements the dependency
expression mechanism of PEI by stipulating a series of modules which
need be dispatched in a prescribed order.</p>
<p>There may be at most one PEI <em>a priori</em> file per firmware volume
present in a platform. The <em>a priori</em> file has a known GUID file
name <strong>PEI_APRIORI_FILE_NAME_GUID</strong>, enabling the PEI</p>
<p>Foundation dispatch behavior to find the <em>a priori</em> file if it is
present. The contents of the file shall contain data of the format
<strong>PEI_APRIORI_FILE_CONTENTS</strong>, with possibly zero entries. Every
time the PEI Dispatcher discovers a firmware volume, it first looks
for the <em>a priori</em> file. The PEIM’s enumerated in a an <em>a priori</em>
file must exist in the same firmware volume as the <em>a priori</em> file
iteself; no cross-volume mapping is allowed. The PEI Foundation will
invoke the PEIM’s listed in the <strong>PEI_APRIORI_FILE_CONTENTS</strong> in
the order found in this file.</p>
<p>Without the <em>a priori</em> file, PEIMs executed solely because of their
dependency expressions are weakly ordered. This means that the
execution order is not completely deterministic between boots or
between platforms. In some cases a deterministic execution order is
required. The PEI a priori file provides a deterministic execution
order of PEIMs using the following two implementation methods.</p>
<p>The <em>a priori</em> model must be supported by all PEI Foundation
implementations, but it does not preclude additional <em>a priori</em>
dispatch methodologies, as long as the latter models use a different
mechanism and/or file name GUID for the alternate <em>a priori</em> module
listing. The <em>a priori</em> file format follows below.</p>
</div></blockquote>
</div>
<div class="section" id="pei-apriori-file-name-guid">
<h3>PEI_APRIORI_FILE_NAME_GUID<a class="headerlink" href="#pei-apriori-file-name-guid" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><a href="#id111"><span class="problematic" id="id112">**</span></a>Summary **</p>
<p>The GUID <strong>PEI_APRIORI_FILE_NAME_GUID</strong> definition is the file
name of the PEI <em>a priori</em> file that is stored in a firmware volume.</p>
<p><strong>GUID</strong></p>
<p><a href="#id113"><span class="problematic" id="id114">**</span></a>#define PEI_APRIORI_FILE_NAME_GUID \ **</p>
<p><strong>{0x1b45cc0a,0x156a,0x428a,0xaf62,0x49,0x86,\</strong></p>
<p><strong>0x4d,0xa0,0xe6,0xe6}</strong></p>
<p><a href="#id115"><span class="problematic" id="id116">**</span></a>typedef struct { **</p>
<p><strong>EFI_GUID</strong> <em>FileNamesWithinVolume[NumberOfModulesInVolume];</em></p>
<p><a href="#id117"><span class="problematic" id="id118">*</span></a>// Optional list of file-names *</p>
<p><strong>} PEI_APRIORI_FILE_CONTENTS;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>FileNamesWithinVolume[]</em></p>
<p>An array of zero or more EFI_GUID type entries that match the file
names of PEIM modules in the same Firmware Volume. The maximum
number of entries</p>
</div></blockquote>
<p><em>NumberOfModulesInVolume</em> is determined by the number of modules in the
FV.</p>
<blockquote>
<div><p><strong>Description</strong></p>
<p>This file must be of type <strong>EFI_FV_FILETYPE_FREEFORM</strong> and must
contain a single section of type <strong>EFI_SECTION_RAW</strong>. For details
on firmware volumes, firmware file types, and firmware file section
types, see the <em>Platform Initialization Specification</em>, Volume 3.</p>
</div></blockquote>
<div class="section" id="dispatch-behavior">
<h4>5.6.3.1 Dispatch Behavior<a class="headerlink" href="#dispatch-behavior" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The <em>a priori</em> file can contain a list of the EFI_GUIDs, which are
the names of the PEIM files within the same firmware volume. Herein,
the PEI Foundation dispatch logic reads the list of names from the
<em>a priori</em> file and invokes the appropriately named module in the
order enumerated in the <em>a priori</em> file. This value can be
calculated by means of the size of <strong>PEI_APRIORI_FILE_CONTENTS</strong>.
This shall be an integral number of GUID sizes.</p>
<p>If there is a file name within <strong>PEI_APRIORI_FILE_CONTENTS</strong>
which is in the deleted state or does not exist, the specific file
name shall be ignored by the PEI Foundation dispatch logic and the
successive entry invoked.</p>
<p>During dispatch of PEIM’s in the <em>a priori</em> file, any PEIMs in newly
published firmware volumes will be ignored until completion of the
<em>a priori</em> file dispatch. These interfaces would be assessed during
subsequent module dispatch, though.</p>
<p>In addition to ignoring any additional volumes published during <em>a
priori</em> dispatch, any dependency expressions associated with PEIMs
listed within <strong>PEI_APRIORI_FILE_CONTENTS</strong> are ignored.</p>
<p>During dispatch of the <em>a priori</em> PEIM list, the PEI Dispatcher
shall invoke the</p>
<p><strong>EFI_PEI_SECURITY2_PPI</strong> <strong>AuthenticationState</strong> service, if it
exists, to qualify the dispatch of each module. This is the same
behavior as the normal dependency-based dispatch. For the <em>a priori</em>
file in the boot firmware volume, for example, the
<strong>EFI_PEI_SECURITY2_PPI</strong> could be passed by the SEC into the PEI
Foundation via the optional <strong>EFI_PEI_PPI_DESCRIPTOR</strong> list. This
latter scenario allows authentication of PEIMs in the <em>a priori</em>
file.</p>
<p>After executing all of the PEIMs specified in the <em>a priori</em> file,
the PEI Dispatcher searches the firmware volume for any additional
PEIMs and executes them according to their dependency expressions.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="firmware-volume-image-files">
<h3>5.6.4 Firmware Volume Image Files<a class="headerlink" href="#firmware-volume-image-files" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For PEI, while processing a firmware volume, if a file of type</p>
<p><strong>EFI_FV_FIRMWARE_VOLUME_IMAGE</strong> is found, the PEI Dispatcher
will check whether this firmware volume image file was already
processed. If it was, then the file is ignored.</p>
<p>Otherwise, the PEI Dispatcher will search the file for a section
with the type</p>
<p><strong>EFI_SECTION_PEI_DEPEX</strong>, and if found, evaluate the expression
against the presently installed entries in the PPI database. If the
file has a dependency expression that evaluates to TRUE (or no
<strong>EFI_SECTION_PEI_DEPEX</strong> section), then the PEI Dispatcher will
search the file for a section with the type
<strong>EFI_SECTION_FIRMWARE_VOLUME_IMAGE</strong>, copy its contents into
memory, and install the <strong>EFI_PEI_FIRMWARE_VOLUME_INFO_PPI</strong>
and</p>
<p><strong>EFI_PEI_FIRMWARE_VOLUME_INFO2_PPI</strong> for the firmware volume
image, and add HOBs of type <strong>EFI_HOB_FIRMWARE_VOLUME</strong> and
<strong>EFI_HOB_FIRMWARE_VOLUME2</strong> to the hob list for the firmware
volume image.</p>
</div></blockquote>
</div>
<div class="section" id="peim-dependency-expressions">
<h3>5.6.5 PEIM Dependency Expressions<a class="headerlink" href="#peim-dependency-expressions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The sequencing of PEIMs is determined by evaluating a <em>dependency
expression</em> associated with each PEIM. This expression describes the
requirements necessary for that PEIM to run, which imposes a weak
ordering on the PEIMs. Within this weak ordering, the PEIMs may be
initialized in any order.</div></blockquote>
</div>
<div class="section" id="types-of-dependencies">
<h3>5.6.6 Types of Dependencies<a class="headerlink" href="#types-of-dependencies" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The base unit of the dependency expression is a dependency. A
representative syntax (used in this document for descriptive
purposes) for each dependency is shown in the following section. The
syntax is case-insensitive and mnemonics are used in place of
non-human-readable data such as GUIDs. White space is optional.</p>
<p>The operands are GUIDs of PPIs. The operand becomes “true” when a
PPI with the GUID is registered.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="dependency-expressions">
<h2>5.7 Dependency Expressions<a class="headerlink" href="#dependency-expressions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id119">
<h3>5.7.1 Introduction<a class="headerlink" href="#id119" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A PEIM is stored in a firmware volume as a file with one or more
sections. One of the sections must be a PE32+ image. If a PEIM has a
dependency expression, then it is stored in a dependency section. A
PEIM may contain additional sections for compression and security
wrappers. The PEI Dispatcher can identify the PEIMs by their file
type. In addition, the PEI Dispatcher can look up the dependency
expression for a PEIM by looking for a dependency section in a PEIM
file. The dependency section contains a section header followed by
the actual dependency expression that is composed of a packed byte
stream of opcodes and operands.</p>
<p>Dependency expressions stored in dependency sections are designed to
meet the following goals:</p>
</div></blockquote>
<ul>
<li><p class="first">Be small to conserve space.</p>
</li>
<li><p class="first">Be simple and quick to evaluate to reduce execution overhead.</p>
<blockquote>
<div><p>These two goals are met by designing a small, stack-based
instruction set to encode the dependency expressions. The PEI
Dispatcher must implement an interpreter for this instruction set to
evaluate dependency expressions. The instruction set is defined in
the following topics.</p>
<p>See <em>“Dependency Expression Grammar” on page 234</em> for an example BNF
grammar for a dependency expression compiler. There are many
possible methods of specifying the dependency expression for a PEIM.
This example grammar demonstrates one possible design for a tool
that can be used to help build PEIM images.</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="dependency-expression-instruction-set">
<h4>5.7.1.1 Dependency Expression Instruction Set<a class="headerlink" href="#dependency-expression-instruction-set" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The following topics describe each of the dependency expression
(depex) opcodes in detail. Information includes a description of the
instruction functionality, binary encoding, and any limitations or
unique behaviors of the instruction.</p>
<p>Several of the opcodes require a GUID operand. The GUID operand is a
16-byte value that matches the type <strong>EFI_GUID</strong> that is described
in Chapter 2 of the UEFI 2.0 specification. These GUIDs represent
PPIs that are produced by PEIMs and the file names of PEIMs stored
in firmware volumes. A dependency expression is a packed byte stream
of opcodes and operands. As a result, some of the GUID operands will
not be aligned on natural boundaries. Care must be taken on
processor architectures that do allow unaligned accesses.</p>
<p>The dependency expression is stored in a packed byte stream using
postfix notation. As a dependency expression is evaluated, the
operands are pushed onto a stack. Operands are popped off the stack
to perform an operation. After the last operation is performed, the
value on the top of the stack represents the evaluation of the
entire dependency expression. If a push operation causes a stack
overflow, then the entire dependency expression evaluates to
<strong>FALSE</strong>. If a pop operation causes a stack underflow, then the
entire dependency expression evaluates to <strong>FALSE</strong>. Reasonable
implementations of a dependency expression evaluator should not make
arbitrary assumptions about the maximum stack size it will support.
Instead, it should be designed to grow the dependency expression
stack as required. In addition, PEIMs that contain dependency
expressions should make an effort to keep their dependency
expressions as small as possible to help reduce the size of the</p>
<p>PEIM.</p>
<p>All opcodes are 8-bit values, and if an invalid opcode is
encountered, then the entire dependency expression evaluates to
<strong>FALSE</strong>.</p>
<p>If an END opcode is not present in a dependency expression, then the
entire dependency expression evaluates to <strong>FALSE</strong>.</p>
<p>The final evaluation of the dependency expression results in either
a <strong>TRUE</strong> or <strong>FALSE</strong> result.</p>
</div></blockquote>
<p><strong>*Note:</strong> NoteThe PEI Foundation will only support the evaluation of
dependency expressions that are less than or equal to 256 terms.*</p>
<blockquote>
<div><p><em>Table 7</em> is a summary of the opcodes that are used to build
dependency expressions. The following sections describe each of
these instructions in detail.</p>
<p><strong>Table 7. Dependency Expression Opcode Summary</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Opcode</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x02</td>
<td>PUSH &lt;PPI GUID&gt;</td>
</tr>
<tr class="row-odd"><td>0x03</td>
<td>AND</td>
</tr>
<tr class="row-even"><td>0x04</td>
<td>OR</td>
</tr>
<tr class="row-odd"><td>0x05</td>
<td>NOT</td>
</tr>
<tr class="row-even"><td>0x06</td>
<td>TRUE</td>
</tr>
<tr class="row-odd"><td>0x07</td>
<td>FALSE</td>
</tr>
<tr class="row-even"><td>0x08</td>
<td>END</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="push">
<h3>PUSH<a class="headerlink" href="#push" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Syntax</strong></p>
<p><strong>PUSH &lt;PPI GUID&gt;</strong></p>
<p><strong>Description</strong></p>
<p>Pushes a Boolean value onto the stack. If the GUID is present in the
handle database, then a <strong>TRUE</strong> is pushed onto the stack. If the
GUID is not present in the handle database, then a <strong>FALSE</strong> is
pushed onto the stack. The test for the GUID in the handle database
may be performed with the Boot Service <strong>LocatePpi()</strong>.</p>
<p><strong>Operation</strong></p>
<p><a href="#id120"><span class="problematic" id="id121">**</span></a>Status = (*PeiServices)-&gt;LocatePpi (PeiServices, GUID, 0, NULL,
**</p>
<p><strong>&amp;Interface);</strong></p>
<p><strong>if (EFI_ERROR (Status)) {</strong></p>
<p><strong>PUSH FALSE;</strong></p>
<p><strong>} Else {</strong></p>
<p><strong>PUSH TRUE;</strong></p>
<p><strong>}</strong></p>
<p>The following table defines the <strong>PUSH</strong> instruction encoding.</p>
<p><strong>Table 8. PUSH Instruction Encoding</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Byte</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0x02</td>
</tr>
<tr class="row-odd"><td>1..16</td>
<td>A 16-byte GUID that represents a protocol that is produced by a different PEIM. The format is the same at type <strong>EFI_GUID</strong>.</td>
</tr>
</tbody>
</table>
<p><strong>Behaviors and Restrictions</strong></p>
<blockquote>
<div>None.</div></blockquote>
</div>
<div class="section" id="and">
<h3>AND<a class="headerlink" href="#and" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>AND</strong></p>
<p><a href="#id122"><span class="problematic" id="id123">**</span></a>Description **</p>
<p>Pops two Boolean operands off the stack, performs a Boolean <strong>AND</strong>
operation between the two operands, and pushes the result back onto
the stack.</p>
<p><strong>Operation</strong></p>
<p><strong>Operand1 &lt;= POP Boolean stack element</strong></p>
<p><strong>Operand2 &lt;= POP Boolean stack element</strong></p>
<p><strong>Result &lt;= Operand1 AND Operand2</strong></p>
<p><strong>PUSH Result</strong></p>
<p>Table 9 defines the <strong>AND</strong> instruction encoding.</p>
<p><strong>Table 9. AND Instruction Encoding</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Byte</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0x03</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Behaviors and Restrictions</strong></p>
<p>None.</p>
</div></blockquote>
</div>
<div class="section" id="or">
<h3>OR<a class="headerlink" href="#or" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>OR</strong></p>
<p><a href="#id124"><span class="problematic" id="id125">**</span></a>Description **</p>
<p>Pops two Boolean operands off the stack, performs a Boolean <strong>OR</strong>
operation between the two operands, and pushes the result back onto
the stack.</p>
<p><strong>Operation</strong></p>
<p><strong>Operand1 &lt;= POP Boolean stack element</strong></p>
<p><strong>Operand2 &lt;= POP Boolean stack element</strong></p>
<p><strong>Result &lt;= Operand1 OR Operand2</strong></p>
<p><strong>PUSH Result</strong></p>
<p>Table 10 defines the <strong>OR</strong> instruction encoding.</p>
<p><strong>Table 10. OR Instruction Encoding</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Byte</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0x04</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Behaviors and Restrictions</strong></p>
<p>None.</p>
</div></blockquote>
</div>
<div class="section" id="not">
<h3>NOT<a class="headerlink" href="#not" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>NOT</strong></p>
<p><a href="#id126"><span class="problematic" id="id127">**</span></a>Description **</p>
<p>Pops a Boolean operands off the stack, performs a Boolean <strong>NOT</strong>
operation on the operand, and pushes the result back onto the stack.</p>
<p><strong>Operation</strong></p>
<p><strong>Operand &lt;= POP Boolean stack element</strong></p>
<p><strong>Result &lt;= NOT Operand PUSH Result</strong></p>
<p>Table 11 defines the <strong>NOT</strong> instruction encoding.</p>
<p><strong>Table 11. NOT Instruction Encoding</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Byte</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0x05</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Behaviors and Restrictions</strong></p>
<p>None.</p>
</div></blockquote>
</div>
<div class="section" id="true">
<h3>TRUE<a class="headerlink" href="#true" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>TRUE</strong></p>
<p><a href="#id128"><span class="problematic" id="id129">**</span></a>Description **</p>
<p>Pushes a Boolean <strong>TRUE</strong> onto the stack.</p>
<p><strong>Operation</strong></p>
<p><strong>PUSH TRUE</strong></p>
</div></blockquote>
<p><em>Table 12</em> defines the <strong>TRUE</strong> instruction encoding.</p>
<blockquote>
<div><strong>Table 12. TRUE Instruction Encoding</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Byte</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0x06</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Behaviors and Restrictions</strong></p>
<p>None.</p>
</div></blockquote>
</div>
<div class="section" id="false">
<h3>FALSE<a class="headerlink" href="#false" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Syntax</strong></p>
<p><strong>FALSE</strong></p>
<p><a href="#id130"><span class="problematic" id="id131">**</span></a>Description **</p>
<p>Pushes a Boolean <strong>FALSE</strong> onto the stack.</p>
<p><strong>Operation</strong></p>
<p><strong>PUSH FALSE</strong></p>
</div></blockquote>
<p><em>Table 13</em> defines the <strong>FALSE</strong> instruction encoding.</p>
<blockquote>
<div><strong>Table 13. FALSE Instruction Encoding</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Byte</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0x07</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Behaviors and Restrictions</strong></p>
<p>None.</p>
</div></blockquote>
</div>
<div class="section" id="end">
<h3>END<a class="headerlink" href="#end" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Syntax END</strong></p>
<p><a href="#id132"><span class="problematic" id="id133">**</span></a>Description **</p>
<p>Pops the final result of the dependency expression evaluation off
the stack and exits the dependency expression evaluator.</p>
<p><strong>Operation</strong></p>
<p><strong>POP Result</strong></p>
<p><strong>RETURN Result</strong></p>
<p><em>Table 14</em> defines the <strong>END</strong> instruction encoding.</p>
<p><strong>Table 14. END Instruction Encoding</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Byte</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0x08</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>Behaviors and Restrictions</strong></p>
<p>This opcode must be the last one in a dependency expression.</p>
</div></blockquote>
<p><strong>PEI Foundation Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="dependency-expression-with-no-dependencies">
<h3>5.7.2 Dependency Expression with No Dependencies<a class="headerlink" href="#dependency-expression-with-no-dependencies" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>A PEIM that does not have any dependencies will have a dependency
expression that evaluates to <strong>TRUE</strong> with no dependencies on any
PPI GUIDs.</div></blockquote>
</div>
<div class="section" id="empty-dependency-expressions">
<h3>5.7.3 Empty Dependency Expressions<a class="headerlink" href="#empty-dependency-expressions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>If a PEIM file does not contain a dependency section, then the PEIM
has an empty dependency expression.</div></blockquote>
</div>
<div class="section" id="dependency-expression-reverse-polish-notation-rpn">
<h3>5.7.4 Dependency Expression Reverse Polish Notation (RPN)<a class="headerlink" href="#dependency-expression-reverse-polish-notation-rpn" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The actual equations will be presented by the PEIM in a
simple-to-evaluate form, namely postfix.</p>
<p>The following is a BNF encoding of this grammar. See <em>“Dependency
Expression Instruction Set” on page 65</em> for definitions of the
dependency expressions.</p>
<p>&lt;statement&gt; ::= &lt;expression&gt; END</p>
<p>&lt;expression&gt; ::= PUSH &lt;guid&gt; |</p>
<p>TRUE |</p>
<p>FALSE |</p>
<p>&lt;expression&gt; NOT |</p>
<p>&lt;expression&gt; &lt;expression&gt; OR |</p>
<p><em>&lt;expression&gt; &lt;expression&gt; AND</em></p>
</div></blockquote>
</div>
</div>
<div class="section" id="dispatch-algorithm">
<h2>5.8 Dispatch Algorithm<a class="headerlink" href="#dispatch-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id134">
<h3>5.8.1 Overview<a class="headerlink" href="#id134" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ordering-algorithm">
<h4>5.8.1.1 Ordering Algorithm<a class="headerlink" href="#ordering-algorithm" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The dispatch algorithm repeatedly scans through the PEIMs to find
those that have not been dispatched. For each PEIM that is found, it
scans through the PPI database of PPIs that have been published,
searching for elements in the yet-to-be-dispatched PEIM’s depex. If
all of the elements in the depex are in the PEI Foundation’s PPI
database, the PEIM is dispatched. The phase terminates when all
PEIMs are scanned and none dispatched.</div></blockquote>
<p><strong>*Note:</strong> The PEIM may be dispatched without a search if its depex is
NULL.*</p>
</div>
<div class="section" id="multiple-firmware-volume-support">
<h4>5.8.1.2 Multiple Firmware Volume Support<a class="headerlink" href="#multiple-firmware-volume-support" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>In order to expose a new firmware volume, a PEIM should install an
instance of</p>
<p><strong>EFI_PEI_FIRMWARE_VOLUME_INFO_PPI</strong> containing the firmware
volume format GUID, the starting address and the size of the
firmware volume’s window. PEIMs exposing firmware volumes which have
a firmware volume format other than the PI Architecture Firmware
Volume format should include the firmware volume format GUID in
their dependency expression.</p>
<p>PEIMs exposing memory-mapped firmware volumes should create a memory
resource descriptor HOB for the memory occupied by the firmware
volume if it is outside of the PEI memory.</p>
</div></blockquote>
<p>Version 1.7</p>
<blockquote>
<div>For each new exposed firmware volume, the PEI Foundation will take
the following steps: 1. Create a new firmware volume handle. The
firmware volume handle may be created by the PEI Foundation or by
the optional <strong>EFI_PEI_FIRMWARE_VOLUME_PPI.</strong></div></blockquote>
<ol class="arabic simple" start="2">
<li>Create a new firmware volume HOB.</li>
<li><dl class="first docutils">
<dt>If the firmware volume’s format (identified by its GUID) is not</dt>
<dd>supported directly by the PEI Foundation and it is not supported
by any installed <strong>EFI_PEI_FIRMWARE_VOLUME_PPI</strong>, the
firmware volume is skipped.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Otherwise, all PEIMs in the firmware volume are scheduled for</dt>
<dd>dispatching.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Find the <em>a priori</em> file, if it exists, and dispatch any PEIMs listed</dt>
<dd>in it.</dd>
</dl>
</li>
</ol>
</div>
</div>
<div class="section" id="id135">
<h3>5.8.2 Requirements<a class="headerlink" href="#id135" title="Permalink to this headline">¶</a></h3>
<div class="section" id="requirements-of-a-dispatching-algorithm">
<h4>5.8.2.1 Requirements of a Dispatching Algorithm<a class="headerlink" href="#requirements-of-a-dispatching-algorithm" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The dispatching algorithm must meet the following requirements:</div></blockquote>
<ol class="arabic simple">
<li>Preserve the dispatch weak ordering.</li>
<li>Prevent an infinite loop.</li>
<li>Control processor resources.</li>
<li>Preserve proper dispatch order.</li>
<li>Make use of available memory.</li>
<li>Invoke each PEIM’s entry point.</li>
<li>Know when the PEI Dispatcher tasks are finished.</li>
</ol>
<p><strong>5.8.2.2 Preserving Weak Ordering</strong></p>
<blockquote>
<div>The algorithm must preserve the weak ordering implied by the depex.</div></blockquote>
</div>
<div class="section" id="preventing-infinite-loops">
<h4>5.8.2.3 Preventing Infinite Loops<a class="headerlink" href="#preventing-infinite-loops" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>It is illegal for AcXpY (A consumes X and produces Y) and BcYpX.
This is known as a cycle and is unresolvable even if memory is
available. At a minimum, the dispatching algorithm must not end up
in an infinite loop in such a scenario. With the algorithm described
above, neither PEIM would be executed.</div></blockquote>
</div>
<div class="section" id="controlling-processor-register-resources">
<h4>5.8.2.4 Controlling Processor Register Resources<a class="headerlink" href="#controlling-processor-register-resources" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The algorithm must require that a minimum of the processor’s
register resources be preserved while PEIMs are dispatched.</div></blockquote>
</div>
<div class="section" id="preserving-proper-dispatch-order">
<h4>5.8.2.5 Preserving Proper Dispatch Order<a class="headerlink" href="#preserving-proper-dispatch-order" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The algorithm must preserve proper dispatch order in cases such as
the following:</p>
<p><strong>AcQpZ BcLpR CpL DcRpQ</strong></p>
<p>The issue with the above scenario is that A and B are not obviously
related until D is processed. If A and B were in one firmware volume
and C and D were in another, the ordering could not be resolved
until execution. The proper dispatch order in this case is CBDA. The
algorithm must resolve this type of case.</p>
</div></blockquote>
<p><strong>PEI Foundation Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="using-available-memory">
<h4>5.8.2.6 Using Available Memory<a class="headerlink" href="#using-available-memory" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The PEI Foundation begins operation using a temporary memory store
that contains the initial call stack from the Security (SEC) phase.
The SEC phase must pass the size and location of the stack and the
size and location of the temporary memory store.</p>
<p>The PEI stack will be available for subsequent PEIM invocations, and
the PEI heap will be used for PEIM memory allocations and Hand-Off
Block (HOB) creation.</p>
<p>There can be no memory writes to the address space beyond this
initial temporary memory until a PEIM registers a permanent memory
range using the PEI Service <strong>InstallPeiMemory()</strong>. When permanent
memory is installed, the PEI Foundation will copy the call stack
that is located in temporary memory into a segment of permanent
memory. If necessary, the size of the call stack can be expanded to
support the subsequent transition into DXE.</p>
<p>In addition to the call stack, the PEI Foundation will copy the
following from temporary to permanent memory:</p>
</div></blockquote>
<ul>
<li><p class="first">PEI Foundation private data</p>
</li>
<li><p class="first">PEI Foundation heap</p>
</li>
<li><p class="first">HOB list</p>
</li>
<li><p class="first">Installed Firmware Volumes</p>
<blockquote>
<div><p>Any permanent memory consumed in this fashion by the PEI Foundation
will be described in a HOB, which the PEI Foundation will create.</p>
<p>The PEI Foundation will copy any installed firmware volumes from the
temporary memory location to a permanent memory location with the
alignment specified in the firmware volume header. Any
<em>uncompressed</em> PE32 or TE sections within PEIMs in these firmware
volumes will be fixed up. This ensures any static
<strong>EFI_PEI_PPI_DESCRIPTOR</strong>s or PPI interface pointers in these
PEIMs point to the permanent memory addresses.</p>
<p>In addition, if there were any <strong>EFI_PEI_PPI_DESCRIPTOR</strong>s
created in the temporary memory heap or declared statically in
PEIMs, their respective locations have been translated by an offset
equal to the difference between the original location in temporary
memory and the destination location in permanent memory. In addition
to this heap copy, the PEI Foundation will traverse the PEI PPI
database. Any references to <strong>EFI_PEI_PPI_DESCRIPTOR</strong>s that
are in temporary memory will be fixed up by the PEI Foundation to
reflect the location of the <strong>EFI_PEI_PPI_DESCRIPTOR</strong>s
destination in permanent memory.</p>
<p>The PEI Foundation will invoke the DXE IPL PPI after dispatching all
candidate PEIMs. The DXE IPL PPI may have to allocate additional
regions from permanent memory to be able to load and relocate the
DXE Foundation from its firmware store. The DXE IPL PPI will
describe these memory allocations in the appropriate HOB such that
when control is passed to DXE, an accurate record of the memory
usage will be known to the DXE Foundation.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="invoking-the-peim-s-entry-point">
<h4>5.8.2.7 Invoking the PEIM’s Entry Point<a class="headerlink" href="#invoking-the-peim-s-entry-point" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The entry point of a PEIM uses the calling conventions specified in
the UEFI 2.0 specification, which detail how parameters are passed
to a function. After assessing a PEIM’s dependency expression to see
if it can be invoked, the PEI Foundation will pass control to the
PEIM’s entry point. This entry point is a value described in the
PEIM’s image header.</div></blockquote>
<p>Version 1.7</p>
<blockquote>
<div><p>The PEI Foundation will pass an indirect pointer to the PEI Services
Table and the handle of the firmware file when it invokes the PEIM.</p>
<p>In the entry point of the PEIM, the PEIM has the opportunity do the
following:</p>
</div></blockquote>
<ul class="simple">
<li>Locate other PPIs</li>
<li>Install PPIs that reference services within the body of this PEIM</li>
<li>Register for a notification</li>
<li>Upon return from the PEIM’s entry point, it returns back to the PEI
Foundation.</li>
<li>See the <em>Microsoft Portable Executable and Common Object File Format
Specification</em> for information on PE/COFF images; see <em>“TE Image” on
page 236</em> for information on TE images.</li>
</ul>
</div>
<div class="section" id="knowing-when-dispatcher-tasks-are-finished">
<h4>5.8.2.8 Knowing When Dispatcher Tasks Are Finished<a class="headerlink" href="#knowing-when-dispatcher-tasks-are-finished" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The PEI Dispatcher is finished with a pass when it has finished
dispatching all the PEIMs that it can. During a pass, some PEIMs
might not have been dispatched if they had requirements that no
other PEIM has met.</p>
<p>However, with the weak ordering defined in previous requirements,
system RAM could possibly be initialized before all PEIMs are given
a chance to run. This situation can occur because the system RAM
initialization PEIM is not required to consume all resources
provided by all other PEIMs. The PEI Dispatcher must recognize that
its tasks are not complete until all PEIMs have been given an
opportunity to run.</p>
</div></blockquote>
</div>
<div class="section" id="reporting-pei-core-location">
<h4>5.8.2.9 Reporting PEI Core Location<a class="headerlink" href="#reporting-pei-core-location" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>If the <strong>EFI_PEI_LOADED_IMAGE_PPI</strong> is supported by the PEI
Dispatcher, then the PEI Foundation must first report its own
location by using the PEI Service <strong>InstallPpi()</strong> and the</p>
<p><strong>EFI_PEI_LOADED_IMAGE_PPI</strong>. If the <em>FileHandle</em> is unknown,
then <strong>NULL</strong> can be used. PEI</p>
<p>Foundation must also report the location of the PEIM loaded by
creating the</p>
<p><strong>EFI_PEI_LOADED_IMAGE_PPI</strong> and call the PEI Service
<strong>ReinstallPpi()</strong>.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="example-dispatch-algorithm">
<h3>5.8.3 Example Dispatch Algorithm<a class="headerlink" href="#example-dispatch-algorithm" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The following pseudo code is an example of an algorithm that uses
few registers and implements the requirements listed in the previous
section. The pseudo code uses simple C-like statements but more
assembly-like flow-of-control primitives.</p>
<p>The dispatch algorithm’s main data structure is the DispatchedBitMap
as described in <em>Table 15</em>.</p>
</div></blockquote>
<p><strong>PEI Foundation Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><strong>Table 15. Example Dispatch Map</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="49%" />
<col width="17%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>PEIM#</strong></th>
<th class="head"><strong>Item</strong></th>
<th class="head"><strong>PEIM#</strong></th>
<th class="head"><strong>Item</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#160;</td>
<td>FV0</td>
<td>4</td>
<td>FV1</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>PEI Foundation</td>
<td>&#160;</td>
<td>&lt;non PEIM&gt;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&lt;non PEIM&gt;</td>
<td>&#160;</td>
<td>&lt;non PEIM&gt;</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>PEIM</td>
<td>&#160;</td>
<td>&lt;non PEIM&gt;</td>
</tr>
<tr class="row-even"><td>1</td>
<td>PEIM</td>
<td>5</td>
<td>PEIM</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>PEIM with <strong>EFI_PEI_FIRMWARE_VOLUME_PPI</strong></td>
<td>&#160;</td>
<td>&lt;non PEIM&gt;</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&lt;non PEIM&gt;</td>
<td>6</td>
<td>PEIM</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>PEIM</td>
<td>7</td>
<td>PEIM</td>
</tr>
</tbody>
</table>
<blockquote>
<div><em>Table 15</em> is an example of a dispatch in a given set of firmware
volumes (FVs). Following are the steps in this dispatch:</div></blockquote>
<ol class="arabic simple">
<li>The algorithm scans through the PEIMs that it knows about.</li>
<li><dl class="first docutils">
<dt>When it comes to a PEIM that has not been dispatched, it verifies</dt>
<dd>that all of the required PPIs listed in the dependency expression
(depex) are in the PPI database.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>If all of the GUIDed interfaces listed in the depex are available,</dt>
<dd>the PEIM is invoked.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Create the <strong>EFI_PEI_LOADED_IMAGE_PPI</strong> and call the PEI Service</dt>
<dd><strong>ReinstallPpi()</strong></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Iterations continue through all known PEIMs in all known FVs until a</dt>
<dd>pass is made with no PEIMs dispatched, thus signifying
completion.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>After the dispatch completes, the PEI Foundation locates and invokes</dt>
<dd>the GUID for the DXE IPL PPI, passing in the HOB address and a
valid stack. Failing to discover the GUID for the DXE IPL PPI
shall be an error.</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="dispatching-when-memory-exists">
<h3>5.8.4 Dispatching When Memory Exists<a class="headerlink" href="#dispatching-when-memory-exists" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The purpose of the PEI phase of execution is to discover and
initialize main memory. There are several circumstances in which the
shadowing of a PEIM and the relocation of this image into memory are
of interest. This can include but is not limited to compressing
PEIMs, such as the DXE IPL PPI, those modules that are required for
crisis recovery, and platforms in which code is executed from
temporary memory.</p>
<p>The PEI architecture shall not dictate what compression mechanism is
to be used, but there will be a Decompress service that is published
by some PEIM that the PEI Foundation will discover and use when it
becomes available. In addition, loading images also requires a full
image-relocation service and the ability to flush the cache. The
former will allow the PEIM that was relocated into RAM to have its
relocations adjust pursuant to the new load address. The latter
service will be invoked by the PEI Foundation so that this relocated
code can be run, especially on Itanium-based platforms that do not
have a coherent data and code cache.</p>
<p>A compressed section shall have an implied dependency on permanent
memory having been installed. To speed up boot time, however, there
can be an explicit annotation of this dependency.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
</div>
<div class="section" id="peim-dispatching">
<h3>5.8.5 PEIM Dispatching<a class="headerlink" href="#peim-dispatching" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>When the PEI Dispatcher has decided to invoke a PEIM, the following
steps are taken:</div></blockquote>
<ol class="arabic">
<li><p class="first">If any instances of <strong>EFI_PEI_LOAD_FILE_PPI</strong> are installed, they
are called, one at a time, until one reports <strong>EFI_SUCCESS</strong>.</p>
</li>
<li><p class="first">If no instance reports <strong>EFI_SUCCESS</strong> or there are no instances
installed, then the built-in support for (at least) the PE32+/TE XIP
image formats is used.</p>
</li>
<li><p class="first">If any instances of <strong>EFI_PEI_SECURITY2_PPI</strong> are installed, they
are called, one at a time, as long as none returns an
<strong>EFI_SECURITY_VIOLATION</strong> error. If such an error is returned,
then the PEIM is marked as dispatched, but is never invoked.</p>
</li>
<li><p class="first">The PEIM’s entry point is invoked with the file’s handle and the PEI
Services Table pointer.</p>
</li>
<li><p class="first">The PEIM is marked as dispatched.</p>
<blockquote>
<div><p>The PEI Core may decide, because of memory constraints or
performance reasons, to dispatch XIP instead of shadowing into
memory.</p>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="peim-authentication">
<h3>5.8.6 PEIM Authentication<a class="headerlink" href="#peim-authentication" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The PEI specification provides three methods which the PEI
Foundation can use to authenticate a PEIM:</div></blockquote>
<ol class="arabic">
<li><dl class="first docutils">
<dt>The authentication information could be encoded as part of a GUIDed</dt>
<dd><blockquote class="first">
<div><p>section. In this case, the provider of the
<strong>EFI_PEI_GUIDED_SECTION_EXTRACTION_PPI</strong> (see the <a href="#id136"><span class="problematic" id="id137">*</span></a>Platform
*</p>
</div></blockquote>
<p class="last"><em>Initialization Specification</em>, Volume 3) can check the
authentication data and return the results in <em>AttestationState</em>.</p>
</dd>
</dl>
</li>
</ol>
<ol class="arabic">
<li><p class="first">The authentication information can be checked by the provider of the</p>
<blockquote>
<div><p><strong>EFI_PEI_LOAD_FILE_PPI</strong> (see the <em>Platform Initialization
Specification</em>, Volume 3) and the results returned in
<em>AttestationState</em>.</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><dl class="first docutils">
<dt>The PEI Foundation may implement the digital signing as described in</dt>
<dd><blockquote class="first">
<div><p>the UEFI 2.0 specification.</p>
</div></blockquote>
<p>In all cases, the result of the authentication must be passed to any
instances of the</p>
<p class="last"><strong>EFI_PEI_SECURITY2_PPI</strong>.</p>
</dd>
</dl>
</li>
</ol>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
</div>
<div class="section" id="architectural-ppis">
<h1>6 Architectural PPIs<a class="headerlink" href="#architectural-ppis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id138">
<h2>6.1 Introduction<a class="headerlink" href="#id138" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The PEI Foundation and PEI Dispatcher rely on the following
PEIM-to-PEIM Interfaces (PPIs) to perform its work. The abstraction
provided by these interfaces allows dispatcher algorithms to be
improved over time or have some platform variability without
affecting the rest of PEI.</p>
<p>The key to these PPIs is that they are architecturally defined
interfaces consumed by the PEI Foundation, but they may not be
published by the PEI Foundation.</p>
</div></blockquote>
</div>
<div class="section" id="required-architectural-ppis">
<h2>6.2 Required Architectural PPIs<a class="headerlink" href="#required-architectural-ppis" title="Permalink to this headline">¶</a></h2>
<p><strong>6.2.1 Master Boot Mode PPI (Required)</strong></p>
<div class="section" id="efi-pei-master-boot-mode-ppi-required">
<h3>EFI_PEI_MASTER_BOOT_MODE_PPI (Required)<a class="headerlink" href="#efi-pei-master-boot-mode-ppi-required" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p><strong>Summary</strong></p>
<p>The Master Boot Mode PPI is installed by a PEIM to signal that a
final boot has been determined and set. This signal is useful in
that PEIMs with boot-mode-specific behavior (for example, S3 versus
normal) can put this PPI in their dependency expression.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_MASTER_BOOT_MODE_PEIM_PPI \</strong></p>
</div></blockquote>
<p>{0x7408d748, 0xfc8c, 0x4ee6, 0x92, 0x88, 0xc4, 0xbe, \</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><strong>0xc0, 0x92, 0xa4, 0x10}</strong></p>
<p><strong>PPI Interface Structure</strong></p>
<p>None.</p>
<p><strong>Description</strong></p>
<p>The Master Boot Mode PPI is a PPI GUID and must be in the dependency
expression of every PEIM that modifies the basic hardware. The
dispatch, or entry point, of the module that installs the Master
Boot Mode PPI modifies the boot path value in the following ways:</p>
</div></blockquote>
<ul>
<li><p class="first">Directly, through the PEI Service <strong>SetBootMode()</strong></p>
</li>
<li><p class="first">Indirectly through its optional subordinate boot path modules</p>
<blockquote>
<div><p>The PEIM that publishes the Master Boot Mode PPI has a non-null
dependency expression if there are subsidiary modules that publish
alternate boot path PPIs. The primary reason for this PPI is to be
the root of dependencies for any child boot mode provider PPIs.</p>
<p><strong>Status Codes Returned</strong></p>
<p>None.</p>
</div></blockquote>
</li>
</ul>
<p>80</p>
<p><strong>Architectural PPIs</strong></p>
<p><strong>6.2.2 DXE IPL PPI (Required)</strong></p>
</div>
<div class="section" id="efi-dxe-ipl-ppi-required">
<h3>EFI_DXE_IPL_PPI (Required)<a class="headerlink" href="#efi-dxe-ipl-ppi-required" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Final service to be invoked by the PEI Foundation.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_DXE_IPL_PPI_GUID \</strong></p>
<p><strong>{ 0xae8ce5d, 0xe448, 0x4437, 0xa8, 0xd7, 0xeb, 0xf5, \</strong></p>
<p><strong>0xf1, 0x94, 0xf7, 0x31 }</strong></p>
<p><strong>PPI Interface Structure typedef struct _EFI_DXE_IPL_PPI {</strong></p>
<p><strong>EFI_DXE_IPL_ENTRY</strong> <em>Entry;</em></p>
<p><strong>} EFI_DXE_IPL_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Entry</em></p>
<p>The entry point to the DXE IPL PPI. See the <strong>Entry()</strong> function
description.</p>
<p><strong>Description</strong></p>
<p>After completing the dispatch of all available PEIMs, the PEI
Foundation will invoke this PPI through its entry point using the
same handoff state used to invoke other PEIMs. This special
treatment by the PEI Foundation effectively makes the DXE IPL PPI
the last PPI to execute during PEI. When this PPI is invoked, the
system state should be as follows:</p>
</div></blockquote>
<ul>
<li><p class="first">Single thread of execution</p>
</li>
<li><p class="first">Interrupts disabled</p>
</li>
<li><p class="first">Processor mode as defined for PEI</p>
<blockquote>
<div><p>The DXE IPL PPI is responsible for locating and loading the DXE
Foundation. The DXE IPL PPI may use PEI services to locate and load
the DXE Foundation. As long as the DXE IPL PPI is using PEI
Services, it must obey all PEI interoperability rules of memory
allocation, HOB list usage, and PEIM-to-PEIM communication
mechanisms.</p>
<p>For S3 resume boot modes DXE IPL must be prepared to execute without
permanent memory installed and invoke the S3 resume modules.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="efi-dxe-ipl-ppi-entry">
<h3>EFI_DXE_IPL_PPI.Entry()<a class="headerlink" href="#efi-dxe-ipl-ppi-entry" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The architectural PPI that the PEI Foundation invokes when there are
no additional PEIMs to invoke.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_DXE_IPL_ENTRY) (</strong></p>
<p><strong>IN CONST EFI_DXE_IPL_PPI</strong> <em>*This,</em></p>
<p><strong>IN EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_PEI_HOB_POINTERS</strong> <em>HobList</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong> <em>This</em></p>
<p>Pointer to the DXE IPL PPI instance.</p>
<p><em>PeiServices</em></p>
<p>Pointer to the PEI Services Table.</p>
<p><em>HobList</em></p>
<p>Pointer to the list of Hand-Off Block (HOB) entries.</p>
<p><strong>Related Definitions</strong></p>
<p></p>
<p><strong>//</strong></p>
<p><strong>// Union of all the possible HOB Types</strong></p>
<p><strong>//</strong></p>
<p><strong>typedef union {</strong></p>
<p><strong>EFI_HOB_GENERIC_HEADER *</strong><em>Header;</em></p>
<p><strong>EFI_HOB_HANDOFF_INFO_TABLE</strong> <em>*HandoffInformationTable;</em></p>
<p><strong>EFI_HOB_MEMORY_ALLOCATION</strong> <em>*MemoryAllocation;</em></p>
<p><strong>EFI_HOB_MEMORY_ALLOCATION_BSP_STORE</strong>
<em>*MemoryAllocationBspStore;</em></p>
<p><strong>EFI_HOB_MEMORY_ALLOCATION_STACK</strong> <em>*MemoryAllocationStack;</em></p>
<p><strong>EFI_HOB_MEMORY_ALLOCATION_MODULE</strong> <em>*MemoryAllocationModule;</em></p>
<p><strong>EFI_HOB_RESOURCE_DESCRIPTOR</strong> <em>*ResourceDescriptor;</em></p>
<p><strong>EFI_HOB_GUID_TYPE</strong> <em>*Guid;</em></p>
<p><strong>EFI_HOB_FIRMWARE_VOLUME</strong> <em>*FirmwareVolume;</em></p>
<p><strong>EFI_HOB_CPU</strong> <em>*Cpu;</em></p>
<p><strong>EFI_HOB_MEMORY_POOL</strong> <em>*Pool</em><strong>;</strong></p>
<p><strong>UINT8</strong> <em>*Raw;</em> <strong>} EFI_PEI_HOB_POINTERS;</strong></p>
<p></p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Architectural PPIs</strong></p>
<blockquote>
<div><p><strong>Description</strong></p>
<p>This function is invoked by the PEI Foundation. The PEI Foundation
will invoke this service when there are no additional PEIMs to
invoke in the system. If this PPI does not exist, it is an error
condition and an ill-formed firmware set. The DXE IPL PPI should
never return after having been invoked by the PEI Foundation. The
DXE IPL PPI can do many things internally, including the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Invoke the DXE entry point from a firmware volume.</p>
</li>
<li><p class="first">Invoke the recovery processing modules.</p>
</li>
<li><p class="first">Invoke the S3 resume modules.</p>
<blockquote>
<div><p><strong>Status Codes Returned</strong></p>
</div></blockquote>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EFI_SUCCESS</td>
<td>Upon this return code, the PEI Foundation should enter some exception handling. Under normal circumstances, the DXE IPL PPI should not return.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
<p><strong>6.2.3 Memory Discovered PPI (Required)</strong></p>
</div>
<div class="section" id="efi-pei-permanent-memory-installed-ppi-required">
<h3>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI (Required)<a class="headerlink" href="#efi-pei-permanent-memory-installed-ppi-required" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is published by the PEI Foundation when the main memory is
installed. It is essentially a PPI with no associated interface. Its
purpose is to be used as a signal for other PEIMs who can register
for a notification on its installation.</p>
<p><strong>GUID</strong></p>
<p><a href="#id139"><span class="problematic" id="id140">**</span></a>#define EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI_GUID \ **</p>
</div></blockquote>
<p>{0xf894643d, 0xc449, 0x42d1, 0x8e, 0xa8, 0x85, 0xbd, \</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><strong>0xd8, 0xc6, 0x5b, 0xde}</strong></p>
<p><strong>PPI Interface Structure</strong></p>
<p>None.</p>
<p><strong>Description</strong></p>
<p>This PPI is installed by the PEI Foundation at the point of system
evolution when the permanent memory size has been registered and
waiting PEIMs can use the main memory store. Using this GUID allows
PEIMs to do the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Be notified when this PPI is installed.</p>
</li>
<li><p class="first">Include this PPI’s GUID in the <strong>EFI_DEPEX</strong>.</p>
<blockquote>
<div><p>The expectation is that a compressed PEIM would depend on this PPI,
for example. The PEI Foundation will relocate the temporary cache to
permanent memory prior to this installation.</p>
<p><strong>Status Codes Returned</strong></p>
<p>None.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="optional-architectural-ppis">
<h2>6.3 Optional Architectural PPIs<a class="headerlink" href="#optional-architectural-ppis" title="Permalink to this headline">¶</a></h2>
<p><strong>6.3.1 Boot in Recovery Mode PPI (Optional)</strong></p>
<div class="section" id="efi-pei-boot-in-recovery-mode-ppi-optional">
<h3>EFI_PEI_BOOT_IN_RECOVERY_MODE_PPI (Optional)<a class="headerlink" href="#efi-pei-boot-in-recovery-mode-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is installed by the platform PEIM to designate that a
recovery boot is in progress.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_BOOT_IN_RECOVERY_MODE_PEIM_PPI \</strong></p>
</div></blockquote>
<p>{0x17ee496a, 0xd8e4, 0x4b9a, 0x94, 0xd1, 0xce, 0x82, \</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><strong>0x72, 0x30, 0x8, 0x50}</strong></p>
<p><strong>PPI Interface Structure</strong></p>
<p>None.</p>
<p><strong>Description</strong></p>
<p>This optional PPI is installed by the platform PEIM to designate
that a recovery boot is in progress. Its purpose is to allow certain
PEIMs that wish to be dispatched <strong>only during a recovery boot</strong> to
include this PPI in their dependency expression (depex). Including
this PPI in the depex allows the PEI Dispatcher to skip
recovery-specific PEIMs during normal restarts and thus save on boot
time. This PEIM has no associated PPI and is used only to designate
the system state as being “in a crisis recovery dispatch.”</p>
<p><strong>Status Codes Returned</strong></p>
<p>None.</p>
</div></blockquote>
<p><strong>6.3.2 End of PEI Phase PPI (Optional)</strong></p>
</div>
<div class="section" id="efi-pei-end-of-pei-phase-ppi-optional">
<h3>EFI_PEI_END_OF_PEI_PHASE_PPI (Optional)<a class="headerlink" href="#efi-pei-end-of-pei-phase-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI will be installed at the end of PEI for all boot paths,
including normal, recovery, and S3. It allows for PEIMs to possibly
quiesce hardware, build handoff information for the next phase of
execution, or provide some terminal processing behavior.</p>
<p><strong>GUID</strong></p>
<p><a href="#id141"><span class="problematic" id="id142">**</span></a>#define EFI_PEI_END_OF_PEI_PHASE_PPI_GUID \ **</p>
</div></blockquote>
<p>{0x605EA650, 0xC65C, 0x42e1, 0xBA, 0x80, 0x91, 0xA5, \</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><strong>0x2A, 0xB6,0x18, 0xC6}</strong></p>
<p><strong>PPI Interface Structure</strong></p>
<p>None.</p>
<p><strong>Description</strong></p>
<p>This PPI is installed by the DXE IPL PPI to indicate the end of the
PEI usage of memory and ownership of memory allocation by the DXE
phase.</p>
<p>For the <strong>BOOT_ON_S3_RESUME</strong> boot mode, this PPI is installed by
the</p>
<p><strong>EFI_PEI_S3_RESUME_PPI.S3RestoreConfig()</strong> (Section 8.6 of the
PI1.2 Specification, Volume 5) just before jump to OS waking vector.</p>
<p>The intended use model is for any agent that needs to do cleanup,
such as memory services to convert internal metadata for tracking
memory allocation into HOBs, to have some distinguished point in
which to do so. The PEI Memory Services would register for a
callback on the installation of this PPI.</p>
<p><strong>Status Codes Returned</strong></p>
<p>None.</p>
</div></blockquote>
<p><strong>6.3.3 PEI Reset PPI</strong></p>
</div>
<div class="section" id="efi-pei-reset-ppi-optional">
<h3>EFI_PEI_RESET_PPI (Optional)<a class="headerlink" href="#efi-pei-reset-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is installed by some platform- or chipset-specific PEIM
that abstracts the Reset Service to other agents.</p>
<p><strong>GUID</strong></p>
<p><a href="#id143"><span class="problematic" id="id144">**</span></a>#define EFI_PEI_RESET_PPI_GUID \ **</p>
</div></blockquote>
<p>{0xef398d58, 0x9dfd, 0x4103, 0xbf, 0x94, 0x78, 0xc6, \</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><strong>0xf4, 0xfe, 0x71, 0x2f}</strong></p>
<p><strong>PPI Interface Structure typedef struct _EFI_PEI_RESET_PPI {
EFI_PEI_RESET_SYSTEM</strong> <em>ResetSystem;</em></p>
<p><strong>} EFI_PEI_RESET_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>ResetSystem</em></p>
<p>A service to reset the platform. See the <strong>ResetSystem()</strong> function
description in <em>“Reset Services” on page 50</em>.</p>
<p><strong>Description</strong></p>
<p>These services provide a simple reset service. See the
<strong>ResetSystem()</strong> function description for a description of this
service.</p>
</div></blockquote>
<p><strong>6.3.4 PEI Reset2 PPI</strong></p>
</div>
<div class="section" id="efi-pei-reset2-ppi-optional">
<h3>EFI_PEI_RESET2_PPI (Optional)<a class="headerlink" href="#efi-pei-reset2-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is installed by some platform- or chipset-specific PEIM
that abstracts the ability to reset the platform.</p>
</div></blockquote>
<p><strong>GUID</strong></p>
<blockquote>
<div><p><strong>#define EFI_PEI_RESET2_PPI_GUID \</strong></p>
<p><strong>{0x6cc45765, 0xcce4, 0x42fd, \</strong></p>
<p><strong>{0xbc, 0x56, 0x1, 0x1a,0xaa, 0xc6, 0xc9, 0xa8}}</strong></p>
</div></blockquote>
<p><strong>PPI Interface Structure typedef struct _EFI_PEI_RESET2_PPI {</strong></p>
<blockquote>
<div><p><strong>EFI_PEI_RESET2_SYSTEM</strong> <em>ResetSystem</em><strong>;</strong></p>
<p><strong>} EFI_PEI_RESET_PPI;</strong></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><em>ResetSystem</em></p>
<p>A service to reset the platform.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div>These services provide a simple reset service. This is equivalent to
the <strong>ResetSystem()</strong> API call in the UEFI2.4 specification.</div></blockquote>
</div>
<div class="section" id="resetsystem">
<h3>ResetSystem()<a class="headerlink" href="#resetsystem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><a href="#id145"><span class="problematic" id="id146">**</span></a>Summary **</p>
<p>Resets the entire platform.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_RESET2_SYSTEM) (</strong></p>
<p><strong>IN EFI_RESET_TYPE</strong> <em>ResetType*</em>, <a href="#id147"><span class="problematic" id="id148">**</span></a><a href="#id149"><span class="problematic" id="id150">*</span></a></p>
<p><strong>IN EFI_STATUS</strong> <em>ResetStatus*</em>, <a href="#id151"><span class="problematic" id="id152">**</span></a><a href="#id153"><span class="problematic" id="id154">*</span></a></p>
<p><strong>IN UINTN</strong> <em>DataSize*</em>, <a href="#id155"><span class="problematic" id="id156">**</span></a><a href="#id157"><span class="problematic" id="id158">*</span></a></p>
<p><strong>IN VOID ***</strong><em>ResetData</em> <a href="#id159"><span class="problematic" id="id160">**</span></a>OPTIONAL **</p>
<p><a href="#id161"><span class="problematic" id="id162">**</span></a>); **</p>
<p><a href="#id163"><span class="problematic" id="id164">**</span></a>Parameters. **</p>
<p><em>ResetType</em></p>
<p>The type of reset to perform. Type <strong>EFI_RESET_TYPE</strong> is defined
in “Related Definitions” below.</p>
<p><em>ResetStatus</em></p>
<p>The status code for the reset. If the system reset is part of a
normal operation, the status code would be <strong>EFI_SUCCESS</strong>. If the
system reset is due to some type of failure the most appropriate EFI
Status code would be used.</p>
<p><em>DataSize</em></p>
<p>The size, in bytes, of <em>ResetData</em>.</p>
<p><em>ResetData</em></p>
<p>For a <em>ResetType</em> of <strong>EfiResetCold</strong>, <strong>EfiResetWarm</strong>, or</p>
<p><strong>EfiResetShutdown</strong> the data buffer starts with a Null-terminated
string, optionally followed by additional binary data. The string is
a description that the caller</p>
<p>may use to further indicate the reason for the system reset.
<em>ResetData</em> is only valid if <em>ResetStatus</em> is something other than
<strong>EFI_SUCCESS</strong> unless the <em>ResetType</em> is
<em>EfiResetPlatformSpecific</em> where a minimum amount of <em>ResetData</em> is
always required.</p>
</div></blockquote>
<p><strong>Related Definitions</strong></p>
<blockquote>
<div><p><a href="#id165"><span class="problematic" id="id166">**</span></a>//*******************************************************
**</p>
<p><strong>// EFI_RESET_TYPE //</strong></p>
<p><a href="#id167"><span class="problematic" id="id168">**</span></a>*******************************************************
**</p>
<p><a href="#id169"><span class="problematic" id="id170">**</span></a>typedef enum { EfiResetCold, **</p>
<p><a href="#id171"><span class="problematic" id="id172">**</span></a>EfiResetWarm, **</p>
<p><a href="#id173"><span class="problematic" id="id174">**</span></a>EfiResetShutdown, **</p>
<p><a href="#id175"><span class="problematic" id="id176">**</span></a>EfiResetPlatformSpecific **</p>
<p><a href="#id177"><span class="problematic" id="id178">**</span></a>} EFI_RESET_TYPE; **</p>
</div></blockquote>
<p><a href="#id179"><span class="problematic" id="id180">**</span></a>Description **</p>
<blockquote>
<div><p>The <strong>ResetSystem()</strong> function resets the entire platform, including
all processors and devices, and reboots the system.</p>
<p>Calling this interface with <em>ResetType</em> of <strong>EfiResetCold</strong> causes a
system-wide reset. This sets all circuitry within the system to its
initial state. This type of reset is asynchronous to system
operation and operates without regard to cycle boundaries.
<strong>EfiResetCold</strong> is tantamount to a system power cycle.</p>
<p>Calling this interface with <em>ResetType</em> of <strong>EfiResetWarm</strong> causes a
system-wide initialization.</p>
<p>The processors are set to their initial state, and pending cycles
are not corrupted. If the system does not support this reset type,
then an <strong>EfiResetCold</strong> must be performed.</p>
<p>Calling this interface with <em>ResetType</em> of <strong>EfiResetShutdown</strong>
causes the system to enter a power state equivalent to the ACPI
G2/S5 or G3 states. If the system does not support this reset type,
then when the system is rebooted, it should exhibit the
<strong>EfiResetCold</strong> attributes.</p>
<p>Calling this interface with <em>ResetType</em> of EfiResetPlatformSpecific
causes a system-wide reset. The exact type of the reset is defined
by the <strong>EFI_GUID</strong> that follows the Null-terminated Unicode string
passed into <em>ResetData</em>. If the platform does not recognize the
<strong>EFI_GUID</strong> in <em>ResetData</em> the platform must pick a supported
reset type to perform.The platform may optionally log the parameters
from any non-normal reset that occurs.</p>
<p>The <strong>ResetSystem()</strong> function does not return.</p>
</div></blockquote>
<p><strong>6.3.5 Status Code PPI (Optional)</strong></p>
</div>
<div class="section" id="efi-pei-progress-code-ppi-optional">
<h3>EFI_PEI_PROGRESS_CODE_PPI (Optional)<a class="headerlink" href="#efi-pei-progress-code-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service is published by a PEIM. There can be only one instance
of this service in the system. If there are multiple variable access
services, this PEIM must multiplex these alternate accessors and
provide this single, read-only service to the other PEIMs and the
PEI Foundation. This singleton nature is important because the PEI
Foundation will notify when this service is installed.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_REPORT_PROGRESS_CODE_PPI_GUID \</strong></p>
<p><strong>{0x229832d3, 0x7a30, 0x4b36, 0xb8, 0x27, 0xf4, 0xc, \</strong></p>
<p><strong>0xb7, 0xd4, 0x54, 0x36);</strong></p>
<p><strong>PPI Interface Structure typedef struct
_EFI_PEI_PROGRESS_CODE_PPI { EFI_PEI_REPORT_STATUS_CODE</strong>
<em>ReportStatusCode;</em></p>
<p><strong>} EFI_PEI_PROGRESS_CODE_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>ReportStatusCode</em></p>
<p>Service that allows PEIMs to report status codes. See the
<strong>ReportStatusCode()</strong> function description in <em>“Status Code
Service” on page 47</em>.</p>
<p><strong>Description</strong></p>
<p>See the <strong>ReportStatusCode()</strong> function description for a
description of this service.</p>
</div></blockquote>
<p><strong>6.3.6 Security PPI (Optional)</strong></p>
</div>
<div class="section" id="efi-pei-security2-ppi-optional">
<h3>EFI_PEI_SECURITY2_PPI (Optional)<a class="headerlink" href="#efi-pei-security2-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is installed by some platform PEIM that abstracts the
security policy to the PEI Foundation, namely the case of a PEIM’s
authentication state being returned during the PEI section
extraction process.</p>
<p><strong>GUID</strong></p>
<p><a href="#id181"><span class="problematic" id="id182">**</span></a>#define EFI_PEI_SECURITY2_PPI_GUID \ **</p>
<p><strong>{ 0xdcd0be23, 0x9586, 0x40f4, 0xb6, 0x43, 0x6, 0x52, \</strong></p>
<p><a href="#id183"><span class="problematic" id="id184">**</span></a>0x2c, 0xed, 0x4e, 0xde } **</p>
<p><strong>PPI Interface Structure typedef struct _EFI_PEI_SECURITY2_PPI
{</strong></p>
<p><strong>EFI_PEI_SECURITY_AUTHENTICATION_STATE</strong> <em>AuthenticationState;</em></p>
<p><strong>} EFI_PEI_SECURITY2_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>AuthenticationState</em></p>
<p>Allows the platform builder to implement a security policy in
response to varying file authentication states. See the
<strong>AuthenticationState()</strong> function description.</p>
<p><strong>Description</strong></p>
<p>This PPI is a means by which the platform builder can indicate a
response to a PEIM’s authentication state. This can be in the form
of a requirement for the PEI Foundation to skip a module using the
<em>DeferExecution</em> Boolean output in the <strong>AuthenticationState()</strong>
member function.</p>
<p>Alternately, the Security PPI can invoke something like a
cryptographic PPI that hashes the PEIM contents to log attestations,
for which the <em>FileHandle</em> parameter in</p>
<p><strong>AuthenticationState()</strong> will be useful. If this PPI does not
exist, PEIMs will be considered trusted.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-security2-ppi-authenticationstate">
<h3>EFI_PEI_SECURITY2_PPI.AuthenticationState()<a class="headerlink" href="#efi-pei-security2-ppi-authenticationstate" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Allows the platform builder to implement a security policy in
response to varying file authentication states.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_SECURITY_AUTHENTICATION_STATE) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_SECURITY2_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT32</strong> <em>AuthenticationStatus,</em></p>
<p><strong>IN EFI_PEI_FV_HANDLE</strong> <em>FvHandle,</em></p>
<p><strong>IN EFI_PEI_FILE_HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN OUT BOOLEAN</strong> <em>*DeferExecution</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Interface pointer that implements the particular
<strong>EFI_PEI_SECURITY2_PPI</strong> instance.</p>
<p><em>AuthenticationStatus</em></p>
<p>Authentication status of the file.</p>
<p><em>FvHandle</em></p>
<p>Handle of the volume in which the file resides. Type
<strong>EFI_PEI_FV_HANDLE</strong> is defined in <strong>FfsFindNextVolume</strong>. This
allows different policies depending on different firmware volumes.</p>
<p><em>FileHandle</em></p>
<p>Handle of the file under review. Type <strong>EFI_PEI FILE HANDLE</strong> is
defined in <strong>FfsFindNextFile</strong><em>.</em></p>
<p><em>DeferExecution</em></p>
<p>Pointer to a variable that alerts the PEI Foundation to defer
execution of a PEIM.</p>
<p><strong>Description</strong></p>
<p>This service is published by some platform PEIM. The purpose of this
service is to expose a given platform’s policy-based response to the
PEI Foundation. For example, if there is a PEIM in a GUIDed
encapsulation section and the extraction of the PEI file section
yields an authentication failure, there is no <em>a priori</em> policy in
the PEI Foundation. Specifically, this situation leads to the</p>
</div></blockquote>
<p><strong>Architectural PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p>question whether PEIMs that are either not in GUIDed sections or are
in sections whose authentication fails should still be executed.</p>
<p>In fact, it is the responsibility of the platform builder to make
this decision. This platform-scoped policy is a result that a
desktop system might not be able to skip or not execute PEIMs
because the skipped PEIM could be the agent that initializes main
memory. Alternately, a system may require that unsigned PEIMs not be
executed under any circumstances. In either case, the PEI Foundation
simply multiplexes access to the Section Extraction PPI and the
Security PPI. The Section Extraction PPI determines the contents of
a section, and the Security PPI tells the PEI Foundation whether or
not to invoke the PEIM.</p>
<p>The PEIM that publishes the <strong>AuthenticationState()</strong> service uses
its parameters in the following ways:</p>
</div></blockquote>
<ul>
<li><p class="first"><em>AuthenticationStatus</em> conveys the source information upon which the
PEIM acts.</p>
</li>
<li><p class="first">The <em>DeferExecution</em> value tells the PEI Foundation whether or not to
dispatch the PEIM.</p>
<blockquote>
<div><p>In addition, between receiving the <strong>AuthenticationState()</strong> from
the PEI Foundation and returning with the <em>DeferExecution</em> value,
the PEIM that publishes <strong>AuthenticationState()</strong> can do the
following:</p>
</div></blockquote>
</li>
<li><p class="first">Log the file state.</p>
</li>
<li><p class="first">Lock the firmware hubs in response to an unsigned PEIM being
discovered.</p>
<blockquote>
<div><p>These latter behaviors are platform- and market-specific and thus
outside the scope of the PEI CIS.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The service performed its action successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_SECURITY_VIOLATION</td>
<td>The object cannot be trusted</td>
</tr>
</tbody>
</table>
<p><strong>6.3.7 Temporary RAM Support PPI (Optional)</strong></p>
</div>
<div class="section" id="efi-pei-temporary-ram-support-ppi-optional">
<h3>EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI (Optional)<a class="headerlink" href="#efi-pei-temporary-ram-support-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service allows for migrating from some contents of Temporary
RAM store, which is instantiated during the SEC phase, into
permanent RAM. The latter store will persist unmodified into the
subsequent phase of execution, such as DXE. This service may be
published by the SEC as part of the SEC-to-PEI handoff or published
by any other PEIM.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<p><strong>GUID</strong></p>
<blockquote>
<div><p><a href="#id185"><span class="problematic" id="id186">**</span></a>#define EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI_GUID \ **</p>
<p><strong>{0xdbe23aa9, 0xa345, 0x4b97,\</strong></p>
<p><strong>0x85, 0xb6, 0xb2, 0x26, 0xf1, 0x61, 0x73, 0x89}</strong></p>
</div></blockquote>
<p><strong>Prototype typedef struct _EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI {
TEMPORARY_RAM_MIGRATION</strong> <em>TemporaryRamMigration;</em></p>
<blockquote>
<div><strong>} EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI;</strong></div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><em>TemporaryRamMigration</em></p>
<p>Perform the migration of contents of Temporary RAM to Permanent RAM.
This service may terminate the Temporary RAM, for example, if it
cannot coexist with the Permanent RAM. See the
<strong>TemporaryRamMigration()</strong> function description.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This service abstracts the ability to migrate contents of the
platform early memory store. This is an optional PPI that is only
required for platforms that may have side effects when both
Temporary RAM and Permanent RAM are enabled. This PPI provides a
service that orchestrates the complete transition from Temporary RAM
to Permanent RAM that avoids side effects. This includes the
migration of all data, a stack switch action, and possibly the
disabling of Temporary RAM.</p>
<p>If a platform does not have any side effects when both Temporary RAM
and Permanent RAM are enabled, and the platform is required to
disable the use of Temporary RAM, then
<strong>EFI_PEI_TEMPORARY_RAM_DONE</strong> should be produced.</p>
<p>If a platform does not have any side effects when both Temporary RAM
and Permanent RAM are enabled, and the platform is not required to
disable the use of Temporary RAM, then neither</p>
<p><strong>EFI_PEI_TEMPORARY_RAM_DONE</strong> nor
<strong>EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI</strong> should be produced.</p>
<p>July 2018</p>
</div></blockquote>
<p><strong>Architectural PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-pei-temporary-ram-support-ppi-temporaryrammigration">
<h3>EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI.TemporaryRamMigration ()<a class="headerlink" href="#efi-pei-temporary-ram-support-ppi-temporaryrammigration" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service of the <strong>EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI</strong> that
migrates temporary RAM into permanent memory.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI * TEMPORARY_RAM_MIGRATION) (</strong> </p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_PHYSICAL_ADDRESS</strong> <em>TemporaryMemoryBase,</em></p>
<p><strong>IN EFI_PHYSICAL_ADDRESS</strong> <em>PermanentMemoryBase,</em></p>
<p><strong>IN UINTN</strong> <em>CopySize</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>Pointer to the PEI Services Table.</p>
<p><em>TemporaryMemoryBase</em></p>
<p>Source Address in temporary memory from which the SEC or PEIM will
copy the Temporary RAM contents.</p>
<p><em>PermanentMemoryBase</em></p>
<p>Destination Address in permanent memory into which the SEC or PEIM
will copy the Temporary RAM contents.</p>
<p><em>CopySize</em></p>
<p>Amount of memory to migrate from temporary to permanent memory.</p>
<p><strong>Description</strong></p>
<p>This service is published by the SEC module or a PEIM. It migrates
the Temporary RAM contents into Permanent RAMRAM and performs all
actions required to switch the active stack from</p>
<p>Temporary RAM to Permanent RAM. The address range from
<em>PermanentMemoryBase</em> to</p>
<p><em>PermanentMemoryBase</em> + <em>CopySize</em> should fix within the range of
memory provided to the PEI Foundation as part of the
<strong>InstallPeiMemory()</strong>core services. Also, since the SEC may have
sequestered some of the Temporary RAM for its own data storage and
PPI’s, the SEC handoff now includes addresses and sizes of both the
“available” (<em>PeiTemporaryRamBase</em>/ <em>PeiTemporaryRamSize</em>) and
“total” (<em>TemporaryRamBase</em>/<em>TemporaryRamSize</em>) Temporary RAM as
separate numbers.</p>
<p><em>PeiTemporaryRamBase</em> is used by the PEI foundation for its resource
management;</p>
<p><em>TemporaryRamBase</em> is used by the foundation as an input to this</p>
<p><strong>TemporaryRamMigration()</strong> service call. As such, the PEI
foundation is the only agent who knows the full extent of the
Temporary RAM store that needs migration to Permanent RAM. It will</p>
</div></blockquote>
<p>Version 1.7</p>
<p><strong>Architectural PPIs</strong></p>
<blockquote>
<div><p>use this full extent as the <em>CopySize</em> argument in this PPI
invocation. At minimum, the <em>CopySize</em> must include the portion of
the Temporary RAM used by the SEC.</p>
<p>The PEI Foundation implementation will invoke this PPI service
<strong>TemporaryRamMigration()</strong>, if present, after
<strong>InstallPeiMemory()</strong> is invoked.</p>
<p><strong>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI</strong> is installed after
the PPI service</p>
<p><strong>TemporaryRamMigration()</strong>is invoked, providing a signal to PEIMs
that permanent memory is available.</p>
<p>If the <strong>EFI_PEI_TEMPORARY_RAM_SUPPORT_PPI</strong> service is not
available, a PEI foundation implementation shall copy the contents
of the Temporary RAM to Permanent RAM directly and perform the stack
switch action. The lack of this PPI is not an error condition.</p>
<p>The stack switch action, namely the beginning of usage of the
permanent RAM as stack in lieu of the temporary RAM stack, is an
integral capability of any PEI foundation implementation and need
not have an API in this PPI or any other to externally-installed
abstraction.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The data was successfully returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><p class="first">PermanentMemoryBase + CopySize &gt;</p>
<p class="last">TemporaryMemoryBase when TemporaryMemoryBase &gt; PermanentMemoryBase.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>6.3.8 Temporary RAM Done PPI (Optional)</strong></p>
</div>
<div class="section" id="efi-pei-temporary-ram-done-ppi-optional">
<h3>EFI_PEI_TEMPORARY_RAM_DONE_PPI (Optional)<a class="headerlink" href="#efi-pei-temporary-ram-done-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The PPI that provides a service to disable the use of Temporary RAM.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_TEMPORARY_RAM_DONE_PPI_GUID \</strong></p>
<p><strong>{ 0xceab683c, 0xec56, 0x4a2d, \</strong></p>
<p><strong>{ 0xa9, 0x6, 0x40, 0x53, 0xfa, 0x4e, 0x9c, 0x16 } }</strong></p>
<p><strong>Protocol Interface Structure typedef struct
_EFI_PEI_TEMPORARY_RAM_DONE_PPI {</strong></p>
<p><strong>EFI_PEI_TEMPORARY_RAM_DONE</strong> <em>TemporaryRamDone</em><strong>;</strong></p>
<p><strong>} EFI_PEI_TEMPORARY_RAM_DONE_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>TemporaryRamDone</em></p>
<p>Disable the use of Temporary RAM.</p>
</div></blockquote>
<p><strong>Architectural PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>Description</strong></p>
<p>This is an optional PPI that may be produced by SEC or a PEIM. If
present, it provide a service to disable the use of Temporary RAM.
This service may only be called by the PEI Foundation after the
transition from Temporary RAM to Permanent RAM is complete. This PPI
provides an alternative to the Temporary RAM Migration PPI for
system architectures that allow Temporary RAM and Permanent RAM to
be enabled and accessed at the same time with no side effects.</p>
</div></blockquote>
<p>Version 1.7</p>
<p><strong>Architectural PPIs</strong></p>
</div>
<div class="section" id="efi-pei-temporary-ram-done-ppi-temporaryramdone">
<h3>EFI_PEI_TEMPORARY_RAM_DONE_PPI.TemporaryRamDone ()<a class="headerlink" href="#efi-pei-temporary-ram-done-ppi-temporaryramdone" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Disable the use of Temporary RAM.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI * EFI_PEI_TEMPORARY_RAM_DONE) (</strong></p>
<p><strong>VOID</strong></p>
<p><strong>);</strong></p>
<p><strong>Description</strong></p>
<p><strong>TemporaryRamDone()</strong> disables the use of Temporary RAM. If
present, this service is invoked by the PEI Foundation after the
<strong>EFI_PEI_PERMANANT_MEMORY_INSTALLED_PPI</strong> is installed.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">Use of Temporary RAM was disabled.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>Temporary RAM could not be disabled.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="peims">
<h1>7 PEIMs<a class="headerlink" href="#peims" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id187">
<h2>7.1 Introduction<a class="headerlink" href="#id187" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>A Pre-EFI Initialization Module (PEIM) represents a unit of code
and/or data. It abstracts domainspecific logic and is analogous to a
DXE driver. As such, a given group of PEIMs for a platform
deployment might include a set of the following:</div></blockquote>
<ul>
<li><p class="first">Platform-specific PEIMs</p>
</li>
<li><p class="first">Processor-specific PEIMs</p>
</li>
<li><p class="first">Chipset-specific PEIMs</p>
</li>
<li><p class="first">PEI CIS–prescribed architectural PEIMs</p>
</li>
<li><p class="first">Miscellaneous PEIMs</p>
<blockquote>
<div><p>The PEIM encapsulation allows for a platform builder to use services
for a given hardware technology without having to build the source
of this technology or necessarily understand its implementation. A
PEIM-to-PEIM Interface (PPI) is the means by which to abstract
hardwarespecific complexities to a platform builder’s PEIM. As such,
PEIMs can work in concert with other PEIMs using PPIs.</p>
<p>In addition, PEIMs can ascertain a fixed set of services that are
always available through the PEI Services Table.</p>
<p>Finally, because the PEIM represents the basic unit of execution
beyond the Security (SEC) phase and the PEI Foundation, there will
always be some non-zero-sized collection of PEIMs in a platform.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="peim-structure">
<h2>7.2 PEIM Structure<a class="headerlink" href="#peim-structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="peim-structure-overview">
<h3>7.2.1 PEIM Structure Overview<a class="headerlink" href="#peim-structure-overview" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Each PEI Module (PEIM) is stored in a file. It consists of the
following:</div></blockquote>
<ul>
<li><p class="first">Standard header</p>
</li>
<li><p class="first">Execute-in-place code/data section</p>
</li>
<li><p class="first">Optional relocation information</p>
</li>
<li><p class="first">Authentication information, if present</p>
<blockquote>
<div><p>The PEIM binary image can be executed in place from its location in
the firmware volume (FV) or from a compressed component that will be
shadowed after permanent memory has been installed. The executable
section of the PEIM may be either position-dependent or
position-independent code. If the executable section of the PEIM is
position-dependent code, relocation information must be provided in
the PEIM image to allow FV store software to relocate the image to a
different location than it is compiled.</p>
<p>Figure 2 depicts the typical layout of a PEIM.</p>
</div></blockquote>
</li>
</ul>
<p>Version 1.7 100 <strong>PEIMs</strong></p>
<p><a class="reference internal" href="media/image4.jpg"><img alt="image2" src="media/image4.jpg" style="width: 6.50000in; height: 3.96015in;" /></a></p>
</div>
<div class="section" id="relocation-information">
<h3>7.2.2 Relocation Information<a class="headerlink" href="#relocation-information" title="Permalink to this headline">¶</a></h3>
<div class="section" id="position-dependent-code">
<h4>7.2.2.1 Position-Dependent Code<a class="headerlink" href="#position-dependent-code" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>PEIMs that are developed using position-dependent code require
relocation information. When an image in a firmware volume (FV) is
updated, the update software will use the relocation information to
fix the code image according to the module’s location in the FV. The
relocation is done on the authenticated image; therefore, software
verifying the integrity of the image must undo the relocation during
the verification process.</p>
<p>There is no explicit pointer to this data. Instead, the update and
verification tool will know that the image is actually stored as
PE32 if the <em>Pe32Image</em> bit is set in the header</p>
<p><strong>EFI_COMMON_SECTION_HEADER</strong> or
<strong>EFI_COMMON_SECTION_HEADER2</strong>; types
<strong>EFI_COMMON_SECTION_HEADER</strong> and
<strong>EFI_COMMON_SECTION_HEADER2</strong> are defined in the</p>
<p><em>Platform Initialization Specification, Volume 3.</em> The PE32
specification, in turn, will be used to ascertain the relocation
records.</p>
</div></blockquote>
</div>
<div class="section" id="position-independent-code">
<h4>7.2.2.2 Position-Independent Code<a class="headerlink" href="#position-independent-code" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>If the PEIM is written in position-independent code, then its entry
point shall be at the lowest address in the section. This method is
useful for creating PEIMs for the Itanium® processor family.</div></blockquote>
</div>
<div class="section" id="relocation-information-format">
<h4>7.2.2.3 Relocation Information Format<a class="headerlink" href="#relocation-information-format" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The relocations will be contained in a TE or PE32+ image. See the
<em>Microsoft Portable Executable and Common Object File Format
Specification</em> for more information. The determination of whether
the image subscribes to the PE32 image format or is
position-independent assembly language is provided by the firmware
volume section type. The PEIM that is formatted as PE/COFF will
always be linked against a base address of zero. This allows for
support of signature checking.</p>
<p>The section may also be compressed if there is a compression
encapsulation section.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="authentication-information">
<h3>7.2.3 Authentication Information<a class="headerlink" href="#authentication-information" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This section describes in more detail, the means by which
authentication information could be contained in a section of type
<strong>EFI_SECTION_GUID_DEFINED</strong> (see the <em>Platform Initialization
Specification</em>, Volume 3, for more information on section types).
The information contained in this section could be one of the
following:</div></blockquote>
<ul>
<li><p class="first">A cryptographic-quality hash computed across the PEIM image</p>
</li>
<li><p class="first">A simple checksum</p>
</li>
<li><p class="first">A CRC</p>
<blockquote>
<div><p>The GUID defines the meaning of the associated encapsulated data.
The relocation section is needed to undo the fix-ups done on the
image so the hash that was computed at build time can be confirmed.
In other words, the build of a PEIM image is linked against zero,
but the update tool will relocate the PEIM image for its
execute-in-place address (at least for images that are not
positionindependent code). Any signing information is calculated on
the image after the image has been linked against an address of
zero. The relocations on the image will have to be “undone” to
determine if the image has been modified.</p>
<p>The image must be linked against address zero by the PEIM provider.
The build or update tool will apply the appropriate relocations. The
linkage against address zero is key because it allows a subsequent
undoing of the relocations.</p>
</div></blockquote>
</li>
</ul>
<p><strong>PEIMs</strong></p>
</div>
</div>
<div class="section" id="peim-invocation-entry-point">
<h2>7.3 PEIM Invocation Entry Point<a class="headerlink" href="#peim-invocation-entry-point" title="Permalink to this headline">¶</a></h2>
<div class="section" id="efi-peim-entry-point2">
<h3>7.3.1 EFI_PEIM_ENTRY_POINT2<a class="headerlink" href="#efi-peim-entry-point2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The PEI Dispatcher will invoke each PEIM one time.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEIM_ENTRY_POINT2) (</strong></p>
<p><strong>IN EFI_PEI_FILE_HANDLE</strong> <em>FileHandle,</em></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>FileHandle</em></p>
<p>Handle of the file being invoked. Type <strong>EFI_PEI_FILE_HANDLE</strong> is
defined in <strong>FfsFindNextFile()</strong>.</p>
<p><em>PeiServices</em></p>
<p>Describes the list of possible PEI Services.</p>
<p><strong>Description</strong></p>
<p>This function is the entry point for a PEIM.
<strong>EFI_IMAGE_ENTRY_POINT2</strong> is the equivalent of this state in the
UEFI/DXE environment; see the DXE CIS for its definition.</p>
<p>The motivation behind this definition is that the firmware file
system has the provision to mark a file as being both a PEIM and DXE
driver. The result of this name would be that both the PEI
Dispatcher and the DXE Dispatcher would attempt to execute the
module. In doing so, it is incumbent upon the code in the entry
point of the driver to decide what services are exposed, namely
whether to make boot service and runtime calls into the UEFI System
Table or to make calls into the PEI Services Table. The means by
which to make this decision entail examining the second</p>
<p>argument on entry, which is a pointer to the respective foundation’s
exported service-call table. Both</p>
<p>PEI and UEFI/DXE have a common header, <strong>EFI_TABLE_HEADER</strong>, for
the table. The code in the</p>
<p>PEIM or DXE driver will examine the <em>Arg2-&gt;Hdr-&gt;Signature</em>. If it is</p>
<p><strong>EFI_SYSTEM_TABLE_SIGNATURE</strong>, the code will assume DXE driver
behavior; if it is <strong>PEI_SERVICES_SIGNATURE</strong>, the code will
assume PEIM behavior.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The service completed successfully</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&lt; 0</td>
<td>There was an error</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="peim-descriptors">
<h2>7.4 PEIM Descriptors<a class="headerlink" href="#peim-descriptors" title="Permalink to this headline">¶</a></h2>
<div class="section" id="peim-descriptors-overview">
<h3>7.4.1 PEIM Descriptors Overview<a class="headerlink" href="#peim-descriptors-overview" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>A PEIM descriptor is the data structure used by PEIMs to export
service entry points and data. The descriptor contains the
following:</div></blockquote>
<ul>
<li><p class="first">Flags</p>
</li>
<li><p class="first">A pointer to a GUID</p>
</li>
<li><p class="first">A pointer to data</p>
<blockquote>
<div><p>The latter data can include a list of pointers to functions and/or
data. It is the function pointers that are commonly referred to as
PEIM-to-PEIM Interfaces (PPIs), and the PPI is the unit of software
across which PEIMs can invoke services from other PEIMs.</p>
<p>A PEIM also uses a PEIM descriptor to export a service to the PEI
Foundation into which the PEI Foundation will pass control in
response to an event, namely “notifying” the callback when a PPI is
installed or reinstalled. As such, PEIM descriptors serve the dual
role of exposing the following:</p>
</div></blockquote>
</li>
<li><p class="first">A callable interface/data for other PEIMs</p>
</li>
<li><p class="first">A callback interface from the perspective of the PEI Foundation</p>
</li>
</ul>
<p><strong>Platform Initialization Specification, Vol. 1 PEIMs</strong></p>
</div>
<div class="section" id="efi-pei-descriptor">
<h3>EFI_PEI_DESCRIPTOR<a class="headerlink" href="#efi-pei-descriptor" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This data structure is the means by which callable services are
installed and notifications are registered in the PEI phase.</p>
<p><strong>Prototype typedef union {</strong></p>
<p><strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong> <em>Notify;</em></p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR</strong> <em>Ppi;</em></p>
<p><strong>} EFI_PEI_DESCRIPTOR;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Notify</em></p>
<p>The typedef structure of the notification descriptor. See the</p>
<p><strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong> type definition.</p>
<p><em>Ppi</em></p>
<p>The typedef structure of the PPI descriptor. See the
<strong>EFI_PEI_PPI_DESCRIPTOR</strong> type definition.</p>
<p><strong>Description</strong></p>
<p><strong>EFI_PEI_DESCRIPTOR</strong> is a data structure that can be either a
PPI descriptor or a notification descriptor. A PPI descriptor is
used to expose callable services to other PEIMs. A notification
descriptor is used to register for a notification or callback when a
given PPI is installed.</p>
</div></blockquote>
<p>Version 1.7</p>
</div>
<div class="section" id="efi-pei-notify-descriptor">
<h3>EFI_PEI_NOTIFY_DESCRIPTOR<a class="headerlink" href="#efi-pei-notify-descriptor" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The data structure in a given PEIM that tells the PEI Foundation
where to invoke the notification service.</p>
<p><strong>Prototype typedef struct _EFI_PEI_NOTIFY_DESCRIPTOR {</strong></p>
<p><strong>UINTN</strong> <em>Flags;</em></p>
<p><strong>EFI_GUID</strong> <em>*Guid;</em></p>
<p><strong>EFI_PEIM_NOTIFY_ENTRY_POINT</strong> <em>Notify;</em></p>
<p><strong>} EFI_PEI_NOTIFY_DESCRIPTOR;</strong></p>
<p><strong>Parameters</strong> <em>Flags</em></p>
<p>Details if the type of notification is callback or dispatch.</p>
<p><em>Guid</em></p>
<p>The address of the <strong>EFI_GUID</strong> that names the interface.</p>
<p><em>Notify</em></p>
<p>Address of the notification callback function itself within the
PEIM. Type <strong>EFI_PEIM_NOTIFY_ENTRY_POINT</strong> is defined in
“Related Definitions” below.</p>
<p><strong>Description</strong></p>
<p><strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong> is a data structure that is used by
a PEIM that needs to be called back when a PPI is installed or
reinstalled. The notification is similar to the</p>
<p><strong>RegisterProtocolNotify()</strong> function in the UEFI 2.0 Specification.
The use model is complementary to the dependency expression (depex)
and is as follows:</p>
</div></blockquote>
<ul>
<li><p class="first">A PEIM expresses the PPIs that it <em>must</em> have to execute in its depex
list.</p>
</li>
<li><p class="first">A PEIM expresses any other PEIMs that it needs, perhaps at some later
time, in</p>
<blockquote>
<div><p><strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong>.</p>
<p>The latter data structure includes the GUID of the PPI for which the
PEIM publishing the notification would like to be reinvoked.</p>
<p>Following is an example of the notification use model for</p>
<p><strong>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI</strong>. In this example, a
PEIM called <em>SamplePeim</em> executes early in the PEI phase before main
memory is available. However,</p>
<p>SamplePeim also needs to create some large data structure later in
the PEI phase. As such, SamplePeim has a NULL depex, but after its
entry point is processed, it needs to call</p>
<p><strong>NotifyPpi()</strong> with a <strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong>, where the
notification descriptor includes the following:</p>
</div></blockquote>
</li>
<li><p class="first">A reference to <strong>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI</strong></p>
</li>
<li><p class="first">A reference to a function within this same PEIM called
<em>SampleCallback</em></p>
</li>
</ul>
<p><strong>Platform Initialization Specification, Vol. 1 PEIMs</strong></p>
<blockquote>
<div><p>When the PEI Foundation finally migrates the system from temporary
to permanent memory and installs the
<strong>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI</strong>, the PEI Foundation
assesses if there are any pending notifications on this PPI. After
the PEI Foundation discovers the descriptor from SamplePeim, the PEI
Foundation invokes SampleCallback.</p>
<p>With respect to the <em>Flags</em> parameter, the difference between
callback and dispatch mode is as follows:</p>
</div></blockquote>
<ul>
<li><p class="first"><strong>Callback mode:</strong> Invokes all of the agents that are registered for
notification immediately after the PPI is installed.</p>
</li>
<li><p class="first"><strong>Dispatch mode:</strong> Calls the agents that are registered for
notification only after the PEIM that installs the PPI in question
has returned to the PEI Foundation.</p>
<blockquote>
<div><p>The callback mechanism will give a better quality of service, but it
has the downside of possibly deepening the use of the stack (i.e.,
the agent that installed the PPI that engenders the notification is
a PEIM itself that has used the stack already). The dispatcher mode,
however, is better from a stackusage perspective in that when the
PEI Foundation invokes the agents that want notification, the stack
has returned to the minimum stack usage of just the PEI Foundation.</p>
<p><strong>Related Definitions typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEIM_NOTIFY_ENTRY_POINT) (</strong></p>
</div></blockquote>
</li>
</ul>
<p><strong>IN EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<blockquote>
<div><strong>IN EFI_PEI_NOTIFY_DESCRIPTOR</strong> <em>*NotifyDescriptor,</em></div></blockquote>
<p><strong>IN VOID</strong> <em>*Ppi</em></p>
<blockquote>
<div><p><strong>);</strong></p>
<p><em>PeiServices</em></p>
<p>Indirect reference to the PEI Services Table.</p>
<p><em>NotifyDescriptor</em></p>
<p>Address of the notification descriptor data structure. Type</p>
<p><strong>EFI_PEI_NOTIFY_DESCRIPTOR</strong> is defined above. <em>Ppi</em></p>
<p>Address of the PPI that was installed.</p>
<p>The status code returned from this function is ignored.</p>
</div></blockquote>
<p>Version 1.7</p>
</div>
<div class="section" id="efi-pei-ppi-descriptor">
<h3>EFI_PEI_PPI_DESCRIPTOR<a class="headerlink" href="#efi-pei-ppi-descriptor" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The data structure through which a PEIM describes available services
to the PEI Foundation.</p>
<p><strong>Prototype typedef struct {</strong></p>
<p><strong>UINTN</strong> <em>Flags;</em></p>
<p><strong>EFI_GUID</strong> <em>*Guid;</em></p>
<p><strong>VOID</strong> <em>*Ppi;</em></p>
<p><strong>} EFI_PEI_PPI_DESCRIPTOR;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Flags</em></p>
<p>This field is a set of flags describing the characteristics of this
imported table entry. See “Related Definitions” below for possible
flag values.</p>
<p><em>Guid</em></p>
<p>The address of the <strong>EFI_GUID</strong> that names the interface.</p>
<p><em>Ppi</em></p>
<p>A pointer to the PPI. It contains the information necessary to
install a service.</p>
<p><strong>Description</strong></p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR</strong> is a data structure that is within the
body of a PEIM or created by a PEIM. It includes the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Information about the nature of the service</p>
</li>
<li><p class="first">A reference to a GUID naming the service</p>
</li>
<li><p class="first">An associated pointer to either a function or data related to the
service</p>
<blockquote>
<div><p>There can be a catenation of one or more of these
<strong>EFI_PEI_PPI_DESCRIPTOR</strong>s. The final descriptor will have the
<strong>EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST</strong> flag set to indicate
to the PEI Foundation how many of the descriptors need to be added
to the PPI database within the PEI Foundation. The PEI Services that
references this data structure include <strong>InstallPpi()</strong>,
<strong>ReinstallPpi()</strong>, and <strong>LocatePpi()</strong>.</p>
<p><strong>Related Definitions</strong></p>
<p><strong>//</strong></p>
<p><strong>// PEI PPI Services List Descriptors //</strong></p>
<p><strong>#define EFI_PEI_PPI_DESCRIPTOR_PIC 0x00000001</strong></p>
<p><strong>#define EFI_PEI_PPI_DESCRIPTOR_PPI 0x00000010</strong></p>
<p><strong>#define EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK 0x00000020</strong></p>
<p><strong>#define EFI_PEI_PPI_DESCRIPTOR_NOTIFY_DISPATCH 0x00000040</strong></p>
<p><strong>#define EFI_PEI_PPI_DESCRIPTOR_NOTIFY_TYPES 0x00000060</strong></p>
</div></blockquote>
</li>
</ul>
<p><strong>Platform Initialization Specification, Vol. 1 PEIMs</strong></p>
<blockquote>
<div><p><strong>#define EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST 0x80000000</strong></p>
<p><em>Table 16</em> provides descriptions of the fields in the above
definition:</p>
<p><strong>Table 16. PEI PPI Services List Descriptors</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Descriptor</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_PEI_PPI_DESCRIPTOR_PIC</td>
<td>When set to 1, this designates that the PPI described by the structure is position-independent code (PIC).</td>
</tr>
<tr class="row-odd"><td>EFI_PEI_PPI_DESCRIPTOR_PPI</td>
<td>When set to 1, this designates that the PPI described by this structure is a normal PPI. As such, it should be callable by the conventional PEI infrastructure.</td>
</tr>
<tr class="row-even"><td>EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK</td>
<td>When set to 1, this flag designates that the service registered in the descriptor is to be invoked at callback. This means that if the PPI is installed for which the listener registers a notification, then the callback routine will be immediately invoked. The danger herein is that the callback will inherit whatever depth had been traversed up to and including this call.</td>
</tr>
<tr class="row-odd"><td>EFI_PEI_PPI_DESCRIPTOR_NOTIFY_DISPATCH</td>
<td>When set to 1, this flag designates that the service registered in the descriptor is to be invoked at dispatch. This means that if the PPI is installed for which the listener registers a notification, then the callback routine will be deferred until the PEIM calling context returns to the PEI Foundation. Prior to invocation of the next PEIM, the notifications will be dispatched. The advantage herein is that the callback will have the maximum available stack depth as any other PEIM.</td>
</tr>
<tr class="row-even"><td>EFI_PEI_PPI_DESCRIPTOR_NOTIFY_TYPES</td>
<td>When set to 1, this flag designates that this is a notification-style PPI.</td>
</tr>
<tr class="row-odd"><td>EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST</td>
<td>This flag is set to 1 in the last structure entry in the list of PEI PPI descriptors. This flag is used by the PEI Foundation Services to know that there are no additional interfaces to install.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="peim-to-peim-communication">
<h2>7.5 PEIM-to-PEIM Communication<a class="headerlink" href="#peim-to-peim-communication" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id188">
<h3>7.5.1 Overview<a class="headerlink" href="#id188" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>PEIMs may invoke other PEIMs. The interfaces themselves are named
using GUIDs. Because the PEIMs may be authored by different
organizations at different times and updated at different times,
references to these interfaces cannot be resolved during their
execution by referring to the PEI PPI database. The database is
loaded and queried using PEI Services such as <strong>InstallPpi()</strong> and</p>
<p><strong>LocatePpi()</strong>.</p>
</div></blockquote>
<p>Version 1.7 July 2018</p>
</div>
<div class="section" id="dynamic-ppi-discovery">
<h3>7.5.2 Dynamic PPI Discovery<a class="headerlink" href="#dynamic-ppi-discovery" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ppi-database">
<h4>7.5.2.1 PPI Database<a class="headerlink" href="#ppi-database" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The PPI database is a data structure that PEIMs can use to discover
what interfaces are available or to manage a specific interface. The
actual layout of the PPI database is opaque to a PEIM but its
contents can be queried and manipulated using the following PEI
Services:</div></blockquote>
<ul class="simple">
<li><strong>InstallPpi()</strong></li>
<li><strong>ReinstallPpi()</strong></li>
<li><strong>LocatePpi()</strong></li>
<li><strong>NotifyPpi()</strong></li>
</ul>
</div>
<div class="section" id="invoking-a-ppi">
<h4>7.5.2.2 Invoking a PPI<a class="headerlink" href="#invoking-a-ppi" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>When the PEI Foundation examines a PEIM for dispatch eligibility, it
examines the dependency expression section of the firmware file. If
there are non-NULL contents, the Reverse Polish Notation (RPN)
expression is evaluated. Any requested PPI GUIDs in this data
structure are queried in the PPI database. The existence in the
database of the particular PUSH_GUID depex opcode leads to this
expression evaluating to true.</div></blockquote>
</div>
<div class="section" id="address-resolution">
<h4>7.5.2.3 Address Resolution<a class="headerlink" href="#address-resolution" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>When a PEIM needs to leverage a PPI, it uses the PEI Foundation
Service <strong>LocatePpi()</strong> to discover if an instance of the interface
exists. The PEIM could do either of the following:</div></blockquote>
<ul>
<li><p class="first">Install the PPI in its depex to ensure that its entry point will not
be invoked until the needed PPI is already installed</p>
</li>
<li><p class="first">Have a very thin set of code in its entry point that simply registers
a notification on the desired PPI.</p>
<blockquote>
<div><p>In the case of either the depex or the notification, the
<strong>LocatePpi()</strong> call will then succeed and the pointer returned on
this call references the <strong>EFI_PEI_PPI_DESCRIPTOR</strong>. It is
through this data structure that the actual code entry point can be
discovered. If this PEIM is being loaded before permanent memory is
available, it will not have resources to cache this discovered
interface and will have to search for this interface every time it
needs to invoke the service.</p>
<p>It should also be noted that you cannot uninstall a PPI, so the
services will be left in the database. If a PPI needs to be
shrouded, a version can be “reinstalled” that just returns failure.</p>
<p>Also, there is peril in caching a PPI. For example, if you cache a
PPI and the producer of the PPI “reinstalls” it to be something else
(i.e., shadows to memory), then you have the possibility that the
agent who cached the data will have “stale” or “illegal” data. For
example, imagine the Stall PPI,</p>
<p><strong>EFI_PEI_STALL_PPI</strong>, relocating itself to memory using the Load
File PPI,</p>
<p><strong>EFI_PEI_LOAD_FILE_PPI</strong>, and reinstalling the interface for
performance considerations. A way to solve the latter issue, as a
platform builder, is by having a different stall PPI for the
memorybased one versus that of the Execute In Place (XIP) one.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Platform Initialization Specification, Vol. 2</strong></p>
</div>
</div>
</div>
</div>
<div class="section" id="additional-ppis">
<h1>8 Additional PPIs<a class="headerlink" href="#additional-ppis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id189">
<h2>8.1 Introduction<a class="headerlink" href="#id189" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Architectural PPIs described a collection of architecturally
required PPIs. These were interfaces consumed by the PEI Foundation
and are not intended to be consumed by other PEIMs.</p>
<p>In addition to these architectural PPIs, however, there is another
name space of PPIs that are optional or mandatory for a given
platform. This section describes these additional PPIs:</p>
</div></blockquote>
<ul>
<li><p class="first">Required PPIs:</p>
<blockquote>
<div><p>— CPU I/O PPI</p>
<p class="attribution">&mdash;PCI Configuration PPI</p>
</div></blockquote>
<blockquote>
<div><p>— Stall PPI</p>
<p class="attribution">&mdash;PEI Variable Services</p>
</div></blockquote>
</li>
<li><p class="first">Optional PPIs:</p>
<blockquote>
<div><p>— Security (SEC) Platform Information PPI</p>
<p>These shall be referred to as first-class PEIMs in some contexts.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="required-additional-ppis">
<h2>8.2 Required Additional PPIs<a class="headerlink" href="#required-additional-ppis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pci-configuration-ppi-required">
<h3>8.2.1 PCI Configuration PPI (Required)<a class="headerlink" href="#pci-configuration-ppi-required" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The PEI phase provides limited support for initializing and
configuring PCI devices through the EFI_PEI_PCI_CFG2_PPI. The
PEI module which supports a PCI root bridge may install this PPI to
allow access to the PCI configuration space for a particular PCI
segment. The PEI module responsible for the PCI root bridge
representing segment 0 should also install a pointer to the PPI in
the PEI Services Table.</p>
<p>The PEI modules which control devices on segment 0 may use the
pointer provided in the PEI Services Table. The PEI modules for
devices residing on other segments may find the correct PPI by
iterating through PPI instances using the LocatePpi() function. For
example:</p>
</div></blockquote>
<p><strong>Additional PPIs</strong></p>
<blockquote>
<div><p><strong>EFI_STATUS Status;</strong></p>
<p><strong>UINTN Instance = 0;</strong></p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR *PciCfgDescriptor = NULL;
EFI_PEI_PCI_CFG2_PPI *PciCfg = NULL;</strong></p>
<p><strong>/* Loop through all instances of the PPI */ for (;;) {</strong></p>
<p><strong>Status = PeiServices-&gt;LocatePpi(PeiServices,</strong></p>
<p><strong>&amp;gPeiPciCfg2PpiGuid,</strong></p>
<p><strong>Instance,</strong></p>
<p><strong>&amp;PciCfgDescriptor,</strong></p>
<p><strong>(VOID**) &amp;PciCfg</strong></p>
<p><strong>);</strong></p>
<p><strong>if (Status != EFI_SUCCESS || PciCfg-&gt;Segment == MySegment) {
break;</strong></p>
<p><strong>}</strong></p>
<p><strong>Instance++;</strong></p>
<p><strong>}</strong></p>
<p><strong>if (Status == EFI_SUCCESS) { …PciCfg contains pointer…</strong></p>
<p><strong>}</strong></p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
</div>
<div class="section" id="efi-pei-pci-cfg2-ppi">
<h3>EFI_PEI_PCI_CFG2_PPI<a class="headerlink" href="#efi-pei-pci-cfg2-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Provides platform or chipset-specific access to the PCI
configuration space for a specific PCI segment.</p>
<p><strong>Guid static const EFI_GUID EFI_PEI_PCI_CFG2_PPI_GUID = \</strong></p>
<p><strong>{ 0x57a449a, 0x1fdc, 0x4c06, \</strong></p>
<p><strong>{ 0xbf, 0xc9, 0xf5, 0x3f, 0x6a, 0x99, 0xbb, 0x92 }}</strong></p>
<p><strong>Prototype typedef struct _EFI_PEI_PCI_CFG2_PPI {</strong></p>
<p><strong>EFI_PEI_PCI_CFG2_PPI_IO</strong> <em>Read;</em></p>
<p><strong>EFI_PEI_PCI_CFG2_PPI_IO</strong> <em>Write;</em></p>
<p><strong>EFI_PEI_PCI_CFG2_PPI_RW</strong> <em>Modify;</em></p>
<p><strong>UINT16</strong> <em>Segment;</em></p>
<p><strong>} EFI_PEI_PCI_CFG2_PPI</strong></p>
<p><strong>Parameters</strong> <em>Read</em></p>
<p>PCI read services. See the <strong>Read()</strong> function description.</p>
<p><em>Write</em></p>
<p>PCI write services. See the <strong>Write()</strong> function description.</p>
<p><em>Modify</em></p>
<p>PCI read-modify-write services. See the <strong>Modify()</strong> function
description.</p>
<p><em>Segment</em></p>
<p>The PCI bus segment which the specified functions will access.</p>
<p><strong>Description</strong></p>
<p>The <strong>EFI_PEI_PCI_CFG2_PPI</strong> interfaces are used to abstract
accesses to the configuration space of PCI controllers behind a PCI
root bridge controller. There can be multiple instances of this PPI
in the system, one for each segment. The pointer to the instance
which describes segment 0 is installed in the PEI Services Table.</p>
<p>The assignment of segment numbers is implementation specific.</p>
<p>The <strong>Modify()</strong> service allows for space-efficient implementation
of the following common operations:</p>
</div></blockquote>
<ul>
<li><p class="first">Reading a register</p>
</li>
<li><p class="first">Changing some bit fields within the register</p>
</li>
<li><p class="first">Writing the register value back into the hardware</p>
<blockquote>
<div><p>The <strong>Modify()</strong> service is a composite of the <strong>Read()</strong> and
<strong>Write()</strong> services.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Additional PPIs</strong></p>
<blockquote>
<div><p><strong>Parameters</strong></p>
<p><em>Register</em></p>
<p>Register number in PCI configuration space.</p>
<p><em>Function</em></p>
<p>Function number in the PCI device (0-7).</p>
<p><em>Device</em></p>
<p>Device number in the PCI device (0-31).</p>
<p><em>Bus</em></p>
<p>PCI bus number (0-255).</p>
<p><em>ExtendedRegister</em></p>
<p>Register number in PCI configuration space. If this field is zero,
then <em>Register</em> is used for the register number. If this field is
non-zero, then <em>Register</em> is ignored and this field is used for the
register number.</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
</div>
<div class="section" id="efi-pei-pci-cfg2-ppi-read">
<h3>EFI_PEI_PCI_CFG2_PPI.Read()<a class="headerlink" href="#efi-pei-pci-cfg2-ppi-read" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>PCI read operation.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_PCI_CFG_PPI_IO) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_PCI_CFG2_PPI</strong> <em>*This,</em></p>
<p><strong>IN EFI_PEI_PCI_CFG_PPI_WIDTH</strong> <em>Width,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN OUT VOID</strong> <em>*Buffer</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Width</em></p>
<p>The width of the access. Enumerated in bytes. Type</p>
<p><strong>EFI_PEI_PCI_CFG_PPI_WIDTH</strong> is defined in “Related
Definitions” below.</p>
<p><em>Address</em></p>
<p>The physical address of the access. The format of the address is
described by <strong>EFI_PEI_PCI_CFG_PPI_PCI_ADDRESS</strong>, which is
defined in “Related Definitions” below.</p>
<p><em>Buffer</em></p>
<p>A pointer to the buffer of data.</p>
<p><strong>Description</strong></p>
<p>The <strong>Read()</strong> function reads from a given location in the PCI
configuration space.</p>
<p><strong>Related Definitions</strong></p>
<p><strong>//************************************************************</strong></p>
<p><strong>// EFI_PEI_PCI_CFG_PPI_WIDTH</strong></p>
<p><strong>//************************************************************
typedef enum {</strong></p>
<p><strong>EfiPeiPciCfgWidthUint8 = 0,</strong></p>
<p><strong>EfiPeiPciCfgWidthUint16 = 1,</strong></p>
<p><strong>EfiPeiPciCfgWidthUint32 = 2,</strong></p>
<p><strong>EfiPeiPciCfgWidthUint64 = 3,</strong></p>
</div></blockquote>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>EfiPeiPciCfgWidthMaximum } EFI_PEI_PCI_CFG_PPI_WIDTH;</strong></p>
<p><strong>//************************************************************</strong></p>
<p><strong>// EFI_PEI_PCI_CFG_PPI_PCI_ADDRESS</strong></p>
<p><strong>//************************************************************
typedef struct {</strong></p>
<p><strong>UINT8</strong> <em>Register;</em></p>
<p><strong>UINT8</strong> <em>Function;</em></p>
<p><strong>UINT8</strong> <em>Device;</em></p>
<p><strong>UINT8</strong> <em>Bus;</em></p>
<p><strong>UINT32</strong> <em>ExtendedRegister;</em></p>
<p><strong>} EFI_PEI_PCI_CFG_PPI_PCI_ADDRESS;</strong></p>
<p><em>Register</em></p>
<p>8-bit register offset within the PCI configuration space for a given
device’s function space.</p>
<p><em>Function</em></p>
<p>Only the 3 least-significant bits are used to encode one of 8
possible functions within a given device.</p>
<p><em>Device</em></p>
<p>Only the 5 least-significant bits are used to encode one of 32
possible devices.</p>
<p><em>Bus</em></p>
<p>8-bit value to encode between 0 and 255 buses.</p>
<p><em>ExtendedRegister</em></p>
<p>Register number in PCI configuration space. If this field is zero,
then <em>Register</em> is used for the register number. If this field is
non-zero, then <em>Register</em> is ignored and this field is used for the
register number.</p>
<p><strong>#define EFI_PEI_PCI_CFG_ADDRESS(bus,dev,func,reg) \</strong></p>
<p><strong>(((bus) &lt;&lt; 24) | \</strong></p>
<p><strong>((dev) &lt;&lt; 16) | \</strong></p>
<p><strong>((func) &lt;&lt; 8) | \</strong></p>
<p><a href="#id190"><span class="problematic" id="id191">**</span></a>((reg) &lt; 256 ? (reg) : ((UINT64) (reg) &lt;&lt; 32))) **</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The function completed successfully</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>There was a problem with the transaction.</td>
</tr>
<tr class="row-odd"><td>EFI_DEVICE_NOT_READY</td>
<td>The device is not capable of supporting the operation at this time.</td>
</tr>
</tbody>
</table>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
</div>
<div class="section" id="efi-pei-pci-cfg2-ppi-write">
<h3>EFI_PEI_PCI_CFG2_PPI.Write()<a class="headerlink" href="#efi-pei-pci-cfg2-ppi-write" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>PCI write operation.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_PCI_CFG_PPI_IO) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_PCI_CFG2_PPI</strong> <em>*This,</em> <strong>IN
EFI_PEI_PCI_CFG_PPI_WIDTH</strong> <em>Width,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN OUT VOID</strong> <em>*Buffer</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Width</em></p>
<p>The width of the access. Enumerated in bytes. Type</p>
<p><strong>EFI_PEI_PCI_CFG_PPI_WIDTH</strong> is defined in <strong>Read()</strong>.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Buffer</em></p>
<p>A pointer to the buffer of data.</p>
<p><strong>Description</strong></p>
<p>The <strong>Write()</strong> function writes to a given location in the PCI
configuration space.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The function completed successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>There was a problem with the transaction.</td>
</tr>
<tr class="row-odd"><td>EFI_DEVICE_NOT_READY</td>
<td>The device is not capable of supporting the operation at this time.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-pei-pci-cfg2-ppi-modify">
<h3>EFI_PEI_PCI_CFG2_PPI.Modify()<a class="headerlink" href="#efi-pei-pci-cfg2-ppi-modify" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>PCI read-modify-write Operation.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_PCI_CFG_PPI_RW) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices</em><strong>,</strong></p>
<p><strong>IN CONST EFI_PEI_PCI_CFG_PPI</strong> <em>*This,</em></p>
<p><strong>IN EFI_PEI_PCI_CFG_PPI_WIDTH</strong> <em>Width,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN VOID</strong> <em>*SetBits,</em></p>
<p><strong>IN VOID</strong> <em>*ClearBits</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Width</em></p>
<p>The width of the access. Enumerated in bytes. Type</p>
<p><strong>EFI_PEI_PCI_CFG_PPI_WIDTH</strong> is defined in <strong>Read()</strong>.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>SetBits</em></p>
<p>Points to value to bitwise-OR with the read configuration value. The
size of the value is determined by <em>Width</em>.</p>
<p><em>ClearBits</em></p>
<p>Points to the value to negate and bitwise-AND with the read
configuration value. The size of the value is determined by <em>Width</em>.</p>
<p><strong>Description</strong></p>
<p>The <strong>Modify()</strong> function performs a read-modify-write operation on
the contents from a given location in the PCI configuration space.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The function completed successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>There was a problem with the transaction.</td>
</tr>
<tr class="row-odd"><td>EFI_DEVICE_NOT_READY</td>
<td>The device is not capable of supporting the operation at this time.</td>
</tr>
</tbody>
</table>
<p><strong>8.2.2 Stall PPI (Required)</strong></p>
</div>
<div class="section" id="efi-pei-stall-ppi-required">
<h3>EFI_PEI_STALL_PPI (Required)<a class="headerlink" href="#efi-pei-stall-ppi-required" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is installed by some platform or chipset-specific PEIM that
abstracts the blocking stall service to other agents.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_STALL_PPI_GUID \</strong></p>
<p><strong>{ 0x1f4c6f90, 0xb06b, 0x48d8, {0xa2, 0x01, 0xba, 0xe5, \</strong></p>
<p><strong>0xf1, 0xcd, 0x7d, 0x56} }</strong></p>
<p><strong>PPI Interface Structure typedef</strong></p>
<p><strong>struct _EFI_PEI_STALL_PPI {</strong></p>
<p><strong>UINTN</strong> <em>Resolution;</em></p>
<p><strong>EFI_PEI_STALL</strong> <em>Stall;</em></p>
<p><strong>} EFI_PEI_STALL_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Resolution</em></p>
<p>The resolution in microseconds of the stall services.</p>
<p><em>Stall</em></p>
<p>The actual stall procedure call. See the <strong>Stall()</strong> function
description.</p>
<p><strong>Description</strong></p>
<p>This service provides a simple, blocking stall with
platform-specific resolution.</p>
</div></blockquote>
<p>Version 1.7 July 2018</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-pei-stall-ppi-stall">
<h3>EFI_PEI_STALL_PPI.Stall()<a class="headerlink" href="#efi-pei-stall-ppi-stall" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Blocking stall.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_STALL) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_STALL_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINTN</strong> <em>Microseconds</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Pointer to the local data for the interface.</p>
<p><em>Microseconds</em></p>
<p>Number of microseconds for which to stall.</p>
<p><strong>Description</strong></p>
<p>The <strong>Stall()</strong> function provides a blocking stall for at least the
number of microseconds stipulated in the final argument of the API.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EFI_SUCCESS</td>
<td>The service provided at least the required delay.</td>
</tr>
</tbody>
</table>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<p><strong>8.2.3 Variable Services PPI (Required)</strong></p>
</div>
<div class="section" id="efi-pei-read-only-variable2-ppi">
<h3>EFI_PEI_READ_ONLY_VARIABLE2_PPI<a class="headerlink" href="#efi-pei-read-only-variable2-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Permits read-only access to the UEFI variable store during the PEI
phase.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_READ_ONLY_VARIABLE2_PPI_GUID \</strong></p>
<p><strong>{ 0x2ab86ef5, 0xecb5, 0x4134, \</strong></p>
<p><strong>0xb5, 0x56, 0x38, 0x54, 0xca, 0x1f, 0xe1, 0xb4 }</strong></p>
<p><strong>Prototype typedef struct _EFI_PEI_READ_ONLY_VARIABLE2_PPI {
EFI_PEI_GET_VARIABLE2</strong> <em>GetVariable</em><strong>;</strong></p>
<p><strong>EFI_PEI_GET_NEXT_VARIABLE_NAME2</strong> <em>NextVariableName</em><strong>; }
EFI_PEI_READ_ONLY_VARIABLE2_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>GetVariable</em></p>
<p>A service to read the value of a particular variable using its name.</p>
<p><em>NextVariableName</em></p>
<p>Find the next variable name in the variable store.</p>
<p><strong>Description</strong></p>
<p>These services provide a light-weight, read-only variant of the full
UEFI variable services.</p>
</div></blockquote>
<p>Version 1.7 July 2018</p>
</div>
<div class="section" id="efi-pei-read-only-variable2-ppi-getvariable">
<h3>EFI_PEI_READ_ONLY_VARIABLE2_PPI.GetVariable<a class="headerlink" href="#efi-pei-read-only-variable2-ppi-getvariable" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service retrieves a variable’s value using its name and GUID.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GET_VARIABLE2)(</strong></p>
<p><strong>IN CONST EFI_PEI_READ_ONLY_VARIABLE2_PPI *</strong><em>This,</em></p>
<p><strong>IN CONST CHAR16</strong> <em>*VariableName,</em></p>
<p><strong>IN CONST EFI_GUID</strong> <em>*VariableGuid,</em> <strong>OUT UINT32</strong>
<em>*Attributes, OPTIONAL</em></p>
<p><strong>IN OUT UINTN</strong> <em>*DataSize,</em></p>
<p><strong>OUT VOID</strong> <em>*Data</em> <strong>OPTIONAL );</strong></p>
<p><strong>Parameters</strong> <em>This</em></p>
<p>A pointer to this instance of the
<strong>EFI_PEI_READ_ONLY_VARIABLE2_PPI</strong>. <em>VariableName</em></p>
<p>A pointer to a null-terminated string that is the variable’s name.</p>
<p><em>VariableGuid</em></p>
<p>A pointer to an <strong>EFI_GUID</strong> that is the variable’s GUID. The
combination of <em>VariableGuid</em> and <em>VariableName</em> must be unique.</p>
<p><em>Attributes</em></p>
<p>If non-NULL, on return, points to the variable’s attributes. See
“Related Definitons” below for possible attribute values.</p>
<p><em>DataSize</em></p>
<p>On entry, points to the size in bytes of the <em>Data</em> buffer. On
return, points to the size of the data returned in <em>Data</em>.</p>
<p><em>Data</em></p>
<p>Points to the buffer which will hold the returned variable value.
May be <strong>NULL</strong> with a zero <em>DataSize</em> in order to determine the
size of the buffer needed.</p>
<p><strong>Description</strong></p>
<p>Read the specified variable from the UEFI variable store. If the
<em>Data</em> buffer is too small to hold the contents of the variable, the
error <strong>EFI_BUFFER_TOO_SMALL</strong> is returned and <em>DataSize</em> is set
to the required buffer size to obtain the data.</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The variable was read successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The variable was not found.</td>
</tr>
<tr class="row-odd"><td>EFI_BUFFER_TOO_SMALL</td>
<td>The <em>DataSize</em> is too small for the result. <em>DataSize</em> has been updated with the size needed to complete the request.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>VariableName</em> is <strong>NULL</strong>.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><em>DataSize</em> is <strong>NULL</strong>.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>The <em>DataSize</em> is not too small and Data is <strong>NULL</strong>.</td>
</tr>
<tr class="row-odd"><td>EFI_DEVICE_ERROR</td>
<td>The variable could not be retrieved because of a device error.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>VariableGuid</em> is <strong>NULL</strong>.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
</div>
<div class="section" id="efi-pei-read-only-variable2-ppi-nextvariablename">
<h3>EFI_PEI_READ_ONLY_VARIABLE2_PPI.NextVariableName<a class="headerlink" href="#efi-pei-read-only-variable2-ppi-nextvariablename" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Return the next variable name and GUID.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI EFI_PEI_GET_NEXT_VARIABLE_NAME2) (</strong></p>
<p><strong>IN CONST EFI_PEI_READ_ONLY_VARIABLE2_PPI</strong> <em>*This,</em></p>
<p><strong>IN OUT UINTN *</strong><em>VariableNameSize,</em></p>
<p><strong>IN OUT CHAR16</strong> <em>*VariableName,</em></p>
<p><strong>IN OUT EFI_GUID</strong> <em>*VariableGuid</em> <strong>);</strong></p>
<p><strong>Parameters</strong> <em>This</em></p>
<p>A pointer to this instance of the
<strong>EFI_PEI_READ_ONLY_VARIABLE2_PPI</strong>.</p>
<p><em>VariableNameSize</em></p>
<p>On entry, points to the size of the buffer pointed to by
<em>VariableName</em>. On return, the size of the variable name buffer</p>
<p><em>VariableName</em></p>
<p>On entry, a pointer to a null-terminated string that is the
variable’s name. On return, points to the next variable’s
null-terminated name string.</p>
<p><em>VariableGuid</em></p>
<p>On entry, a pointer to an <strong>EFI_GUID</strong> that is the variable’s GUID.
On return, a pointer to the next variable’s GUID.</p>
<p><strong>Description</strong></p>
<p>This function is called multiple times to retrieve the
<em>VariableName</em> and <em>VariableGuid</em> of all variables currently
available in the system. On each call, the previous results are
passed into the interface, and, on return, the interface returns the
data for the next interface. When the entire variable list has been
returned, <strong>EFI_NOT_FOUND</strong> is returned.</p>
</div></blockquote>
<p><strong>*Note:</strong> If* <strong>EFI_BUFFER_TOO_SMALL</strong> <a href="#id192"><span class="problematic" id="id193">*</span></a>is returned, the
VariableName buffer was too small for the name of the next variable.
When such an error occurs, VariableNameSize is updated to reflect the
size of the buffer needed. In all cases when calling
GetNextVariableName() the VariableNameSize must not exceed the actual
buffer size that was allocated for *</p>
<blockquote>
<div><p><em>VariableName.</em></p>
<p>To start the search, a null-terminated string is passed in
<em>VariableName</em>; that is, <em>VariableName</em> is a pointer to a null
Unicode character. This is always done on the initial call. When</p>
<p><em>VariableName</em> is a pointer to a null Unicode character,
<em>VariableGuid</em> is ignored.</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The variable was read successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The variable could not be found.</td>
</tr>
<tr class="row-odd"><td>EFI_BUFFER_TOO_SMALL</td>
<td>The <em>VariableNameSize</em> is too small for the resulting data. <em>VariableNameSize</em> is updated with the size required for the specified variable.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>VariableName</em>, <em>VariableGuid</em> or <em>VariableNameSize</em> is <strong>NULL</strong></td>
</tr>
<tr class="row-odd"><td>EFI_DEVICE_ERROR</td>
<td>The variable could not be retrieved because of a device error.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
</div>
</div>
<div class="section" id="optional-additional-ppis">
<h2>8.3 Optional Additional PPIs<a class="headerlink" href="#optional-additional-ppis" title="Permalink to this headline">¶</a></h2>
<p><strong>8.3.1 SEC Platform Information PPI (Optional)</strong></p>
<div class="section" id="efi-sec-platform-information-ppi-optional">
<h3>EFI_SEC_PLATFORM_INFORMATION_PPI (Optional)<a class="headerlink" href="#efi-sec-platform-information-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service is the platform information for the PEI Foundation.</p>
<p><strong>GUID</strong></p>
<p><a href="#id194"><span class="problematic" id="id195">**</span></a>#define EFI_SEC_PLATFORM_INFORMATION_GUID \ **</p>
<p><strong>{0x6f8c2b35, 0xfef4, 0x448d, 0x82, 0x56, 0xe1, \</strong></p>
<p><strong>0x1b, 0x19, 0xd6, 0x10, 0x77}</strong></p>
<p><strong>Prototype typedef struct _EFI_SEC_PLATFORM_INFORMATION_PPI
{</strong></p>
<p><strong>EFI_SEC_PLATFORM_INFORMATION</strong> <em>PlatformInformation;</em></p>
<p><strong>} EFI_SEC_PLATFORM_INFORMATION_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PlatformInformation</em></p>
<p>Conveys state information out of the SEC phase into PEI. See the
<strong>PlatformInformation()</strong> function description.</p>
<p><strong>Description</strong></p>
<p>This service abstracts platform-specific information.</p>
</div></blockquote>
</div>
<div class="section" id="efi-sec-platform-information-ppi-platforminformation">
<h3>EFI_SEC_PLATFORM_INFORMATION_PPI.PlatformInformation()<a class="headerlink" href="#efi-sec-platform-information-ppi-platforminformation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service is the single member of the
<strong>EFI_SEC_PLATFORM_INFORMATION_PPI</strong> that conveys state
information out of the Security (SEC) phase into PEI.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_SEC_PLATFORM_INFORMATION) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN OUT UINT64</strong> <em>*StructureSize,</em> <strong>OUT
EFI_SEC_PLATFORM_INFORMATION_RECORD</strong></p>
<p><em>*PlatformInformationRecord</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>Pointer to the PEI Services Table.</p>
<p><em>StructureSize</em></p>
<p>Pointer to the variable describing size of the input buffer.</p>
<p><em>PlatformInformationRecord</em></p>
<p>Pointer to the <strong>EFI_SEC_PLATFORM_INFORMATION_RECORD</strong>. Type
<strong>EFI_SEC_PLATFORM_INFORMATION_RECORD</strong> is defined in “Related
Definitions” below.</p>
<p><strong>Description</strong></p>
<p>This service is published by the SEC phase. The SEC phase handoff
has an optional</p>
<p><strong>EFI_PEI_PPI_DESCRIPTOR</strong> list as its final argument when
control is passed from SEC into the PEI Foundation. As such, if the
platform supports the built-in self test (BIST) on IA-32 Intel
architecture or the PAL-A handoff state for Itanium<sup>®</sup>
architecture, this information is encapsulated into the data
structure abstracted by this service. This information is collected
for the boot-strap processor (BSP) on IA-32, and for Itanium
architecture, it is available on all processors that execute the PEI
Foundation.</p>
<p>The motivation for this service is that a specific processor
register contains this information for each microarchitecture, but
the PEI CIS avoids using specific processor registers. Instead, the
PEI CIS describes callable interfaces across which data is conveyed.
As such, this processor state information that is collected at the
reset of the machine is mapped into a common interface. The
expectation is that a manageability agent, such as a platform PEIM
that logs information for the platform, would use this interface to
determine the viability of the BSP and possibly select an alternate
BSP if there are significant errors.</p>
</div></blockquote>
<p><strong>Related Definitions</strong></p>
<blockquote>
<div><p><strong>//******************************************************</strong></p>
<p><strong>// EFI_SEC_PLATFORM_INFORMATION_RECORD</strong></p>
<p><strong>//******************************************************</strong></p>
<p><strong>typedef union {</strong></p>
<p><strong>IA32_HANDOFF_STATUS</strong> <em>IA32HealthFlags</em><a href="#id196"><span class="problematic" id="id197">**</span></a>; **</p>
<p><strong>X64_HANDOFF_STATUS</strong> <em>x64HealthFlags</em><a href="#id198"><span class="problematic" id="id199">**</span></a>; **</p>
<p><strong>ITANIUM_HANDOFF_STATUS</strong> <em>ItaniumHealthFlags</em><strong>;</strong></p>
<p><strong>} EFI_SEC_PLATFORM_INFORMATION_RECORD;</strong></p>
<p><em>HealthFlags</em></p>
<p>Contains information generated by microcode, or hardware, about the
state of the processor upon reset. Type <strong>EFI_HEALTH_FLAGS</strong> is
defined below.</p>
<p><strong>//******************************************************</strong></p>
<p><strong>// EFI_HEALTH_FLAGS</strong></p>
<p><strong>//******************************************************</strong></p>
<p><strong>typedef union { struct {</strong></p>
<p><strong>UINT32</strong> <em>Status</em> <strong>: 2;</strong></p>
<p><strong>UINT32</strong> <em>Tested</em> <strong>: 1; UINT32</strong> <em>Reserved1</em> <strong>:13; UINT32</strong>
<em>VirtualMemoryUnavailable</em> <strong>: 1;</strong></p>
<p><strong>UINT32</strong> <em>Ia32ExecutionUnavailable</em> <strong>: 1;</strong></p>
<p><strong>UINT32</strong> <em>FloatingPointUnavailable</em> <strong>: 1;</strong></p>
<p><strong>UINT32</strong> <em>MiscFeaturesUnavailable</em> <strong>: 1; UINT32</strong> <em>Reserved2</em>
<strong>:12;</strong></p>
<p><strong>}</strong> <em>Bits;</em></p>
<p><strong>UINT32</strong> <em>Uint32;</em></p>
<p><strong>} EFI_HEALTH_FLAGS;</strong></p>
<p>IA-32 and X64 have the BIST. See <em>“Health Flag Bit Format” on page
229</em> for more information on</p>
<p><strong>EFI_HEALTH_FLAGS</strong>.</p>
<p>The following two structures are for IA32 and x64.</p>
<p><a href="#id200"><span class="problematic" id="id201">**</span></a>typedef EFI_HEALTH_FLAGS X64_HANDOFF_STATUS; typedef
EFI_HEALTH_FLAGS IA32_HANDOFF_STATUS; **</p>
<p>There is no instance of an
<strong>EFI_SEC_PLATFORM_INFORMATION_RECORD</strong> for the ARM PI binding.</p>
<p>For Itanium, the structure is as follows:</p>
<p>For details, see the <em>Itanium Software Developers Manual</em>, Volume 2,
Rev 2.2, Document Number: 245318-005 (SwDevMan) Section 11.2.2.1
“Definition of <strong>SALE_ENTRY</strong> State Parameter” as indicated below.</p>
<p><strong>typedef struct {</strong></p>
<p><a href="#id202"><span class="problematic" id="id203">**</span></a>UINT8 BootPhase; // SALE_ENTRY state : 3 = Recovery_Check **</p>
<p><a href="#id204"><span class="problematic" id="id205">**</span></a>// and 0 = RESET or Normal_Boot phase. **</p>
<p><a href="#id206"><span class="problematic" id="id207">**</span></a>// See ‘function’ in SwDevMan Fig 11-8 and **</p>
<p><a href="#id208"><span class="problematic" id="id209">**</span></a>// Table 11-3. **</p>
<p><strong>UINT8 FWStatus; // Firmware status on entry to SALE.</strong></p>
<p><a href="#id210"><span class="problematic" id="id211">**</span></a>// See ‘Status’ in SwDevMan Fig 11-8 and **</p>
<p><strong>// Table 11-4.</strong></p>
<p><strong>UINT16 Reserved1;</strong></p>
<p><strong>UINT32 Reserved2;</strong></p>
<p><a href="#id212"><span class="problematic" id="id213">**</span></a>UINT16 ProcId; // Geographically significant unique **</p>
<p><strong>// processor ID assigned by PAL.</strong></p>
<p><strong>// See ‘proc_id’ in SwDevMan Fig 11-9</strong></p>
<p><strong>// and Table 11-5.</strong></p>
<p><strong>UINT16 Reserved3;</strong></p>
<p><a href="#id214"><span class="problematic" id="id215">**</span></a>UINT8 IdMask; // See ‘id_mask’ in SwDevMan **</p>
<p><strong>// Fig 11-9 and Table 11-5.</strong></p>
<p><a href="#id216"><span class="problematic" id="id217">**</span></a>UINT8 EidMask; // See ‘eid_mask’ in SwDevMan **</p>
<p><strong>// Fig 11-9 and Table 11-5</strong></p>
<p><strong>UINT16 Reserved4;</strong></p>
<p><strong>UINT64 PalCallAddress; // Address to make PAL calls.</strong></p>
<p><a href="#id218"><span class="problematic" id="id219">**</span></a>UINT64 PalSpecialAddress; // If the entry state is **</p>
<p><a href="#id220"><span class="problematic" id="id221">**</span></a>// RECOVERY_CHECK, this **</p>
<p><a href="#id222"><span class="problematic" id="id223">**</span></a>// contains the PAL_RESET **</p>
<p><a href="#id224"><span class="problematic" id="id225">**</span></a>// return address, and if entry **</p>
<p><a href="#id226"><span class="problematic" id="id227">**</span></a>// state is RESET, this contains **</p>
<p><strong>// address for PAL_authentication</strong></p>
<p><strong>// call.</strong></p>
<p><a href="#id228"><span class="problematic" id="id229">**</span></a>UINT64 SelfTestStatus; // GR35 from PALE_EXIT state, **</p>
<p><a href="#id230"><span class="problematic" id="id231">**</span></a>// See ‘Self Test State’ in // SwDevMan Fig 11-10 and **</p>
<p><strong>// Table 11-6.</strong></p>
<p><strong>UINT64 SelfTestControl; // GR37 from PALE_EXIT state:</strong></p>
<p><strong>// See ‘Self Test Control’ in</strong></p>
<p><strong>// SwDevMan Fig 11-11.</strong></p>
<p><strong>UINT64 MemoryBufferRequired; // See GR38 Reset Layout // in
SwDevMan Table 11-2.</strong></p>
<p><strong>} ITANIUM_HANDOFF_STATUS;</strong></p>
<p>Consult the <strong>PALE_RESET</strong> Exit State in Software Development
Manual for Itanium regarding an interpretation of these fields.</p>
</div></blockquote>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The data was successfully returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_BUFFER_TOO_SMALL</td>
<td>The buffer was too small. The current buffer size needed to hold the record is returned in <em>StructureSize</em>.</td>
</tr>
</tbody>
</table>
<p><strong>8.3.1.1 SEC Platform Information 2 PPI (Optional)</strong></p>
<p>July 2018 Version 1.7</p>
</div>
<div class="section" id="efi-sec-platform-information2-ppi-optional">
<h3>EFI_SEC_PLATFORM_INFORMATION2_PPI (Optional)<a class="headerlink" href="#efi-sec-platform-information2-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service is the primary handoff state into the PEI Foundation.
The Security (SEC) component creates the early, transitory memory
environment and also encapsulates knowledge of at least the location
of the Boot Firmware Volume (BFV).</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_SEC_PLATFORM_INFORMATION2_GUID \</strong></p>
<p><strong>{0x9e9f374b, 0x8f16, 0x4230,</strong></p>
<p><strong>{ 0x98, 0x24, 0x58, 0x46, 0xee, 0x76, 0x6a, 0x97}};</strong></p>
<p><strong>Prototype typedef struct _EFI_SEC_PLATFORM_INFORMATION2_PPI {
EFI_SEC_PLATFORM_INFORMATION2</strong> <em>PlatformInformation2</em><strong>;</strong></p>
<p><strong>} EFI_SEC_PLATFORM_INFORMATION2_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PlatformInformation2</em></p>
<p>Conveys state information out of the SEC phase into PEI for many
CPU’s. See the <strong>PlatformInformation2()</strong> function description.</p>
<p><strong>Description</strong></p>
<p>This service abstracts platform-specific information for many CPU’s.
It is the multi-processor equivalent of <em>PlatformInformation</em> for
implementations that synchronize some, if not all CPU’s in the SEC
phase.</p>
<p>July 2018</p>
</div></blockquote>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-sec-platform-information2-ppi-platforminformation2">
<h3>EFI_SEC_PLATFORM_INFORMATION2_PPI.PlatformInformation2()<a class="headerlink" href="#efi-sec-platform-information2-ppi-platforminformation2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This service is the single member of the
<strong>EFI_SEC_PLATFORM_INFORMATION2_PPI</strong> that conveys state
information out of the Security (SEC) phase into PEI.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_SEC_PLATFORM_INFORMATION2) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN OUT UINT64 *</strong><em>StructureSize</em><strong>,</strong></p>
<p><strong>OUT EFI_SEC_PLATFORM_INFORMATION_RECORD2</strong></p>
<p><strong>*</strong><em>PlatformInformationRecord2</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>Pointer to the PEI Services Table.</p>
<p><em>StructureSize</em></p>
<p>Pointer to the variable describing size of the input buffer.</p>
<p><em>PlatformInformationRecord2</em></p>
<p>Pointer to the <strong>EFI_SEC_PLATFORM_INFORMATION_RECORD2</strong>. Type
<strong>EFI_SEC_PLATFORM_INFORMATION_RECORD2</strong> is defined in “Related</p>
<p>Definitions” below.</p>
<p><strong>Description</strong></p>
<p>This service is published by the SEC phase.</p>
<p><strong>Related Definitions</strong></p>
<p><strong>//******************************************************</strong></p>
<p><strong>// EFI_SEC_PLATFORM_INFORMATION_RECORD2</strong></p>
<p><strong>//******************************************************</strong></p>
<p><strong>typedef struct {</strong></p>
<p><strong>UINT32</strong> <em>CpuLocation</em><strong>;</strong></p>
<p><strong>EFI_SEC_PLATFORM_INFORMATION_RECORD</strong> <em>InfoRecord</em><strong>;</strong></p>
<p><strong>} EFI_SEC_PLATFORM_INFORMATION_CPU;</strong></p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><p><strong>typedef struct {</strong></p>
<p><strong>UINT32</strong> <em>NumberOfCpus</em><strong>.</strong></p>
<p><strong>EFI_SEC_PLATFORM_INFORMATION_CPU</strong> <em>CpuInstance</em> <strong>[1];</strong></p>
<p><strong>} EFI_SEC_PLATFORM_INFORMATION_RECORD2;</strong></p>
<p>The CPU location would be the local API ID.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The data was successfully returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_BUFFER_TOO_SMALL</td>
<td>The buffer was too small. The current buffer size needed to hold the record is returned in <em>StructureSize</em>.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
<p><strong>8.3.2 Loaded Image PPI (Optional)</strong></p>
</div>
<div class="section" id="efi-pei-loaded-image-ppi">
<h3>EFI_PEI_LOADED_IMAGE_PPI<a class="headerlink" href="#efi-pei-loaded-image-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Notifies other drivers of the PEIM being initialized by the PEI
Dispatcher.</p>
<p><strong>GUID</strong></p>
<p><a href="#id232"><span class="problematic" id="id233">**</span></a>#define EFI_PEI_LOADED_IMAGE_PPI_GUID \ **</p>
<p><a href="#id234"><span class="problematic" id="id235">**</span></a>{ 0xc1fcd448, 0x6300, 0x4458, \ **</p>
<p><strong>0xb8, 0x64, 0x28, 0xdf, 0x1, 0x53, 0x64, 0xbc }</strong></p>
<p><strong>Prototype typedef struct _EFI_PEI_LOADED_IMAGE_PPI {</strong></p>
<p><strong>EFI_PHYSICAL_ADDRESS</strong> <em>ImageAddress,</em></p>
<p><strong>UINT64</strong> <em>ImageSize,</em></p>
<p><strong>EFI_PEI_FILE_HANDLE</strong> <em>FileHandle</em></p>
<p><strong>} EFI_PEI_LOADED_IMAGE_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>ImageAddress</em></p>
<p>Address of the image at the address where it will be executed.</p>
<p><em>ImageSize</em></p>
<p>Size of the image as it will be executed.</p>
<p><em>FileHandle</em></p>
<p>File handle from which the image was loaded. Can be NULL, indicating
the image was not loaded from a handle.</p>
<p><strong>Description</strong></p>
<p>This interface is installed by the PEI Dispatcher after the image
has been loaded and after all security checks have been performed,
to notify other PEIMs of the files which are being loaded.</p>
</div></blockquote>
<p><strong>*Note:</strong> The same PEIM may be initialized twice.*</p>
<p><strong>8.3.3 SEC HOB PPI</strong></p>
</div>
<div class="section" id="efi-sec-hob-data-ppi">
<h3>EFI_SEC_HOB_DATA_PPI<a class="headerlink" href="#efi-sec-hob-data-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI allows the SEC code to install HOBs into the HOB list.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><p><strong>GUID</strong></p>
<p><strong>#define EFI_SEC_HOB_DATA_PPI_GUID \</strong></p>
<p><strong>{0x3ebdaf20, 0x6667, 0x40d8,\</strong></p>
<p><strong>{0xb4, 0xee, 0xf5, 0x99, 0x9a, 0xc1, 0xb7, 0x1f}};</strong></p>
<p><a href="#id236"><span class="problematic" id="id237">**</span></a>Protocol Interface Structure typedef struct
_EFI_SEC_HOB_DATA_PPI { **</p>
<p><strong>EFI_SEC_HOB_DATA_GET</strong> <em>GetHobs</em><strong>;</strong></p>
<p><strong>} EFI_SEC_HOB_DATA_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>GetHobs</em></p>
<p>Retrieves a list of HOBs to install into the PEI HOB list.</p>
<p><strong>Description</strong></p>
<p>This PPI provides a way for the SEC code to pass zero or more HOBs
in a HOB list.</p>
</div></blockquote>
<p>Version 1.7 July 2018</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-sec-hob-data-ppi-gethobs">
<h3>EFI_SEC_HOB_DATA_PPI.GetHobs()<a class="headerlink" href="#efi-sec-hob-data-ppi-gethobs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Return a pointer to a buffer containing zero or more HOBs that will
be installed into the PEI HOB List.</p>
<p><strong>Prototype</strong></p>
<p><strong>EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_SEC_HOB_DATA_GET) (</strong></p>
<p><strong>IN CONST EFI_SEC_HOB_DATA_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>OUT EFI_HOB_GENERIC_HEADER **</strong><em>HobList</em> <strong>);</strong></p>
<p><strong>Parameters</strong> <em>This</em></p>
<p>Pointer to this PPI structure.</p>
<p><em>HobList</em></p>
<p>A pointer to a returned pointer to zero or more HOBs. If no HOBs are
to be returned, then the returned pointer is a pointer to a HOB of
type</p>
<p><strong>EFI_HOB_TYPE_END_OF_HOB_LIST</strong>.</p>
<p><strong>Description</strong></p>
<p>This function returns a pointer to a pointer to zero or more HOBs,
terminated with a HOB of type</p>
<p><strong>EI_HOB_TYPE_END_OF_HOB_LIST</strong>.</p>
</div></blockquote>
<p><strong>*Note:</strong> The HobList must not contain a*
<strong>EFI_HOB_HANDOFF_INFO_TABLE</strong> <a href="#id238"><span class="problematic" id="id239">*</span></a>HOB (PHIT) HOB. *</p>
<p><strong>*Note:</strong> The HOBs pointed to by HobList must be formed as described in
section 4.5.2 of Volume 3, “HOB Construction Rules” including the
requirement that the list start on an 8-byte boundary.*</p>
<blockquote>
<div><strong>Status Codes</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">This function completed successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_UNSUPPORTED</td>
<td>No HOBS are available.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="recovery">
<h3>8.3.4 Recovery<a class="headerlink" href="#recovery" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>This section contains the definitions of the PPIs that are required
on platforms that support firmware recovery. The table below
explains the organization of this section and lists the PPIs that
are defined in this section.</div></blockquote>
<p>July 2018 Version 1.7</p>
<blockquote>
<div><strong>Table 17. Organization of the Code Definitions Section</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="74%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Section</th>
<th class="head">Summary</th>
<th class="head">PPI Definition</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><p class="first">Recovery Module</p>
<p class="last">PPI</p>
</td>
<td>Describes the main Recovery Module PPI<em>.</em></td>
<td>EFI_PEI_RECOVERY_MODULE_PPI</td>
</tr>
<tr class="row-odd"><td><p class="first">Device Recovery</p>
<p class="last">Module PPI</p>
</td>
<td>Describes the Device Recovery Module PPI.</td>
<td>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</td>
</tr>
<tr class="row-even"><td><p class="first">Device Recovery</p>
<p class="last">Block I/O PPI</p>
</td>
<td><p class="first">Describes the Device Recovery Block I/O PPI. This section is device specific and addresses the most common form of recovery media—block I/O devices such as legacy floppy, CD-ROM, or</p>
<p class="last">IDE devices.</p>
</td>
<td>EFI_PEI_RECOVERY_BLOCK_IO_PPI</td>
</tr>
</tbody>
</table>
<blockquote>
<div>This section also contains the definitions for additional data types
and structures that are subordinate to the structures in which they
are called. The following types or structures can be found in
“Related Definitions” of the parent protocol or function definition:</div></blockquote>
<ul class="simple">
<li><a href="#id240"><span class="problematic" id="id241">**</span></a>EFI_PEI_BLOCK_IO_MEDIA **</li>
<li><a href="#id242"><span class="problematic" id="id243">**</span></a>EFI_PEI_BLOCK_DEVICE_TYPE **</li>
<li><strong>EFI_PEI_LBA</strong></li>
</ul>
<p><strong>8.3.4.1 Recovery Module PPI</strong></p>
</div>
<div class="section" id="efi-pei-recovery-module-ppi">
<h3>EFI_PEI_RECOVERY_MODULE_PPI<a class="headerlink" href="#efi-pei-recovery-module-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Finds and loads the recovery files.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_RECOVERY_MODULE_PPI_GUID \</strong></p>
<p><strong>{0xFB6D9542, 0x612D, 0x4f45, 0x87, 0x2F, 0x5C, \</strong></p>
<p><strong>0xFF, 0x52, 0xE9, 0x3D, 0xCF}</strong></p>
<p><strong>PPI Interface Structure typedef struct
_EFI_PEI_RECOVERY_MODULE_PPI {</strong></p>
<p><strong>EFI_PEI_LOAD_RECOVERY_CAPSULE</strong> <em>LoadRecoveryCapsule</em><strong>;</strong></p>
<p><strong>} EFI_PEI_RECOVERY_MODULE_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>LoadRecoveryCapsule</em></p>
<p>Loads a DXE binary capsule into memory.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div>This module has many roles and is responsible for the following:</div></blockquote>
<ol class="arabic">
<li><p class="first">Calling the driver recovery PPI</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.GetNumberRecoveryCapsules()</strong>
to determine if one or more DXE recovery entities exist.</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">If no capsules exist, then performing appropriate error handling.</p>
</li>
<li><p class="first">Allocating a buffer of <em>MaxRecoveryCapsuleSize</em> as determined by</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</strong>.<strong>GetRecoveryCapsuleInfo()</strong>
or larger.</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">Determining the policy in which DXE recovery capsules are loaded.</p>
</li>
<li><p class="first">Calling the driver recovery PPI</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()</strong>
for capsule number x.</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">If the load failed, performing appropriate error handling.</p>
</li>
<li><p class="first">Performing security checks for a loaded DXE recovery capsule.</p>
</li>
<li><p class="first">If the security checks failed, then logging the failure in a data
HOB.</p>
</li>
<li><p class="first">If the security checks failed, then determining the next</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()</strong>capsule
number; otherwise, go to step 11.</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">If more DXE recovery capsules exist, then go to step 5; otherwise,
perform error handling.</p>
</li>
<li><p class="first">Decomposing the capsule loaded by</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()</strong>
into its components. It is assumed that the path parameters are
redundant for recovery and Setup parameters are either redundant or
canned.</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic simple">
<li>Invalidating all HOB entries for updateable firmware volume entries.
This invalidation prevents possible errant drivers from being
executed.</li>
<li>Updating the HOB table with the recovery DXE firmware volume
information generated from the capsule decomposition.</li>
<li>Returning to the PEI Dispatcher.</li>
</ol>
</div>
<div class="section" id="efi-pei-recovery-module-ppi-loadrecoverycapsule">
<h3>EFI_PEI_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()<a class="headerlink" href="#efi-pei-recovery-module-ppi-loadrecoverycapsule" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Loads a DXE capsule from some media into memory and updates the HOB
table with the DXE firmware volume information.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_LOAD_RECOVERY_CAPSULE) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN struct _EFI_PEI_RECOVERY_MODULE_PPI *</strong><em>This</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type
<strong>EFI_PEI_SERVICES</strong> is defined in <strong>section 3.2.1</strong>.</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_RECOVERY_MODULE_PPI</strong> instance.
<em>Description</em></p>
<p>This function, by whatever mechanism, retrieves a DXE capsule from
some device and loads it into memory. Note that the published
interface is device neutral.</p>
<p><a href="#id244"><span class="problematic" id="id245">**</span></a>Status Codes Returned **</p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The capsule was loaded correctly.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>A device error occurred.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>A recovery DXE capsule cannot be found.</td>
</tr>
</tbody>
</table>
<p><strong>8.3.4.2 Device Recovery Module PPI</strong></p>
</div>
<div class="section" id="efi-pei-device-recovery-module-ppi">
<h3>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI<a class="headerlink" href="#efi-pei-device-recovery-module-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Presents a standard interface to
<strong>EFI_PEI_RECOVERY_MODULE_PPI</strong>, regardless of the underlying
device(s).</p>
</div></blockquote>
<p><strong>GUID</strong></p>
<blockquote>
<div><p><strong>#define EFI_PEI_DEVICE_RECOVERY_MODULE_PPI_GUID \</strong></p>
<p><strong>{ 0x0DE2CE25, 0x446A, 0x45a7, 0xBF, 0xC9, 0x37, 0xDA, \</strong></p>
<p><strong>0x26, 0x34, 0x4B, 0x37}</strong></p>
</div></blockquote>
<p><strong>PPI Interface Structure typedef struct
_EFI_PEI_DEVICE_RECOVERY_MODULE_PPI {</strong></p>
<blockquote>
<div><p><a href="#id246"><span class="problematic" id="id247">**</span></a>EFI_PEI_DEVICE_GET_NUMBER_RECOVERY_CAPSULE **</p>
<p><em>GetNumberRecoveryCapsules</em><strong>;</strong></p>
<p><a href="#id248"><span class="problematic" id="id249">**</span></a>EFI_PEI_DEVICE_GET_RECOVERY_CAPSULE_INFO **</p>
<p><em>GetRecoveryCapsuleInfo</em><strong>;</strong></p>
<p><a href="#id250"><span class="problematic" id="id251">**</span></a>EFI_PEI_DEVICE_LOAD_RECOVERY_CAPSULE **</p>
<p><em>LoadRecoveryCapsule</em><strong>;</strong></p>
<p><strong>} EFI_PEI_DEVICE_RECOVERY_MODULE_PPI;</strong></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><em>GetNumberRecoveryCapsules</em></p>
<p>Returns the number of DXE capsules that were found. See the
<strong>GetNumberRecoveryCapsules()</strong> function description.
<em>GetRecoveryCapsuleInfo</em></p>
<p>Returns the capsule image type and the size of a given image. See
the <strong>GetRecoveryCapsuleInfo()</strong> function description.</p>
<p><em>LoadRecoveryCapsule</em></p>
<p>Loads a DXE capsule into memory. See the <strong>LoadRecoveryCapsule()</strong>
function description.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The role of this module is to present a standard interface to</p>
<p><strong>EFI_PEI_RECOVERY_MODULE_PPI</strong>, regardless of the underlying
device(s). The interface does the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Reports the number of recovery DXE capsules that exist on the
associated device(s)</p>
</li>
<li><p class="first">Finds the requested firmware binary capsule</p>
</li>
<li><p class="first">Loads that capsule into memory</p>
<blockquote>
<div><p>A device can be either a group of devices, such as a block device,
or an individual device. The module determines the internal search
order, with capsule number 1 as the highest load priority and number
N as the lowest priority.</p>
</div></blockquote>
</li>
</ul>
<p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.</strong></p>
</div>
<div class="section" id="getnumberrecoverycapsules">
<h3>GetNumberRecoveryCapsules()<a class="headerlink" href="#getnumberrecoverycapsules" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Returns the number of DXE capsules residing on the device.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_DEVICE_GET_NUMBER_RECOVERY_CAPSULE) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN struct _EFI_PEI_DEVICE_RECOVERY_MODULE_PPI
*</strong><em>This</em><strong>,</strong></p>
<p><strong>OUT UINTN *</strong><em>NumberRecoveryCapsules</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type
<strong>EFI_PEI_SERVICES</strong> is defined in <strong>section 3.2.1</strong>.</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</strong> instance.</p>
<p><em>NumberRecoveryCapsules</em></p>
<p>Pointer to a caller-allocated <strong>UINTN</strong>. On output,
<em>*NumberRecoveryCapsules</em> contains the number of recovery capsule
images available for retrieval from this PEIM instance.</p>
<p><strong>Description</strong></p>
<p>This function, by whatever mechanism, searches for DXE capsules from
the associated device and returns the number and maximum size in
bytes of the capsules discovered. Entry 1 is assumed to be the
highest load priority and entry N is assumed to be the lowest
priority.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">One or more capsules were discovered.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>A device error occurred.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>A recovery DXE capsule cannot be found.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-pei-device-recovery-module-ppi-getrecoverycapsuleinfo">
<h3>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI. GetRecoveryCapsuleInfo()<a class="headerlink" href="#efi-pei-device-recovery-module-ppi-getrecoverycapsuleinfo" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Returns the size and type of the requested recovery capsule.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_DEVICE_GET_RECOVERY_CAPSULE_INFO) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN struct _EFI_PEI_DEVICE_RECOVERY_MODULE_PPI
*</strong><em>This</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>CapsuleInstance</em><strong>,</strong></p>
<p><strong>OUT UINTN *</strong><em>Size</em><strong>,</strong></p>
<p><strong>OUT EFI_GUID *</strong><em>CapsuleType</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type
<strong>EFI_PEI_SERVICES</strong> is defined in <strong>section 3.2.1</strong>.</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</strong> instance.</p>
<p><em>CapsuleInstance</em></p>
<p>Specifies for which capsule instance to retrieve the information.
This parameter must be between one and the value returned by
<strong>GetNumberRecoveryCapsules()</strong> in <em>NumberRecoveryCapsules</em>.</p>
<p><em>Size</em></p>
<p>A pointer to a caller-allocated <strong>UINTN</strong> in which the size of the
requested recovery module is returned.</p>
<p><em>CapsuleType</em></p>
<p>A pointer to a caller-allocated <strong>EFI_GUID</strong> in which the type of
the requested recovery capsule is returned. The semantic meaning of
the value returned is defined by the implementation. Type
<strong>EFI_GUID</strong> is defined in</p>
<p><strong>InstallProtocolInterface()</strong> in the <em>EFI 1.10 Specification</em>.</p>
<p><strong>Description</strong></p>
<p>This function returns the size and type of the capsule specified by
CapsuleInstance.</p>
</div></blockquote>
<p><strong>Status Codes Returned</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">One or more capsules were discovered.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>A device error occurred.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>A recovery DXE capsule cannot be found.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-pei-device-recovery-module-ppi-loadrecoverycapsule">
<h3>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI. LoadRecoveryCapsule()<a class="headerlink" href="#efi-pei-device-recovery-module-ppi-loadrecoverycapsule" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Loads a DXE capsule from some media into memory.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_DEVICE_LOAD_RECOVERY_CAPSULE) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN struct _EFI_PEI_DEVICE_RECOVERY_MODULE_PPI
*</strong><em>This</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>CapsuleInstance</em><strong>,</strong></p>
<p><strong>OUT VOID *</strong><em>Buffer</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type
<strong>EFI_PEI_SERVICES</strong> is defined in <strong>section 3.2.1.</strong></p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</strong> instance.
<em>CapsuleInstance</em></p>
<p>Specifies which capsule instance to retrieve.</p>
<p><em>Buffer</em></p>
<p>Specifies a caller-allocated buffer in which the requested recovery
capsule will be returned.</p>
<p><strong>Description</strong></p>
<p>This function, by whatever mechanism, retrieves a DXE capsule from
some device and loads it into memory. Note that the published
interface is device neutral.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The capsule was loaded correctly.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>A device error occurred.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>The requested recovery DXE capsule cannot be found.</td>
</tr>
</tbody>
</table>
<div class="section" id="device-recovery-block-i-o-ppi">
<h4>8.3.4.3 Device Recovery Block I/O PPI<a class="headerlink" href="#device-recovery-block-i-o-ppi" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The Recovery Module PPI and the Device Recovery Module PPI
subsections earlier in Code Definitions are device neutral. This
section is device specific and addresses the most common form of
recovery media-block I/O devices such as legacy floppy, CD-ROM, or
IDE devices.</p>
<p>The Recovery Block I/O PPI is used to access block devices. Because
the Recovery Block I/O PPIs that are provided by the PEI ATAPI
driver and PEI legacy floppy driver are the same, here we define a
set of general PPIs for both drivers to use.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="efi-pei-recovery-block-io-ppi">
<h3>EFI_PEI_RECOVERY_BLOCK_IO_PPI<a class="headerlink" href="#efi-pei-recovery-block-io-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Provides the services required to access a block I/O device during
PEI recovery boot mode.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_RECOVERY_BLOCK_IO_PPI_GUID \</strong></p>
<p><strong>{ 0x695d8aa1, 0x42ee, 0x4c46, 0x80, 0x5c,0x6e, 0xa6, \</strong></p>
<p><strong>0xbc, 0xe7, 0x99, 0xe3 }</strong></p>
<p><strong>PPI Interface Structure typedef struct
_EFI_PEI_RECOVERY_BLOCK_IO_PPI {</strong></p>
<p><strong>EFI_PEI_GET_NUMBER_BLOCK_DEVICES</strong>
<em>GetNumberOfBlockDevices</em><strong>;</strong></p>
<p><a href="#id252"><span class="problematic" id="id253">**</span></a>EFI_PEI_GET_DEVICE_MEDIA_INFORMATION **</p>
<p><em>GetBlockDeviceMediaInfo</em><strong>;</strong></p>
<p><strong>EFI_PEI_READ_BLOCKS</strong> <em>ReadBlocks</em><strong>;</strong></p>
<p><strong>} EFI_PEI_RECOVERY_BLOCK_IO_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>GetNumberOfBlockDevices</em></p>
<p>Gets the number of block I/O devices that the specific block driver
manages. See the <strong>GetNumberOfBlockDevices()</strong>function
description.</p>
<p><em>GetBlockDeviceMediaInfo</em></p>
<p>Gets the specified media information. See the
<strong>GetBlockDeviceMediaInfo()</strong> function description.</p>
<p><em>ReadBlocks</em></p>
<p>Reads the requested number of blocks from the specified block
device. See the <strong>ReadBlocks()</strong> function description.</p>
<p><strong>Description</strong></p>
<p>This function provides the services that are required to access a
block I/O device during PEI recovery boot mode.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-recovery-block-io-ppi-getnumberofblockdevices">
<h3>EFI_PEI_RECOVERY_BLOCK_IO_PPI. GetNumberOfBlockDevices()<a class="headerlink" href="#efi-pei-recovery-block-io-ppi-getnumberofblockdevices" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><a href="#id254"><span class="problematic" id="id255">**</span></a>Summary **</p>
<p>Gets the count of block I/O devices that one specific block driver
detects.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GET_NUMBER_BLOCK_DEVICES) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN struct _EFI_PEI_RECOVERY_BLOCK_IO_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>OUT UINTN *</strong><em>NumberBlockDevices</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type
<strong>EFI_PEI_SERVICES</strong> is defined in <strong>section 3.2.1</strong>.</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_RECOVERY_BLOCK_IO_PPI</strong> instance.
<em>NumberBlockDevices</em></p>
<p>The number of block I/O devices discovered.</p>
<p><strong>Description</strong></p>
<p>This function is used for getting the count of block I/O devices
that one specific block driver detects. To the PEI ATAPI driver, it
returns the number of all the detected ATAPI devices it detects
during the enumeration process. To the PEI legacy floppy driver, it
returns the number of all the legacy devices it finds during its
enumeration process. If no device is detected, then the function
will return zero.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EFI_SUCCESS</td>
<td>Operation performed successfully</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-pei-recovery-block-io-ppi-getblockdevicemediainfo">
<h3>EFI_PEI_RECOVERY_BLOCK_IO_PPI.GetBlockDeviceMediaInfo()<a class="headerlink" href="#efi-pei-recovery-block-io-ppi-getblockdevicemediainfo" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Gets a block device’s media information.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GET_DEVICE_MEDIA_INFORMATION) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN struct _EFI_PEI_RECOVERY_BLOCK_IO_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>DeviceIndex</em><strong>,</strong></p>
<p><strong>OUT EFI_PEI_BLOCK_IO_MEDIA *</strong><em>MediaInfo</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type
<strong>EFI_PEI_SERVICES</strong> is defined in <strong>section 3.2.1</strong>.</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_RECOVERY_BLOCK_IO_PPI</strong> instance.
<em>DeviceIndex</em></p>
<p>Specifies the block device to which the function wants to talk.
Because the driver that implements Block I/O PPIs will manage
multiple block devices, the PPIs that want to talk to a single
device must specify the device index that was assigned during the
enumeration process. This index is a number from one to
<em>NumberBlockDevices</em>. <em>MediaInfo</em></p>
<p>The media information of the specified block media. Type</p>
<p><strong>EFI_PEI_BLOCK_IO_MEDIA</strong> is defined in “Related Definitions”
below. The caller is responsible for the ownership of this data
structure.</p>
</div></blockquote>
<p><strong>*Note:</strong> This structure describes an enumeration of possible block
device types. This enumeration exists because no device paths are
actually passed across interfaces that describe the type or class of
hardware that is publishing the block I/O interface. This enumeration
will allow for policy decisions in the Recovery PEIM, such as “Try to
recover from legacy floppy first, LS-120 second, CD-ROM third.” If there
are multiple partitions abstracted by a given device type, they should
be reported in ascending order; this order also applies to nested
partitions, such as legacy MBR, where the outermost partitions would
have precedence in the reporting order. The same logic applies to
systems such as IDE that have precedence relationships like
“Master/Slave” or “Primary/ Secondary”; the master device should be
reported first, the slave second. *</p>
<blockquote>
<div><p><strong>Description</strong></p>
<p>This function will provide the caller with the specified block
device’s media information. If the media changes, calling this
function will update the media information accordingly.</p>
</div></blockquote>
<p><strong>Related Definitions</strong></p>
<blockquote>
<div><p><strong>//***************************************************</strong></p>
<p><strong>// EFI_PEI_BLOCK_IO_MEDIA</strong></p>
<p><strong>//***************************************************</strong></p>
<p><strong>typedef struct {</strong></p>
<p><strong>EFI_PEI_BLOCK_DEVICE_TYPE</strong> <em>DeviceType</em><strong>;</strong></p>
<p><strong>BOOLEAN</strong> <em>MediaPresent</em><strong>; UINTN</strong> <em>LastBlock</em><strong>;</strong></p>
<p><strong>UINTN</strong> <em>BlockSize</em><strong>;</strong></p>
<p><strong>} PEI_BLOCK_IO_MEDIA;</strong></p>
<p><em>DevType</em></p>
<p>The type of media device being referenced by DeviceIndex. Type
<strong>EFI_PEI_BLOCK_DEVICE_TYPE</strong> is defined below. <em>MediaPresent</em></p>
<p>A flag that indicates if media is present. This flag is always set
for nonremovable media devices.</p>
<p><em>LastBlock</em></p>
<p>The last logical block that the device supports.</p>
<p><em>BlockSize</em></p>
<p>The size of a logical block in bytes.</p>
<p><strong>//***********************************************************</strong></p>
<p><strong>// EFI_PEI_BLOCK_DEVICE_TYPE</strong></p>
<p><strong>//***********************************************************
typedef enum { LegacyFloppy = 0,</strong></p>
<p><strong>IdeCDROM = 1,</strong></p>
<p><strong>IdeLS120 = 2,</strong></p>
<p><strong>UsbMassStorage = 3,</strong></p>
<p><strong>SD = 4,</strong></p>
<p><strong>EMMC = 5,</strong></p>
<p><strong>UfsDevice = 6,</strong></p>
<p><strong>MaxDeviceType</strong></p>
<p><strong>} EFI_PEI_BLOCK_DEVICE_TYPE;</strong></p>
</div></blockquote>
<p><strong>Status Codes Returned</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">Media information about the specified block device was obtained successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>Cannot get the media information due to a hardware error.</td>
</tr>
</tbody>
</table>
<blockquote>
<div>EFI_PEI_RECOVERY_BLOCK_IO_PPI.ReadBlocks()</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Reads the requested number of blocks from the specified block
device.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_READ_BLOCKS) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN struct _EFI_PEI_RECOVERY_BLOCK_IO_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>DeviceIndex</em><strong>,</strong></p>
<p><strong>IN EFI_PEI_LBA</strong> <em>StartLBA</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>BufferSize</em><strong>,</strong></p>
<p><strong>OUT VOID *</strong><em>Buffer</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type
<strong>EFI_PEI_SERVICES</strong> is defined in <strong>section 3.2.1</strong>.</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_RECOVERY_BLOCK_IO_PPI</strong> instance.</p>
<p><em>DeviceIndex</em></p>
<p>Specifies the block device to which the function wants to talk.
Because the driver that implements Block I/O PPIs will manage
multiple block devices, the PPIs that want to talk to a single
device must specify the device index that was assigned during the
enumeration process. This index is a number from one to
<em>NumberBlockDevices</em>. <em>StartLBA</em></p>
<p>The starting logical block address (LBA) to read from on the device.
Type <strong>EFI_PEI_LBA</strong> is defined in “Related Definitions” below.</p>
<p><em>BufferSize</em></p>
<p>The size of the <em>Buffer</em> in bytes. This number must be a multiple of
the intrinsic block size of the device.</p>
<p><strong>Buffer</strong></p>
<p>A pointer to the destination buffer for the data. The caller is
responsible for the ownership of the buffer.</p>
<p><strong>Description</strong></p>
<p>The function reads the requested number of blocks from the device.
All the blocks are read, or an error is returned. If there is no
media in the device, the function returns <strong>EFI_NO_MEDIA</strong>.</p>
<p><a href="#id256"><span class="problematic" id="id257">**</span></a>Related Definitions **</p>
</div></blockquote>
<p><strong>//*****************************************************</strong></p>
<blockquote>
<div><p><strong>// EFI_PEI_LBA</strong></p>
<p><strong>//*****************************************************
typedef UINT64 EFI_PEI_LBA;</strong></p>
<p><strong>EFI_PEI_LBA</strong> is the <strong>UINT64</strong> LBA number.</p>
<p><a href="#id258"><span class="problematic" id="id259">**</span></a>Status Codes Returned **</p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The data was read correctly from the device.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>The device reported an error while attempting to perform the read operation.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td>The read request contains LBAs that are not valid, or the buffer is not properly aligned.</td>
</tr>
<tr class="row-even"><td>EFI_NO_MEDIA</td>
<td>There is no media in the device.</td>
</tr>
<tr class="row-odd"><td>EFI_BAD_BUFFER_SIZE</td>
<td>The <em>BufferSize</em> parameter is not a multiple of the intrinsic block size of the device.</td>
</tr>
</tbody>
</table>
<p><strong>8.3.5 EFI PEI Recovery Block IO2 PPI</strong></p>
</div>
<div class="section" id="efi-pei-recovery-block-io2-ppi">
<h3>EFI_PEI_RECOVERY_BLOCK_IO2_PPI<a class="headerlink" href="#efi-pei-recovery-block-io2-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Provides the services required to access a block I/O device during
PEI recovery boot mode.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_RECOVERY_BLOCK_IO2_PPI_GUID \</strong></p>
<p><strong>{ 0x26cc0fad, 0xbeb3, 0x478a,\</strong></p>
<p><strong>{ 0x91, 0xb2, 0xc, 0x18, 0x8f, 0x72, 0x61, 0x98 } }</strong></p>
<p><strong>PPI Interface Structure typedef struct
_EFI_PEI_RECOVERY_BLOCK_IO2_PPI {</strong></p>
<p><strong>UINT64</strong> <em>Revision;</em></p>
<p><strong>EFI_PEI_GET_NUMBER_BLOCK_DEVICES2</strong>
<em>GetNumberOfBlockDevices*</em>;***</p>
<p><a href="#id260"><span class="problematic" id="id261">**</span></a>EFI_PEI_GET_DEVICE_MEDIA_INFORMATION2 **</p>
<p><em>GetBlockDeviceMediaInfo;</em></p>
<p><strong>EFI_PEI_READ_BLOCKS2</strong> <em>ReadBlocks;</em></p>
<p><strong>} EFI_PEI_RECOVERY_BLOCK_IO2_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Revision</em></p>
<p>The revision to which the interface adheres. All future revisions
must be backwards compatible.</p>
<p><em>GetNumberOfBlockDevices</em></p>
<p>Gets the number of block I/O devices that the specific block driver
manages. See the <strong>GetNumberOfBlockDevices()</strong> function description.</p>
<p><em>GetBlockDeviceMediaInfo</em></p>
<p>Gets the specified media information. See the
<strong>GetBlockDeviceMediaInfo()</strong> function description.</p>
<p><em>ReadBlocks</em></p>
<p>Reads the requested number of blocks from the specified block
device. See the <strong>ReadBlocks()</strong> function description.</p>
<p><strong>Related Definitions</strong></p>
<p><strong>#define EFI_PEI_RECOVERY_BLOCK_IO2_PPI_REVISION 0x00010000</strong></p>
<p><strong>Description</strong></p>
<p>This function provides the services that are required to access a
block I/O device during PEI recovery boot mode.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-recovery-block-io2-ppi-getnumberofblockdevices">
<h3>EFI_PEI_RECOVERY_BLOCK_IO2_PPI.GetNumberOfBlockDevices()<a class="headerlink" href="#efi-pei-recovery-block-io2-ppi-getnumberofblockdevices" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Gets the count of block I/O devices that one specific block driver
detects.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GET_NUMBER_BLOCK_DEVICES2) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_PEI_RECOVERY_BLOCK_IO2_PPI</strong> <em>*This,</em></p>
<p><strong>OUT UINTN</strong> <em>*NumberBlockDevices</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type</p>
<p><strong>EFI_PEI_SERVICES</strong> is defined in the <em>Intel® Platform Innovation
Framework for EFI Pre-EFI Initialization Core Interface
Specification</em> (PEI CIS).</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_RECOVERY_BLOCK_IO_PPI</strong> instance.
<em>NumberBlockDevices</em></p>
<p>The number of block I/O devices discovered.</p>
<p><strong>Description</strong></p>
<p>This function is used for getting the count of block I/O devices
that one specific block driver detects. To the PEI ATAPI driver, it
returns the number of all the detected ATAPI devices it detects
during the enumeration process. To the PEI legacy floppy driver, it
returns the number of all the legacy devices it finds during its
enumeration process. If no device is detected, then the function
will return zero.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>EFI_SUCCESS</td>
<td>Operation performed successfully</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-pei-recovery-block-io2-ppi-getblockdevicemediainfo">
<h3>EFI_PEI_RECOVERY_BLOCK_IO2_PPI.GetBlockDeviceMediaInfo()<a class="headerlink" href="#efi-pei-recovery-block-io2-ppi-getblockdevicemediainfo" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Gets a block device’s media information.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GET_DEVICE_MEDIA_INFORMATION2) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_PEI_RECOVERY_BLOCK_IO2_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINTN</strong> <em>DeviceIndex,</em></p>
<p><strong>OUT EFI_PEI_BLOCK_IO2_MEDIA</strong> <em>*MediaInfo</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type</p>
<p><strong>EFI_PEI_SERVICES</strong> is defined in the <em>Intel® Platform Innovation
Framework for EFI Pre-EFI Initialization Core Interface
Specification</em> (PEI CIS).</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_RECOVERY_BLOCK_IO_PPI</strong> instance.</p>
<p><em>DeviceIndex</em></p>
<p>Specifies the block device to which the function wants to talk.
Because the driver that implements Block I/O PPIs will manage
multiple block devices, the PPIs that want to talk to a single
device must specify the device index that was assigned during the
enumeration process. This index is a number from one to
<em>NumberBlockDevices</em>. <em>MediaInfo</em></p>
<p>The media information of the specified block media. Type</p>
<p><strong>EFI_PEI_BLOCK_IO2_MEDIA</strong> is defined in “Related Definitions”
below. The caller is responsible for the ownership of this data
structure.</p>
<p>Note that this structure describes an enumeration of possible block
device types. This enumeration exists because no device paths are
actually passed across interfaces that describe the type or class of
hardware that is publishing the block I/O interface. This
enumeration will allow for policy decisions in the Recovery PEIM,
such as “Try to recover from legacy floppy first, USB mass storage
device second, CD-ROM third.” If there are multiple partitions
abstracted by a given device type, they should be reported in
ascending order; this order also applies to nested partitions, such
as legacy MBR, where the outermost partitions would have precedence
in the reporting order.</p>
<p>The same logic applies to systems such as IDE that have precedence
relationships like “Master/Slave” or “Primary/Secondary”; the master
device should be reported first, the slave second.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div>This function will provide the caller with the specified block
device’s media information. If the media changes, calling this
function will update the media information accordingly.</div></blockquote>
<p><strong>Related Definitions</strong></p>
<blockquote>
<div><p><strong>//***************************************************</strong></p>
<p><strong>// EFI_PEI_BLOCK_IO2_MEDIA</strong></p>
<p><strong>//***************************************************</strong></p>
<p><strong>typedef struct {</strong></p>
<p><strong>UINT8</strong> <em>InterfaceType;</em></p>
<p><strong>BOOLEAN</strong> <em>RemovablaMedia;</em></p>
<p><strong>BOOLEAN</strong> <em>MediaPresent</em><strong>;</strong></p>
<p><strong>BOOLEAN</strong> <em>ReadOnly</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>BlockSize;</em></p>
<p><strong>EFI_PEI_LBA</strong> <em>LastBlock;</em></p>
<p><strong>} PEI_BLOCK_IO2_MEDIA;</strong></p>
<p><em>InterfaceType</em></p>
<p>A type of interface that the device being referenced by
<em>DeviceIndex</em> is attached to.</p>
<p>This field re-uses Messaging Device Path Node sub-type values as
defined by Section “9.3.5 Messaging Device Path” of <em>UEFI
Specification</em>. When more than one sub-type is associated with the
interface, sub-type with the smallest number must be used. For
example, <em>InterfaceType</em> must be set to 5 for USB devices.</p>
<p><em>RemovablaMedia</em></p>
<p>A flag that indicates if media is removable.</p>
<p><em>MediaPresent</em></p>
<p>A flag that indicates if media is present. This flag is always set
for non-removable media devices.</p>
<p><em>ReadOnly</em></p>
<p>A flag that indicates if media is read-only.</p>
<p><em>LastBlock</em></p>
<p>The last logical block that the device supports.</p>
<p><em>BlockSize</em></p>
<p>The size of a logical block in bytes. Type <strong>EFI_PEI_LBA</strong> is
defined below.</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><p><strong>Related Definitions</strong></p>
<p><strong>//*****************************************************</strong></p>
<p><strong>// EFI_PEI_LBA</strong></p>
<p><strong>//*****************************************************
typedef UINT64 EFI_PEI_LBA; EFI_PEI_LBA</strong> is the <strong>UINT64</strong> LBA
number.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">Media information about the specified block device was obtained successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>Cannot get the media information due to a hardware error.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
</div>
<div class="section" id="efi-pei-recovery-block-io2-ppi-readblocks">
<h3>EFI_PEI_RECOVERY_BLOCK_IO2_PPI.ReadBlocks()<a class="headerlink" href="#efi-pei-recovery-block-io2-ppi-readblocks" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Reads the requested number of blocks from the specified block
device.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_READ_BLOCKS2) (</strong></p>
<p><strong>IN EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN EFI_PEI_RECOVERY_BLOCK_IO2_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINTN</strong> <em>DeviceIndex,</em></p>
<p><strong>IN EFI_PEI_LBA</strong> <em>StartLBA,</em></p>
<p><strong>IN UINTN</strong> <em>BufferSize,</em></p>
<p><strong>OUT VOID</strong> <em>*Buffer</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>General-purpose services that are available to every PEIM. Type</p>
<p><strong>EFI_PEI_SERVICES</strong> is defined in the <em>Intel® Platform Innovation
Framework for EFI Pre-EFI Initialization Core Interface
Specification</em> (PEI CIS).</p>
<p><em>This</em></p>
<p>Indicates the <strong>EFI_PEI_RECOVERY_BLOCK_IO_PPI</strong> instance.</p>
<p><em>DeviceIndex</em></p>
<p>Specifies the block device to which the function wants to talk.
Because the driver that implements Block I/O PPIs will manage
multiple block devices, the PPIs that want to talk to a single
device must specify the device index that was assigned during the
enumeration process. This index is a number from one to
<em>NumberBlockDevices</em>. <em>StartLBA</em></p>
<p>The starting logical block address (LBA) to read from on the device.
Type</p>
<p><strong>EFI_PEI_LBA</strong> is defined in in the <strong>GetBlockDeviceMediaInfo()</strong>
function description.</p>
<p><em>BufferSize</em></p>
<p>The size of the <em>Buffer</em> in bytes. This number must be a multiple of
the intrinsic block size of the device.</p>
<p><em>Buffer</em></p>
<p>A pointer to the destination buffer for the data. The caller is
responsible for the ownership of the buffer.</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><p><strong>Description</strong></p>
<p>The function reads the requested number of blocks from the device.
All the blocks are read, or an error is returned. If there is no
media in the device, the function returns <strong>EFI_NO_MEDIA</strong>.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The data was read correctly from the device.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>The device reported an error while attempting to perform the read operation.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td>The read request contains LBAs that are not valid, or the buffer is not properly aligned.</td>
</tr>
<tr class="row-even"><td>EFI_NO_MEDIA</td>
<td>There is no media in the device.</td>
</tr>
<tr class="row-odd"><td>EFI_BAD_BUFFER_SIZE</td>
<td>The <em>BufferSize</em> parameter is not a multiple of the intrinsic block size of the device.</td>
</tr>
</tbody>
</table>
<p><strong>8.3.6 EFI PEI Vector Handoff Info PPI</strong></p>
<p>Version 1.7 July 2018</p>
</div>
<div class="section" id="efi-pei-vector-handoff-info-ppi-optional">
<h3>EFI_PEI_VECTOR_HANDOFF_INFO_PPI (Optional)<a class="headerlink" href="#efi-pei-vector-handoff-info-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>The PPI that describes an array of interrupt and/or exception
vectors that are in use and need to persist.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_VECTOR_HANDOFF_INFO_PPI_GUID \</strong></p>
<p><strong>{ 0x3cd652b4, 0x6d33, 0x4dce, \</strong></p>
<p><strong>{ 0x89, 0xdb, 0x83, 0xdf, 0x97, 0x66, 0xfc, 0xca } }</strong></p>
<p><strong>Protocol Interface Structure typedef struct
_EFI_PEI_VECTOR_HANDOFF_INFO_PPI {</strong></p>
<p><strong>EFI_VECTOR_HANDOFF_INFO</strong> <em>*Info;</em></p>
<p><strong>} EFI_PEI_VECTOR_HANDOFF_INFO_PPI;</strong></p>
<p><strong>Parameters</strong> <em>Info</em></p>
<p>Pointer to an array of interrupt and /or exception vectors.</p>
<p><strong>Description</strong></p>
<p>This is an optional PPI that may be produced by SEC. If present, it
provides a description of the interrupt and/or exception vectors
that were established in the SEC Phase and need to persist into PEI
and DXE. This PPI is an array of entries that is terminated by an
entry whose <em>Attribute</em> is set to
<strong>EFI_VECTOR_HANDOFF_LAST_ENTRY</strong>.</p>
<p>If <em>Attribute</em> is set to <strong>EFI_VECTOR_HANDOFF_DO_NOT_HOOK</strong>,
then the associated handler for <em>VectorNumber</em> must be preserved in
PEI and DXE.</p>
<p>If <em>Attribute</em> is set to <strong>EFI_VECTOR_HANDOFF_HOOK_BEFORE</strong>,
then <em>VectorNumber</em> may be used in PEI and DXE, but new handlers
must be invoked prior to when the existing handler is called.</p>
<p>If <em>Attribute</em> is set to <strong>EFI_VECTOR_HANDOFF_HOOK_AFTER</strong>, then
the associated</p>
<p><em>VectorNumber</em> may be used in PEI and DXE, but new handlers must be
called after the existing handler is called.</p>
<p><strong>EFI_PEI_VECTOR_HANDOFF_INFO_PPI_GUID</strong> can also be used in
the PEI Phase to build a</p>
<p>GUIDed HOB that contains an array of <strong>EFI_VECTOR_HANDOFF_INFO</strong>
entries that describes the interrupt and/or exception vectors in use
in the PEI Phase. This may be identical to the array passed up from
SEC, or it could be an array that is augmented with additional
vectors used in PEI Phase.</p>
<p><strong>Related Definitions</strong></p>
<p><strong>//</strong></p>
<p><strong>// System configuration table entry that points to the table</strong></p>
<p><strong>// in case an entity in DXE wishes to update/change the vector</strong></p>
<p><strong>// table contents.</strong></p>
<p><strong>//</strong></p>
<p><a href="#id262"><span class="problematic" id="id263">**</span></a>#define EFI_VECTOR_HANDOFF_TABLE_GUID \ **</p>
<p><strong>{0x996ec11c, 0x5397, 0x4e73, \</strong></p>
<p><strong>{0xb5, 0x8f, 0x82, 0x7e, 0x52, 0x90, 0x6d, 0xef}}</strong></p>
<p><strong>typedef struct { UINT32</strong> <em>VectorNumber;</em></p>
<p><strong>UINT32</strong> <em>Attribute</em><strong>;</strong></p>
<p><strong>EFI_GUID</strong> <em>Owner</em><strong>;</strong></p>
<p><strong>} EFI_VECTOR_HANDOFF_INFO;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>VectorNumber</em></p>
<p>The interrupt or exception vector that is in use and must be
preserved.</p>
<p><em>Attribute</em></p>
<p>A bitmask that describes the attributes of the interrupt or
exception vector.</p>
<p><em>Owner</em></p>
<p>The GUID identifies the party who created the entry. For the</p>
</div></blockquote>
<p><strong>EFI_VECTOR_HANDOFF_DO_NOT_HOOK</strong> case, this establishes the
single owner.</p>
<p><strong>8.3.7 CPU I/O PPI (Optional)</strong></p>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-optional">
<h3>EFI_PEI_CPU_IO_PPI (Optional)<a class="headerlink" href="#efi-pei-cpu-io-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If the service is not available, the PEI Core service
<strong>EFI_PEI_CPU_IO_PPI</strong> <em>*CpuIo</em> member functions will have a
dummy function that return <strong>EFI_NOT_AVAILABLE_YET</strong>;</p>
<p><strong>Summary</strong></p>
<p>This PPI is installed by some platform or chipset-specific PEIM that
abstracts the processor-visible I/O operations.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_CPU_IO_PPI_INSTALLED_GUID \</strong></p>
<p><strong>{0xe6af1f7b, 0xfc3f, 0x46da, 0xa8, 0x28, 0xa3, 0xb4, \</strong></p>
<p><strong>0x57, 0xa4, 0x42, 0x82}</strong></p>
<p>This is an indicator GUID without any data. It represents the fact
that a PEIM has written the address of the
<strong>EFI_PEI_CPU_IO_PPI</strong> into the <strong>EFI_PEI_SERVICES</strong> table.</p>
</div></blockquote>
<p><strong>PPI Interface Structure typedef</strong></p>
<blockquote>
<div><p><strong>struct _EFI_PEI_CPU_IO_PPI {</strong></p>
<p><strong>EFI_PEI_CPU_IO_PPI_ACCESS</strong> <em>Mem;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_ACCESS</strong> <em>Io;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_READ8</strong> <em>IoRead8;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_READ16</strong> <em>IoRead16;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_READ32</strong> <em>IoRead32;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_READ64</strong> <em>IoRead64;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_WRITE8</strong> <em>IoWrite8;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_WRITE16</strong> <em>IoWrite16;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_WRITE32</strong> <em>IoWrite32;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_WRITE64</strong> <em>IoWrite64;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_READ8</strong> <em>MemRead8;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_READ16</strong> <em>MemRead16;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_READ32</strong> <em>MemRead32;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_READ64</strong> <em>MemRead64;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_WRITE8</strong> <em>MemWrite8;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_WRITE16</strong> <em>MemWrite16;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_WRITE32</strong> <em>MemWrite32;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_MEM_WRITE64</strong> <em>MemWrite64;</em></p>
<p><strong>} EFI_PEI_CPU_IO_PPI;</strong></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><em>Mem</em></p>
<p>Collection of memory-access services. See the <strong>Mem()</strong> function
description. Type <strong>EFI_PEI_CPU_IO_PPI_ACCESS</strong> is defined in
“Related Definitions” below.</p>
<p><em>Io</em></p>
<p>Collection of I/O-access services. See the <strong>Io()</strong> function
description. Type <strong>EFI_PEI_CPU_IO_PPI_ACCESS</strong> is defined in
“Related Definitions” below. <em>IoRead8</em></p>
<p>8-bit read service. See the <strong>IoRead8()</strong> function description.</p>
<p><em>IoRead16</em></p>
<p>16-bit read service. See the <strong>IoRead16()</strong> function description.</p>
<p><em>IoRead32</em></p>
<p>32-bit read service. See the <strong>IoRead32()</strong> function description.</p>
<p><em>IoRead64</em></p>
<p>64-bit read service. See the <strong>IoRead64()</strong> function description.</p>
<p><em>IoWrite8</em></p>
<p>8-bit write service. See the <strong>IoWrite8()</strong> function description.</p>
<p><em>IoWrite16</em></p>
<p>16-bit write service. See the <strong>IoWrite16()</strong> function description.</p>
<p><em>IoWrite32</em></p>
<p>32-bit write service. See the <strong>IoWrite32()</strong> function description.</p>
<p><em>IoWrite64</em></p>
<p>64-bit write service. See the <strong>IoWrite64()</strong> function description.</p>
<p><em>MemRead8</em></p>
<p>8-bit read service. See the <strong>MemRead8()</strong> function description.</p>
<p><em>MemRead16</em></p>
<p>16-bit read service. See the <strong>MemRead16()</strong> function description.</p>
<p><em>MemRead32</em></p>
<p>32-bit read service. See the <strong>MemRead32()</strong> function description.</p>
<p><em>MemRead64</em></p>
<p>64-bit read service. See the <strong>MemRead64()</strong> function description.</p>
<p><em>MemWrite8</em></p>
<p>8-bit write service. See the <strong>MemWrite8()</strong> function description.</p>
<p><em>MemWrite16</em></p>
<p>16-bit write service. See the <strong>MemWrite16()</strong> function description.</p>
<p><em>MemWrite32</em></p>
<p>32-bit write service. See the <strong>MemWrite32()</strong> function description.</p>
<p><em>MemWrite64</em></p>
<p>64-bit write service. See the <strong>MemWrite64()</strong> function description.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div>This PPI provides a set of memory- and I/O-based services. The
perspective of the services is that of the processor, not the bus or
system.</div></blockquote>
<p><strong>Related Definitions</strong></p>
<blockquote>
<div><p><strong>//*******************************************************</strong></p>
<p><strong>// EFI_PEI_CPU_IO_PPI_ACCESS</strong></p>
<p><strong>//*******************************************************</strong></p>
<p><strong>typedef struct {</strong></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_MEM</strong> <em>Read;</em></p>
<p><strong>EFI_PEI_CPU_IO_PPI_IO_MEM</strong> <em>Write;</em></p>
<p><strong>} EFI_PEI_CPU_IO_PPI_ACCESS;</strong></p>
<p><em>Read</em></p>
<p>This service provides the various modalities of memory and I/O read.</p>
</div></blockquote>
<p><em>Write</em></p>
<p>This service provides the various modalities of memory and I/O write.</p>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-mem">
<h3>EFI_PEI_CPU_IO_PPI.Mem()<a class="headerlink" href="#efi-pei-cpu-io-ppi-mem" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Memory-based access services.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_MEM) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN EFI_PEI_CPU_IO_PPI_WIDTH</strong> <em>Width,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINTN</strong> <em>Count,</em></p>
<p><strong>IN OUT VOID</strong> <em>*Buffer</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Width</em></p>
<p>The width of the access. Enumerated in bytes. Type</p>
<p><strong>EFI_PEI_CPU_IO_PPI_WIDTH</strong> is defined in “Related
Definitions” below. <em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Count</em></p>
<p>The number of accesses to perform.</p>
<p><em>Buffer</em></p>
<p>A pointer to the buffer of data.</p>
<p><strong>Description</strong></p>
<p>The <strong>Mem()</strong> function provides a list of memory-based accesses.</p>
</div></blockquote>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>Related Definitions</strong></p>
<p><strong>//*******************************************************</strong></p>
<p><strong>// EFI_PEI_CPU_IO_PPI_WIDTH</strong></p>
<p><strong>//*******************************************************</strong></p>
<p><strong>typedef enum {</strong></p>
<p><strong>EfiPeiCpuIoWidthUint8,</strong></p>
<p><strong>EfiPeiCpuIoWidthUint16,</strong></p>
<p><strong>EfiPeiCpuIoWidthUint32,</strong></p>
<p><strong>EfiPeiCpuIoWidthUint64,</strong></p>
<p><strong>EfiPeiCpuIoWidthFifoUint8,</strong></p>
<p><strong>EfiPeiCpuIoWidthFifoUint16,</strong></p>
<p><strong>EfiPeiCpuIoWidthFifoUint32,</strong></p>
<p><strong>EfiPeiCpuIoWidthFifoUint64,</strong></p>
<p><strong>EfiPeiCpuIoWidthFillUint8,</strong></p>
<p><strong>EfiPeiCpuIoWidthFillUint16,</strong></p>
<p><strong>EfiPeiCpuIoWidthFillUint32,</strong></p>
<p><strong>EfiPeiCpuIoWidthFillUint64,</strong></p>
<p><strong>EfiPeiCpuIoWidthMaximum</strong></p>
<p><strong>} EFI_PEI_CPU_IO_PPI_WIDTH;</strong></p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The function completed successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_YET_AVAILABLE</td>
<td>The service has not been installed.</td>
</tr>
</tbody>
</table>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-io">
<h3>EFI_PEI_CPU_IO_PPI.Io()<a class="headerlink" href="#efi-pei-cpu-io-ppi-io" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>I/O-based access services.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_MEM) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN EFI_PEI_CPU_IO_PPI_WIDTH</strong> <em>Width,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINTN</strong> <em>Count,</em></p>
<p><strong>IN OUT VOID</strong> <em>*Buffer</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Width</em></p>
<p>The width of the access. Enumerated in bytes. Type</p>
<p><strong>EFI_PEI_CPU_IO_PPI_WIDTH</strong> is defined in <strong>Mem()</strong>.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Count</em></p>
<p>The number of accesses to perform.</p>
<p><em>Buffer</em></p>
<p>A pointer to the buffer of data.</p>
<p><strong>Description</strong></p>
<p>The <strong>Io()</strong> function provides a list of I/O-based accesses. Input
or output data can be found in the last argument.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The function completed successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_YET_AVAILABLE</td>
<td>The service has not been installed.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-ioread8">
<h3>EFI_PEI_CPU_IO_PPI.IoRead8()<a class="headerlink" href="#efi-pei-cpu-io-ppi-ioread8" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>8-bit I/O read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT8</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_READ8) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoRead8()</strong> function returns an 8-bit value from the I/O
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-ioread16">
<h3>EFI_PEI_CPU_IO_PPI.IoRead16()<a class="headerlink" href="#efi-pei-cpu-io-ppi-ioread16" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>16-bit I/O read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT16</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_READ16) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoRead16()</strong> function returns a 16-bit value from the I/O
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-ioread32">
<h3>EFI_PEI_CPU_IO_PPI.IoRead32()<a class="headerlink" href="#efi-pei-cpu-io-ppi-ioread32" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>32-bit I/O read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT32</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_READ32) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoRead32()</strong> function returns a 32-bit value from the I/O
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-ioread64">
<h3>EFI_PEI_CPU_IO_PPI.IoRead64()<a class="headerlink" href="#efi-pei-cpu-io-ppi-ioread64" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>64-bit I/O read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT64</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_READ64) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST_EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoRead64()</strong> function returns a 64-bit value from the I/O
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-iowrite8">
<h3>EFI_PEI_CPU_IO_PPI.IoWrite8()<a class="headerlink" href="#efi-pei-cpu-io-ppi-iowrite8" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>8-bit I/O write operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_WRITE8) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST_EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT8</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoWrite8()</strong> function writes an 8-bit value to the I/O space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-iowrite16">
<h3>EFI_PEI_CPU_IO_PPI.IoWrite16()<a class="headerlink" href="#efi-pei-cpu-io-ppi-iowrite16" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>16-bit I/O write operation.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_WRITE16) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT16</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoWrite16()</strong> function writes a 16-bit value to the I/O space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-iowrite32">
<h3>EFI_PEI_CPU_IO_PPI.IoWrite32()<a class="headerlink" href="#efi-pei-cpu-io-ppi-iowrite32" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>32-bit I/O write operation.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_WRITE32) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT32</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoWrite32()</strong> function writes a 32-bit value to the I/O space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-iowrite64">
<h3>EFI_PEI_CPU_IO_PPI.IoWrite64()<a class="headerlink" href="#efi-pei-cpu-io-ppi-iowrite64" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>64-bit I/O write operation.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_WRITE64) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT64</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>IoWrite64()</strong> function writes a 64-bit value to the I/O space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memread8">
<h3>EFI_PEI_CPU_IO_PPI.MemRead8()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memread8" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>8-bit memory read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT8</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_MEM_READ8) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemRead8()</strong> function returns an 8-bit value from the memory
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memread16">
<h3>EFI_PEI_CPU_IO_PPI.MemRead16()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memread16" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>16-bit memory read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT16</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_MEM_READ16) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemRead16()</strong> function returns a 16-bit value from the memory
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memread32">
<h3>EFI_PEI_CPU_IO_PPI.MemRead32()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memread32" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>32-bit memory read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT32</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_MEM_READ32) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemRead32()</strong> function returns a 32-bit value from the memory
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memread64">
<h3>EFI_PEI_CPU_IO_PPI.MemRead64()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memread64" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>64-bit memory read operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>UINT64</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_MEM_READ64) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemRead64()</strong> function returns a 64-bit value from the memory
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memwrite8">
<h3>EFI_PEI_CPU_IO_PPI.MemWrite8()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memwrite8" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>8-bit memory write operations.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_MEM_WRITE8) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT8</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemWrite8()</strong> function writes an 8-bit value to the memory
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memwrite16">
<h3>EFI_PEI_CPU_IO_PPI.MemWrite16()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memwrite16" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>16-bit memory write operation.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_MEM_WRITE16) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT16</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemWrite16()</strong> function writes a 16-bit value to the memory
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memwrite32">
<h3>EFI_PEI_CPU_IO_PPI.MemWrite32()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memwrite32" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>32-bit memory write operation.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_MEM_WRITE32) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT32</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemWrite32()</strong> function writes a 32-bit value to the memory
space.</p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-cpu-io-ppi-memwrite64">
<h3>EFI_PEI_CPU_IO_PPI.MemWrite64()<a class="headerlink" href="#efi-pei-cpu-io-ppi-memwrite64" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>64-bit memory write operation.</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>VOID</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CPU_IO_PPI_IO_WRITE64) (</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES</strong> <em>**PeiServices,</em></p>
<p><strong>IN CONST EFI_PEI_CPU_IO_PPI</strong> <em>*This,</em></p>
<p><strong>IN UINT64</strong> <em>Address,</em></p>
<p><strong>IN UINT64</strong> <em>Data</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
</div></blockquote>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<blockquote>
<div><p><em>This</em></p>
<p>Pointer to local data for the interface.</p>
<p><em>Address</em></p>
<p>The physical address of the access.</p>
<p><em>Data</em></p>
<p>The data to write.</p>
<p><strong>Description</strong></p>
<p>The <strong>MemWrite64()</strong> function writes a 64-bit value to the memory
space.</p>
<p><strong>//</strong></p>
<p><strong>// Vector Handoff Info Attributes</strong></p>
<p><strong>//</strong></p>
<p><strong>#define EFI_VECTOR_HANDOFF_DO_NOT_HOOK 0x00000000</strong></p>
<p><strong>#define EFI_VECTOR_HANDOFF_HOOK_BEFORE 0x00000001</strong></p>
<p><strong>#define EFI_VECTOR_HANDOFF_HOOK_AFTER 0x00000002</strong></p>
<p><strong>#define EFI_VECTOR_HANDOFF_LAST_ENTRY 0x80000000</strong></p>
</div></blockquote>
<p><strong>8.3.8 EFI Pei Capsule PPI</strong></p>
</div>
<div class="section" id="efi-pei-capsule-ppi-optional">
<h3>EFI_PEI_CAPSULE_PPI (Optional)<a class="headerlink" href="#efi-pei-capsule-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is installed by some platform or chipset-specific PEIM that
abstracts handling of UEFI Capsule processing.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_CAPSULE_PPI_GUID \</strong></p>
<p><strong>{0x3acf33ee, 0xd892, 0x40f4, \</strong></p>
<p><strong>{0xa2, 0xfc, 0x38, 0x54, 0xd2, 0xe1, 0x32, 0x3d } }</strong></p>
<p><strong>PPI Interface Structure typedef</strong></p>
<p><strong>struct _EFI_PEI_CAPSULE_PPI { EFI_PEI_CAPSULE_COALESCE
Coalesce;</strong></p>
<p><strong>EFI_PEI_CAPSULE_CHECK_CAPSULE_UDPATE</strong>
<em>CheckCapsuleUpdate</em><strong>;</strong></p>
<p><strong>EFI_PEI_CAPSULE_CREATE_STATE</strong> <em>CreateState</em><strong>;</strong></p>
<p><strong>} EFI_PEI_CAPSULE_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Coalesce</em></p>
<p>Upon determining that there is a capsule to operate on, this service
will use a series of <strong>EFI_CAPSULE_BLOCK_DESCRIPTOR</strong> entries to
determine the current location of the various capsule fragments and
coalesce them into a contiguous region of system memory.</p>
<p><em>CheckCapsuleUpdate</em></p>
<p>Determine if a capsule needs to be processed. The means by which the
presence of a capsule is determined is platform specific. For
example, an implementation could be driven by the presence of a
Capsule EFI Variable containing a list of</p>
<p><strong>EFI_CAPSULE_BLOCK_DESCRIPTOR</strong> entries. If present, return
<strong>EFI_SUCCESS</strong>, otherwise return <strong>EFI_NOT_FOUND</strong>.
<em>CreateState</em></p>
<p>The Capsule PPI service that gets called after memory is available.
The capsule coalesce function, which must be called first, returns a
base address and size. Once the memory init PEIM has discovered
memory, it should call this function and pass in the base address
and size returned by the Coalesce() function. Then this function can
create a capsule HOB and return.</p>
<p><strong>Description</strong></p>
<p>This PPI provides several services in PEI to work with the
underlying capsule capabilities of the platform. These services
include the ability for PEI to coalesce a capsule from a scattered
set of memory locations into a contiguous space in memory, detect if
a capsule is present for processing, and once memory is available,
create a HOB for the capsule.</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
</div>
<div class="section" id="efi-pei-capsule-ppi-coalesce">
<h3>EFI_PEI_CAPSULE_PPI.Coalesce<a class="headerlink" href="#efi-pei-capsule-ppi-coalesce" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Coalesce the capsule</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CAPSULE_COALESCE)(</strong></p>
<p><strong>IN EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN OUT VOID **</strong><em>MemoryBase</em><strong>,</strong></p>
<p><strong>IN OUT UINTN *</strong><em>MemSize</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>MemoryBase</em></p>
<p>Pointer to the base of a block of memory into which the buffers will
be coalesced. On output, this variable will hold the base address of
a coalesced capsule.</p>
<p><em>MemorySize</em></p>
<p>Pointer to local data for the interface.</p>
<p><strong>Description</strong></p>
<p>Upon determining that there is a capsule to operate on, this service
will use a series of</p>
<p><strong>EFI_CAPSULE_BLOCK_DESCRIPTOR</strong> entries to determine the current
location of the various capsule fragments and coalesce them into a
contiguous region of system memory.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">There was no capsule, or the capsule was processed successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>If: boot mode could not be determined, or the boot mode is not flash-update, or the capsule descriptors were not found.</td>
</tr>
<tr class="row-odd"><td>EFI_BUFFER_TOO_SMALL</td>
<td>The capsule could not be coalesced in the provided memory region.</td>
</tr>
</tbody>
</table>
<p>Version 1.7</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-pei-capsule-check-capsule-udpate-checkcapsuleupdat-e">
<h3>EFI_PEI_CAPSULE_CHECK_CAPSULE_UDPATE.CheckCapsuleUpdat e()<a class="headerlink" href="#efi-pei-capsule-check-capsule-udpate-checkcapsuleupdat-e" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Check the Capsule Update.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CAPSULE_CHECK_CAPSULE_UPDATE)( IN
EFI_PEI_SERVICES **</strong><em>PeiServices</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><strong>Description</strong></p>
<p>Determine if a capsule needs to be processed. The means by which the
presence of a capsule is determined is platform specific. For
example, an implementation could be driven by the presence of a
Capsule EFI Variable containing a list of
<strong>EFI_CAPSULE_BLOCK_DESCRIPTOR</strong> entries. If present, return
<strong>EFI_SUCCESS</strong>, otherwise return <strong>EFI_NOT_FOUND</strong>.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">If a capsule is available.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>No capsule detected.</td>
</tr>
</tbody>
</table>
<p>Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
</div>
<div class="section" id="efi-pei-capsule-check-capsule-udpate-capsulecreatestate">
<h3>EFI_PEI_CAPSULE_CHECK_CAPSULE_UDPATE.CapsuleCreateState(<a class="headerlink" href="#efi-pei-capsule-check-capsule-udpate-capsulecreatestate" title="Permalink to this headline">¶</a></h3>
<p><strong>)</strong></p>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Create the Capsule state.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_CAPSULE_CREATE_STATE)( IN EFI_PEI_SERVICES
**</strong><em>PeiServices</em><strong>, IN VOID *</strong><em>CapsuleBase</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>CapsuleSize</em></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>Pointer to the PEI Services Table.</p>
<p><em>CapsuleBase</em></p>
<p>Address returned by the capsule coalesce function.</p>
<p><a href="#id264"><span class="problematic" id="id265">*</span></a>CapsuleSize *</p>
<p>Value returned by the capsule coalesce function.</p>
<p><strong>Description</strong></p>
<p>The Capsule PPI service that gets called after memory is available.
The capsule coalesce function, which must be called first, returns a
base address and size. Once the memory init PEIM has discovered
memory, it should call this function and pass in the base address
and size returned by the Coalesce() function. Then this function can
create a capsule HOB and return.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_VOLUME_CORRUPTED</th>
<th class="head"><em>CapsuleBase</em> does not appear to point to a coalesced capsule.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_SUCCESS</td>
<td>Capsule HOB was created successfully.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-mp-services-ppi">
<h3>8.3.9 EFI MP Services PPI<a class="headerlink" href="#efi-mp-services-ppi" title="Permalink to this headline">¶</a></h3>
<p>Version 1.7</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-mp-services-ppi-optional">
<h3>EFI_MP_SERVICES_PPI (Optional)<a class="headerlink" href="#efi-mp-services-ppi-optional" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>This PPI is installed by some platform or chipset-specific PEIM that
abstracts handling multiprocessor support.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_MP_SERVICES_PPI_GUID \</strong></p>
<p><strong>{0xee16160a, 0xe8be, 0x47a6,\</strong></p>
<p><strong>{0x82, 0xa, 0xc6, 0x90, 0xd, 0xb0, 0x25, 0xa } }</strong></p>
<p><strong>PPI Interface Structure typedef</strong></p>
<p><strong>struct _EFI_MP_SERVICES_PPI {</strong></p>
<p><a href="#id266"><span class="problematic" id="id267">**</span></a>PEI_MP_SERVICES_GET_NUMBER_OF_PROCESSORS **</p>
<p><em>GetNumberOfProcessors</em><strong>;</strong></p>
<p><a href="#id268"><span class="problematic" id="id269">**</span></a>PEI_MP_SERVICES_GET_PROCESSOR_INFO **</p>
<p><em>GetProcessorInfo</em><strong>;</strong></p>
<p><a href="#id270"><span class="problematic" id="id271">**</span></a>PEI_MP_SERVICES_STARTUP_ALL_APS **</p>
<p><em>StartupAllAPs</em><strong>;</strong></p>
<p><strong>PEI_MP_SERVICES_STARTUP_THIS_AP</strong> <em>StartupThisAP</em><strong>;</strong></p>
<p><a href="#id272"><span class="problematic" id="id273">**</span></a>PEI_MP_SERVICES_SWITCH_BSP **</p>
<p><em>SwitchBSP</em><strong>;</strong></p>
<p><a href="#id274"><span class="problematic" id="id275">**</span></a>PEI_MP_SERVICES_ENABLEDISABLEAP **</p>
<p><strong>EnableDisableAP;</strong></p>
<p><a href="#id276"><span class="problematic" id="id277">**</span></a>PEI_MP_SERVICES_WHOAMI **</p>
<p><em>WhoAmI</em><strong>;</strong></p>
<p><strong>} EFI_MP_SERVICES_PPI;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>GetNumberOfProcessors</em></p>
<p>Discover the number of CPU’s</p>
<p><em>GetProcessorInfo</em></p>
<p>Ascertain information on the CPU’s. <em>StartupAllAPs</em></p>
<p>Startup all of the application processors. <em>StartupThisAP</em></p>
<p>Startup the specific application processor. <em>SwitchBSP</em></p>
<p>Swtich the boot strap processor.</p>
</div></blockquote>
<p>Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><p><em>WhoAmI</em></p>
<p>Identify the currently executing processor.</p>
<p><strong>Description</strong></p>
<p>When installed, the MP Services Ppi produces a collection of
services that are needed for MP management.</p>
<p>Before the PI event <strong>END_OF_PEI</strong> is signaled, the module that
produces this protocol is required to place all APs into an idle
state whenever the APs are disabled or the APs are not executing
code as requested through the <strong>StartupAllAPs()</strong> or
<strong>StartupThisAP()</strong> services. The idle state of an AP before the PI
event <strong>END_OF_PEI</strong> is signaled is implementation dependent.</p>
<p>After the PI event <strong>END_OF_PEI</strong> is signaled, all the APs must be
placed in the OS compatible CPU state as defined by the <em>UEFI
Specification</em>. Implementations of this Ppi may use the PI event
<strong>END_OF_PEI</strong> to force APs into the OS compatible state as
defined by the <em>UEFI Specification.</em></p>
<p>The support for <strong>SwitchBSP()</strong> and <strong>EnableDisableAP()</strong> may no
longer be supported after the PEI event <strong>END_OF_PEI</strong> is
signaled.</p>
</div></blockquote>
<p>Version 1.7</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div>EFI_MP_SERVICES_PPI.GetNumberOfProcessors()</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Get the number of CPU’s</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI PEI_MP_SERVICES_GET_NUMBER_OF_PROCESSORS)(</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN EFI_MP_SERVICES_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>OUT UINTN *</strong><em>NumberOfProcessors</em><strong>,</strong></p>
<p><strong>OUT UINTN *</strong><em>NumberOfEnabledProcessors</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>Pointer to this instance of the PPI.</p>
<p><em>NumberOfProcessors</em></p>
<p>Pointer to the total number of logical processors in the system,
including the BSP and disabled APs.</p>
<p><em>NumberOfEnabledProcessors</em></p>
<p>Number of processors in the system that are enabled.</p>
<p><strong>Description</strong></p>
<p>This service retrieves the number of logical processor in the
platform and the number of those logical processors that are enabled
on this boot. This service may only be called from the BSP.</p>
<p>This function is used to retrieve the following information:</p>
</div></blockquote>
<ul>
<li><p class="first">The number of logical processors that are present in the system.</p>
</li>
<li><p class="first">The number of enabled logical processors in the system at the instant
this call is made.</p>
<blockquote>
<div><p>Because MP Service Ppi provides services to enable and disable
processors dynamically, the number of enabled logical processors may
vary during the course of a boot session.</p>
<p>If this service is called from an AP, then <strong>EFI_DEVICE_ERROR</strong> is
returned.</p>
<p>If <em>NumberOfProcessors</em> or <em>NumberOfEnabledProcessors</em> is NULL, then</p>
<p><strong>EFI_INVALID_PARAMETER</strong> is returned. Otherwise, the total number
of processors is returned in</p>
<p><em>NumberOfProcessors</em>, the number of currently enabled processor is
returned in <em>NumberOfEnabledProcessors</em>, and <strong>EFI_SUCCESS</strong> is
returned.</p>
</div></blockquote>
</li>
</ul>
<p>Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The number of logical processors and enabled logical processors was retrieved.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>The calling processor is an AP.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><em>NumberOfProcessors</em> is NULL.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>NumberOfEnabledProcessors</em> is NULL.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
</div>
<div class="section" id="efi-mp-services-ppi-getprocessorinfo">
<h3>EFI_MP_SERVICES_PPI.GetProcessorInfo()<a class="headerlink" href="#efi-mp-services-ppi-getprocessorinfo" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Get information on a specific CPU.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI PEI_MP_SERVICES_GET_PROCESSOR_INFO)(</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN EFI_MP_SERVICES_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>ProcessorNumber</em><strong>,</strong></p>
<p><strong>OUT EFI_PROCESSOR_INFORMATION *</strong><em>ProcessorInfoBuffer</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>A pointer to the <strong>EFI_MP_SERVICES_PPI</strong> instance.
<em>ProcessorNumber</em></p>
<p>The handle number of the processor.</p>
<p><em>ProcessorInfoBuffer</em></p>
<p>A pointer to the buffer where the processor information is stored.</p>
<p><strong>Description</strong></p>
<p>Gets detailed MP-related information on the requested processor at
the instant this call is made. This service may only be called from
the BSP.</p>
<p>This service retrieves detailed MP-related information about any
processor on the platform. Note the following:</p>
</div></blockquote>
<ul>
<li><p class="first">The processor information may change during the course of a boot
session.</p>
</li>
<li><p class="first">The information presented here is entirely MP related.</p>
<blockquote>
<div><p>Information regarding the number of caches and their sizes,
frequency of operation, slot numbers is all considered
platform-related information and is not provided by this service.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">Processor information was returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>The calling processor is an AP.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><em>ProcessorInfoBuffer</em> is NULL.</td>
</tr>
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td><p class="first">The processor with the handle specified by</p>
<p class="last"><em>ProcessorNumber</em> does not exist in the platform.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-mp-services-ppi-startupallaps">
<h3>EFI_MP_SERVICES_PPI.StartupAllAPs ()<a class="headerlink" href="#efi-mp-services-ppi-startupallaps" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Activate all of the application proessors.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *PEI_MP_SERVICES_STARTUP_ALL_APS)(</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN EFI_MP_SERVICES_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>IN EFI_AP_PROCEDURE</strong> <em>Procedure</em><strong>,</strong></p>
<p><strong>IN BOOLEAN</strong> <em>SingleThread</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>TimeoutInMicroSeconds</em><strong>,</strong></p>
<p><strong>IN VOID *</strong><em>ProcedureArgument</em> <strong>OPTIONAL );</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>A pointer to the <strong>EFI_MP_SERVICES_PPI</strong> instance.</p>
<p><em>Procedure</em></p>
<p>A pointer to the function to be run on enabled APs of the system.
See type</p>
<p><strong>EFI_AP_PROCEDURE</strong>.</p>
<p><em>SingleThread</em></p>
<p>If <strong>TRUE</strong>, then all the enabled APs execute the function specified
by <em>Procedure</em> one by one, in ascending order of processor handle
number. If <strong>FALSE</strong>, then all the enabled APs execute the function
specified by <em>Procedure</em> simultaneously.</p>
<p><a href="#id278"><span class="problematic" id="id279">*</span></a>TimeoutInMicroseconds *</p>
<p>Indicates the time limit in microseconds for APs to return from
Procedure, for blocking mode only. Zero means infinity. If the
timeout expires before all APs return from <em>Procedure</em>, then
<em>Procedure</em> on the failed APs is terminated. All enabled</p>
<p>APs are available for next function assigned by</p>
<p><strong>EFI_MP_SERVICES_PPI.StartupAllAPs()</strong>or
<strong>EFI_MP_SERVICES_PPI.StartupThisAP()</strong>.</p>
<p>If the timeout expires in blocking mode, BSP returns
<strong>EFI_TIMEOUT</strong>.</p>
<p><a href="#id280"><span class="problematic" id="id281">*</span></a>ProcedureArgument *</p>
<p>The parameter passed into <em>Procedure</em> for all APs.</p>
<p><strong>Description</strong></p>
<p>This service executes a caller provided function on all enabled APs.
APs can run either simultaneously or one at a time in sequence. This
service supports both blocking requests only. This service may only
be called from the BSP.</p>
<p>This function is used to dispatch all the enabled APs to the
function specified by <em>Procedure</em>. If any enabled AP is busy, then
<strong>EFI_NOT_READY</strong> is returned immediately and <em>Procedure</em> is not
started on any AP.</p>
<p>If <em>SingleThread</em> is <strong>TRUE</strong>, all the enabled APs execute the
function specified by <em>Procedure</em> one by one, in ascending order of
processor handle number. Otherwise, all the enabled APs execute the
function specified by <em>Procedure</em> simultaneously.</p>
<p>If the timeout specified by <em>TimeoutInMicroseconds</em> expires before
all APs return from <em>Procedure</em>, then <em>Procedure</em> on the failed APs
is terminated. All enabled APs are always available for further
calls to <strong>EFI_MP_SERVICES_PPI.StartupAllAPs()</strong> and</p>
<p><strong>EFI_MP_SERVICES_PPI.StartupThisAP()</strong>. If <em>FailedCpuList</em> is
not NULL, its content points to the list of processor handle numbers
in which <em>Procedure</em> was terminated.</p>
</div></blockquote>
<p><strong>*Note:</strong> It is the responsibility of the consumer of the*
<strong>EFI_MP_SERVICES_PPI.StartupAllAPs()</strong> <em>to make sure that the nature
of the code that is executed on the BSP and the dispatched APs is well
controlled. The MP Services Ppi does not guarantee that the Procedure
function is MPsafe. Hence, the tasks that can be run in parallel are
limited to certain independent tasks and wellcontrolled exclusive code.
PEI services and Ppis may not be called by APs unless otherwise
specified.</em></p>
<blockquote>
<div><p>In blocking execution mode, BSP waits until all APs finish or
<em>TimeoutInMicroSeconds</em> expires.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">In blocking mode, all APs have finished before the timeout expired.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>Caller processor is AP.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_STARTED</td>
<td>No enabled APs exist in the system.</td>
</tr>
<tr class="row-even"><td>EFI_NOT_READY</td>
<td>Any enabled APs are busy.</td>
</tr>
<tr class="row-odd"><td>EFI_TIMEOUT</td>
<td>In blocking mode, the timeout expired before all enabled APs have finished.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>Procedure</em> is NULL</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-mp-services-ppi-startupthisap">
<h3>EFI_MP_SERVICES_PPI.StartupThisAP ()<a class="headerlink" href="#efi-mp-services-ppi-startupthisap" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Activate a specific application processor</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *PEI_MP_SERVICES_STARTUP_THIS_AP)(</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN EFI_MP_SERVICES_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>IN EFI_AP_PROCEDURE</strong> <em>Procedure</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>ProcessorNumber</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>TimeoutInMicroseconds</em><strong>,</strong></p>
<p><strong>IN VOID *</strong><em>ProcedureArgument</em> <strong>OPTIONAL );</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>A pointer to the <strong>EFI_MP_SERVICES_PPI</strong> instance. <a href="#id282"><span class="problematic" id="id283">*</span></a>Procedure *</p>
<p>A pointer to the function to be run on enabled APs of the system.
See type</p>
<p><strong>EFI_AP_PROCEDURE</strong>.</p>
<p><a href="#id284"><span class="problematic" id="id285">*</span></a>ProcessorNumber *</p>
<p>The handle number of the AP. The range is from 0 to the total number
of logical</p>
<p>processors minus 1. The total number of logical processors can be
retrieved by</p>
<p><strong>EFI_MP_SERVICES_PPI.GetNumberOfProcessors()</strong>.</p>
<p><a href="#id286"><span class="problematic" id="id287">*</span></a>TimeoutInMicrosecsond *</p>
<p>Indicates the time limit in microseconds for APs to return from
<em>Procedure</em>, for blocking mode only. Zero means infinity. If the
timeout expires before all APs return from <em>Procedure</em>, then
<em>Procedure</em> on the failed APs is terminated. All enabled</p>
<p>APs are available for next function assigned by</p>
<p><strong>EFI_MP_SERVICES_PPI.StartupAllAPs()</strong> or
<strong>EFI_MP_SERVICES_PPI.StartupThisAP()</strong>.</p>
<p>If the timeout expires in blocking mode, BSP returns
<strong>EFI_TIMEOUT</strong>.</p>
<p><a href="#id288"><span class="problematic" id="id289">*</span></a>ProcedureArgument *</p>
<p>The parameter passed into Procedure for all APs.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This service lets the caller get one enabled AP to execute a
caller-provided function. The caller can request the BSP to wait for
the completion of the AP. This service may only be called from the
BSP. This function is used to dispatch one enabled AP to the
function specified by <em>Procedure</em> passing in the argument specified
by <em>ProcedureArgument</em>.</p>
<p>The execution is in blocking mode. The BSP waits until the AP
finishes or <em>TimeoutInMicroSecondss</em> expires.</p>
<p>If the timeout specified by <em>TimeoutInMicroseconds</em> expires before
the AP returns from <em>Procedure</em>, then execution of <em>Procedure</em> by
the AP is terminated. The AP is available for subsequent calls to
<strong>EFI_MP_SERVICES_PPI.StartupAllAPs()</strong> and
<strong>EFI_MP_SERVICES_PPI.StartupThisAP()</strong>.</p>
</div></blockquote>
<p><strong>Status Codes Returned</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">In blocking mode, specified AP finished before the timeout expires.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>The calling processor is an AP.</td>
</tr>
<tr class="row-odd"><td>EFI_TIMEOUT</td>
<td>In blocking mode, the timeout expired before the specified AP has finished.</td>
</tr>
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The processor with the handle specified by <em>ProcessorNumber</em> does not exist.</td>
</tr>
<tr class="row-odd"><td>EFI_INVALID_PARAMETER</td>
<td><em>ProcessorNumber</em> specifies the current BSP or a disabled AP.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>Procedure</em> is NULL</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="efi-mp-services-ppi-switchbsp">
<h3>EFI_MP_SERVICES_PPI.SwitchBSP ()<a class="headerlink" href="#efi-mp-services-ppi-switchbsp" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Switch the boot strap processor</p>
<p><strong>Prototype typedef</strong></p>
<p><strong>(EFIAPI *PEI_MP_SERVICES_SWITCH_BSP)(</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN EFI_MP_SERVICES_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>ProcessorNumber</em><strong>,</strong></p>
<p><strong>IN BOOLEAN</strong> <em>EnableOldBSP</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>A pointer to the <strong>EFI_MP_SERVICES_PPI</strong> instance.</p>
<p><a href="#id290"><span class="problematic" id="id291">*</span></a>ProcessorNumber *</p>
<p>The handle number of AP that is to become the new BSP. The range is
from 0 to the total number of logical processors minus 1. The total
number of logical processors can be retrieved by
<strong>EFI_MP_SERVICES_PPI.GetNumberOfProcessors()</strong>. <a href="#id292"><span class="problematic" id="id293">*</span></a>EnableOldBSP *</p>
<p>If <strong>TRUE</strong>, then the old BSP will be listed as an enabled AP.
Otherwise, it will be disabled.</p>
<p><strong>Description</strong></p>
<p>This service switches the requested AP to be the BSP from that point
onward.</p>
<p>This service changes the BSP for all purposes.This call can only be
performed by the current BSP.</p>
<p>This service switches the requested AP to be the BSP from that point
onward. This service changes the BSP for all purposes. The new BSP
can take over the execution of the old BSP and continue seamlessly
from where the old one left off.</p>
<p>If the BSP cannot be switched prior to the return from this service,
then <strong>EFI_UNSUPPORTED</strong> must be returned.</p>
</div></blockquote>
<p><strong>Status Codes Returned</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">BSP successfully switched.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_UNSUPPORTED</td>
<td>Switching the BSP cannot be completed prior to this service returning.</td>
</tr>
<tr class="row-odd"><td>EFI_UNSUPPORTED</td>
<td>Switching the BSP is not supported.</td>
</tr>
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>The calling processor is an AP.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>The processor with the handle specified by <em>ProcessorNumber</em> does not exist.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>ProcessorNumber</em> specifies the current BSP or a disabled AP.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_READY</td>
<td>The specified AP is busy.</td>
</tr>
</tbody>
</table>
<p><strong>Summary</strong></p>
<blockquote>
<div>Switch the boot strap processor</div></blockquote>
<p><strong>Prototype typedef</strong></p>
<blockquote>
<div><p><strong>(EFIAPI *PEI_MP_SERVICES_ENABLEDISABLEAP)(</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN EFI_MP_SERVICES_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>IN UINTN</strong> <em>ProcessorNumber</em><strong>,</strong></p>
<p><strong>IN BOOLEAN</strong> <em>EnableAP</em><strong>,</strong></p>
<p><strong>IN UINT32 *</strong><em>HealthFlag</em> <strong>OPTIONAL );</strong></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>A pointer to the <strong>EFI_MP_SERVICES_PPI</strong> instance.</p>
<p><a href="#id294"><span class="problematic" id="id295">*</span></a>ProcessorNumber *</p>
<p>The handle number of AP that is to become the new BSP. The range is
from 0 to the total number of logical processors minus 1. The total
number of logical processors can be retrieved by
<strong>EFI_MP_SERVICES_PPI.GetNumberOfProcessors()</strong>. <a href="#id296"><span class="problematic" id="id297">*</span></a>EnableAP *</p>
<p>Specifies the new state for the processor for enabled, FALSE for
disabled.</p>
<p><a href="#id298"><span class="problematic" id="id299">*</span></a>HealthFlag *</p>
<p>If not NULL, a pointer to a value that specifies the new health
status of the AP. This flag corresponds to <em>StatusFlag</em> defined in</p>
<p><strong>EFI_MP_SERVICES_PPI.GetProcessorInfo()</strong>. Only the</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><p><strong>PROCESSOR_HEALTH_STATUS_BIT</strong> is used. All other bits are
ignored. If it is NULL, this parameter is ignored.</p>
<p><strong>Description</strong></p>
<p>This service lets the caller enable or disable an AP from this point
onward.</p>
<p>This service may only be called from the BSP.</p>
<p>This service allows the caller enable or disable an AP from this
point onward. The caller can optionally specify the health status of
the AP by Health. If an AP is being disabled, then the state of the
disabled AP is implementation dependent. If an AP is enabled, then
the implementation must guarantee that a complete initialization
sequence is performed on the AP, so the AP is in a state that is
compatible with an MP operating system.</p>
<p>If the enable or disable AP operation cannot be completed prior to
the return from this service, then <strong>EFI_UNSUPPORTED</strong> must be
returned.</p>
<p><strong>Status Codes Returned</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The specified AP was enabled or disabled successfully.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_UNSUPPORTED</td>
<td>Enabling or disabling an AP cannot be completed prior to this service returning.</td>
</tr>
<tr class="row-odd"><td>EFI_UNSUPPORTED</td>
<td>Enabling or disabling an AP is not supported.</td>
</tr>
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>The calling processor is an AP.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td>Processor with the handle specified by <em>ProcessorNumber</em> does not exist.</td>
</tr>
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>ProcessorNumber</em> specifies the BSP.</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-mp-services-ppi-whoami">
<h3>EFI_MP_SERVICES_PPI.WhoAmI ()<a class="headerlink" href="#efi-mp-services-ppi-whoami" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>Identify the currently executing processor.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *PEI_MP_SERVICES_WHOAMI)(</strong></p>
<p><strong>IN CONST EFI_PEI_SERVICES **</strong><em>PeiServices</em><strong>,</strong></p>
<p><strong>IN EFI_MP_SERVICES_PPI *</strong><em>This</em><strong>,</strong></p>
<p><strong>OUT UINTN *</strong><em>ProcessorNumber</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>PeiServices</em></p>
<p>An indirect pointer to the PEI Services Table published by the PEI
Foundation.</p>
<p><em>This</em></p>
<p>A pointer to the <strong>EFI_MP_SERVICES_PPI</strong> instance.</p>
<p><a href="#id300"><span class="problematic" id="id301">*</span></a>ProcessorNumber *</p>
<p>The handle number of AP that is to become the new BSP. The range is
from 0 to the total number of logical processors minus 1. The total
number of logical processors can be retrieved by
<strong>EFI_MP_SERVICES_PPI.GetNumberOfProcessors()</strong>.</p>
<p><strong>Description</strong></p>
<p>This services returns the handle number for the calling processor.
This service may be called from the BSP and APs.</p>
<p>This service returns the processor handle number for the calling
processor.</p>
<p>The returned value is in the range from 0 to the total number of
logical processors minus 1. The total number of logical processors
can be retrieved with</p>
<p><strong>EFI_MP_SERVICES_PPI.GetNumberOfProcessors()</strong>. This service may
be called from the BSP and APs. If <em>ProcessorNumber</em> is NULL, then
<strong>EFI_INVALID_PARAMETER</strong> is returned. Otherwise, the current
processors handle number is returned in <em>ProcessorNumber</em>, and
<strong>EFI_SUCCESS</strong> is returned.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Additional PPIs</strong></p>
<blockquote>
<div><strong>Status Codes Returned</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The current processor handle number was returned in <em>ProcessorNumber</em>.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td><em>ProcessorNumber</em> is NULL.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="graphics-peim-interfaces">
<h2>8.4 Graphics PEIM Interfaces<a class="headerlink" href="#graphics-peim-interfaces" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There is one PEI to PEI Interfaces (PPI) that is required to provide
graphics functionality in the PEI phase.</p>
<p>The <strong>PeiGraphicsPpi</strong> is the PPI produced by the Graphics PEI
Module and provides interfaces to the platform code to complete the
basic initialization of the graphics subsystem to enable console
output.</p>
</div></blockquote>
<div class="section" id="pei-graphics-ppi">
<h3>8.4.1 Pei Graphics PPI<a class="headerlink" href="#pei-graphics-ppi" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The <strong>PeiGraphicsPpi</strong> is the main interface exposed by the Graphics
PEIM to be used by the other firmware modules.</p>
<p>The following sections cover the individual APIs in detail.</p>
<p><strong>GUID</strong></p>
<p><strong>#define EFI_PEI_GRAPHICS_PPI_GUID \</strong></p>
<p><a href="#id302"><span class="problematic" id="id303">**</span></a>{ 0x6ecd1463, 0x4a4a, 0x461b, **</p>
<p><strong>{0xaf, 0x5f, 0x5a, 0x33, 0xe3, 0xb2, 0x16, 0x2b }};</strong></p>
<p><strong>Prototype struct _EFI_PEI_GRAPHICS_PPI {</strong></p>
<p><strong>EFI_PEI_GRAPHICS_INIT</strong> <em>GraphicsPpiInit</em><strong>;</strong></p>
<p><strong>EFI_PEI_GRAPHICS_GET_MODE</strong> <em>GraphicsPpiGetMode</em><strong>;</strong></p>
<p><strong>} EFI_PEI_GRAPHICS_PPI;</strong></p>
</div></blockquote>
<p>Version 1.7 July 2018</p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="graphicsppiinit">
<h3>GraphicsPpiInit<a class="headerlink" href="#graphicsppiinit" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Description</strong></p>
<p>The <em>GraphicsPpiInit</em> initializes the graphics subsystem in phases.</p>
<p><strong>Calling Condition</strong></p>
<p>There are certain conditions to be met before the <em>GraphicsPpiInit</em>
can be called; Memory has been initialized.</p>
<p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GRAPHICS_INIT) (</strong></p>
<p><strong>IN VOID *</strong><em>GraphicsPolicyPtr</em><strong>;</strong></p>
<p><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>GraphicsPolicyPtr</em></p>
<p><em>GraphicsPolicyPtr</em> points to a configuration data block of policy
settings required by Graphics PEIM.</p>
<p><strong>Return</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">The invocation was successful.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>The phase parameter is not valid.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_ABORTED</td>
<td>The stages were not called in the proper order.</td>
</tr>
<tr class="row-even"><td>EFI_NOT_FOUND</td>
<td>The <strong>PeiGraphicsPlatformPolicyPpi</strong> is not located.</td>
</tr>
<tr class="row-odd"><td>EFI_DEVICE_ERROR</td>
<td>The initialization failed due to device error.</td>
</tr>
<tr class="row-even"><td>EFI_NOT_READY</td>
<td>The previous init stage is still in progress and not ready for the current initialization phase yet. The platform code should call this again sometime later..</td>
</tr>
</tbody>
</table>
<p>July 2018 Version 1.7</p>
</div>
<div class="section" id="graphicsppigetmode">
<h3>GraphicsPpiGetMode<a class="headerlink" href="#graphicsppigetmode" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Description</strong></p>
<p>The <strong>GraphicsPpiGetMode</strong> returns the mode information supported by
the Graphics PEI Module.</p>
<p>The frame buffer abstracts the video display as an array of pixels.
Each pixels location on the video display is defined by its X and Y
coordinates. The X coordinate represents a scan line. A scan line is
a horizontal line of pixels on the display. The Y coordinate
represents a vertical line on the display. The upper left hand
corner of the video display is defined as (0, 0) where the notation
(X, Y) represents the X and Y coordinate of the pixel. The lower
right corner of the video display is represented by (Width –1,
Height -1).</p>
<p>A pixel is comprised of a 32-bit quantity. The first three bytes for
each pixel represents the intensity for Red, Blue and Green colors.
The fourth byte is reserved and must be zero. The byte values for
the red, green, and blue components represent the color intensity.
This color intensity value range from a minimum intensity of 0 to
maximum intensity of 255.</p>
<p>The mode information returned by this PPI is similar to the GOP’s</p>
<p><strong>EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE</strong> structure.</p>
</div></blockquote>
<p><a class="reference internal" href="media/image6.png"><img alt="image3" src="media/image6.png" style="width: 6.39333in; height: 4.10333in;" /></a></p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><strong>Prototype typedef EFI_STATUS</strong></p>
<p><strong>(EFIAPI *EFI_PEI_GRAPHICS_GET_MODE) (</strong></p>
<p><strong>IN OUT EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE *</strong><em>Mode</em> <strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Mode</em></p>
<p>Pointer to <strong>EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE</strong> data. Type</p>
<p><strong>EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE</strong> is defined in the <em>UEFI
Specification</em> and in “Related Definitions” below.</p>
<p><strong>Return</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_SUCCESS</th>
<th class="head">Valid mode information was returned.</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_INVALID_PARAMETER</td>
<td>The <em>Mode</em> parameter is not valid.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_FOUND</td>
<td><p class="first">The <strong>PeiGraphicsPlatformPolicyPpi</strong> is not</p>
<p class="last">located.</p>
</td>
</tr>
<tr class="row-even"><td>EFI_DEVICE_ERROR</td>
<td>A hardware error occurred trying to retrieve the video mode.</td>
</tr>
<tr class="row-odd"><td>EFI_NOT_READY</td>
<td>The Graphics Initialization is not compete, and <em>Mode</em> information is not yet available.The platform code should call this again after the Graphics initialization is done.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><strong>typedef struct { UINT32 MaxMode;</strong></p>
<p><strong>UINT32 Mode;</strong></p>
<p><strong>EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *Info;</strong></p>
<p><strong>UINTN SizeOfInfo;</strong></p>
<p><strong>EFI_PHYSICAL_ADDRESS FrameBufferBase;</strong></p>
<p><strong>UINTN FrameBufferSize;</strong></p>
<p><strong>} EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE;</strong></p>
<p><strong>Related Definition – EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE</strong>
<em>MaxMode</em></p>
<p>The number of modes that is supported by this module.</p>
<p><em>Mode</em></p>
<p>Current mode of the graphics device. If the <em>MaxMode</em> is 1, then
this field will be 0.</p>
<p><em>Info</em></p>
<p>Pointer to <strong>EFI_GRAPHICS_OUTPUT_MODE_INFORMATION</strong> data. See
Related Definition below.</p>
<p><em>SizeOfInfo</em></p>
<p>Size of the <em>Info</em> structure in bytes.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<blockquote>
<div><p><em>FrameBufferBase</em></p>
<p>Base address of graphics linear frame buffer. <em>Info</em> contains
information required to allow software to draw directly to the frame
buffer.</p>
<p><em>FrameBufferSize</em></p>
<p>Size of the frame buffer represented by <em>FrameBufferBase</em> in bytes.</p>
</div></blockquote>
<p><strong>Related Definition – EFI_GRAPHICS_OUTPUT_MODE_INFORMATION typedef
struct {</strong></p>
<blockquote>
<div><p><strong>UINT32</strong> <em>Version</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>HorizontalResolution</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>VerticalResolution</em><strong>;</strong></p>
<p><strong>EFI_GRAPHICS_PIXEL_FORMAT</strong> <em>PixelFormat</em><strong>;</strong></p>
<p><strong>EFI_PIXEL_BITMASK</strong> <em>PixelInformation</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>PixelsPerScanLine</em><strong>;</strong></p>
<p><strong>} EFI_GRAPHICS_OUTPUT_MODE_INFORMATION;</strong></p>
<p><em>Version</em></p>
<p>The version of this data structure. A value of zero represents the
structure as defined in this specification. Future version of this
specification may extend this data structure in a backwards
compatible way and increase the value of Version.</p>
<p><em>HorizontalResolution</em></p>
<p>The size of video screen in pixels in the X dimension.</p>
<p><em>VerticalResolution</em></p>
<p>The size of video screen in pixels in the Y dimension.</p>
<p><em>PixelFormat</em></p>
<p>Enumeration that defines the physical format of the pixel. A value
of</p>
<p><em>PixelBltOnly</em></p>
<p>implies that a linear frame buffer is not available for this mode.</p>
<p><em>PixelInformation</em></p>
<p>This bit-mask is only valid if <em>PixelFormat</em> is set to
<em>PixelPixelBitMask</em>. A bit being set defines what bits are used for
what purpose such as Red, Green, Blue, or Reserved.</p>
<p><em>PixelsPerScanLine</em></p>
<p>Defines the number of pixel elements per video memory line. For
performance reasons, or due to hardware restrictions, scan lines may
be padded to an amount of memory alignment. These padding pixel
elements are outside the area covered by <em>HorizontalResolution</em> and
are not visible. For direct frame buffer access, this number is used
as a span between starts of pixel lines in video memory. Based on
the size of an individual pixel element and <em>PixelsPerScanline</em>, the
offset in video memory from pixel element (x, y) to pixel element
(x, y+1) has to be calculated as “sizeof( PixelElement) *
<em>PixelsPerScanLine</em>”, not “<em>sizeof</em>( PixelElement ) *</p>
</div></blockquote>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p><em>HorizontalResolution</em>”, though in many cases those values can
coincide. This value can depend on video hardware and mode
resolution.</p>
<p><strong>Related Definition – EFI_GRAPHICS_OUTPUT_MODE_INFORMATION
typedef enum {</strong></p>
<p><strong>PixelRedGreenBlueReserved8BitPerColor,</strong></p>
<p><strong>PixelBlueGreenRedReserved8BitPerColor,</strong></p>
<p><strong>PixelBitMask,</strong></p>
<p><strong>PixelBltOnly,</strong></p>
<p><strong>PixelFormatMax</strong></p>
<p><strong>} EFI_GRAPHICS_PIXEL_FORMAT;</strong></p>
<p><em>PixelRedGreenBlueReserved8BitPerColor</em></p>
<p>A pixel is 32-bits and byte zero represents red, byte one represents
green, byte two represents blue, and byte three is reserved. This is
the definition for the physical frame buffer. The byte values for
the red, green, and blue components represent the color intensity.
This color intensity value range from a minimum intensity of 0 to
maximum intensity of 255.</p>
<p><em>PixelBlueGreenRedReserved8BitPerColor</em></p>
<p>A pixel is 32-bits and byte zero represents blue, byte one
represents green, byte two represents red, and byte three is
reserved. This is the definition for the physical frame buffer. The
byte values for the red, green, and blue components represent the
color intensity. This color intensity value range from a minimum
intensity of 0 to maximum intensity of 255.</p>
<p><em>PixelBitMask</em></p>
<p>The pixel definition of the physical frame buffer is defined by</p>
<p><strong>*EFI_PIXEL_BITMASK*</strong></p>
<p><em>PixelBltOnly</em></p>
<p>This mode does not support a physical frame buffer.</p>
<p><strong>Related Definition – EFI_PIXEL_BITMASK typedef struct { UINT32</strong>
<em>RedMask</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>GreenMask</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>BlueMask</em><strong>;</strong></p>
<p><strong>UINT32 ReservedMask;</strong></p>
<p><strong>} EFI_PIXEL_BITMASK;</strong></p>
<p>If a bit is set in <em>RedMask</em>, <em>GreenMask</em>, or <em>BlueMask</em> then those
bits of the pixel represent the corresponding color. Bits in
<em>RedMask</em>, <em>GreenMask</em>, <em>BlueMask</em>, and</p>
<p><em>ReserveredMask</em> must not overlap bit positions. The values for the
red, green, and blue components in the bit mask represent the color
intensity. The color intensities must increase as the</p>
</div></blockquote>
<p>Version 1.7</p>
<blockquote>
<div>color values for each color mask increase with a minimum intensity
of all bits in a color mask clear to a maximum intensity of all bits
in a color mask set.</div></blockquote>
<p><strong>8.4.2 EFI PEI Graphics INFO HOB</strong></p>
<p><strong>Additional PPIs Platform Initialization Specification, Vol. 1</strong></p>
</div>
<div class="section" id="efi-pei-graphics-info-hob">
<h3>EFI_PEI_GRAPHICS_INFO_HOB<a class="headerlink" href="#efi-pei-graphics-info-hob" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>#define EFI_PEI_GRAPHICS_INFO_HOB_GUID \</strong></p>
<p><strong>{ 0x39f62cce, 0x6825, 0x4669,\</strong></p>
<p><strong>{ 0xbb, 0x56, 0x54, 0x1a, 0xba, 0x75, 0x3a, 0x07 }}</strong></p>
<p><strong>typedef struct {</strong></p>
<p><strong>EFI_PHYSICAL_ADDRESS</strong> <em>FrameBufferBase</em><strong>;</strong></p>
<p><strong>UINT32</strong> <em>FrameBufferSize</em><strong>;</strong></p>
<p><strong>EFI_GRAPHICS_OUTPUT_MODE_INFORMATION</strong> <em>GraphicsMode</em><strong>;</strong></p>
<p><strong>} EFI_PEI_GRAPHICS_INFO_HOB;</strong></p>
</div></blockquote>
</div>
<div class="section" id="efi-pei-graphics-device-info-hob">
<h3>EFI_PEI_GRAPHICS_DEVICE_INFO_HOB<a class="headerlink" href="#efi-pei-graphics-device-info-hob" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>#define EFI_PEI_GRAPHICS_DEVICE_INFO_HOB_GUID \</strong></p>
<p><strong>{ 0xe5cb2ac9, 0xd35d, 0x4430,\</strong></p>
<p><strong>{ 0x93, 0x6e, 0x1d, 0xe3, 0x32, 0x47, 0x8d, 0xe7 }}</strong></p>
<p></p>
<p><strong>typedef struct {</strong></p>
<p><strong>UINT16 VendorId</strong></p>
<p><strong>UINT16 DeviceId</strong></p>
<p><strong>UINT16 SubsystemVendorId</strong></p>
<p><strong>UINT16 SubsystemId;</strong></p>
<p><strong>UINT8 RevisionId;</strong></p>
<p><strong>UINT8 BarIndex;</strong></p>
<p><strong>} EFI_PEI_GRAPHICS_DEVICE_INFO_HOB;</strong></p>
<p>When graphics capability is included in PEI, it may optionally
provide a splash screen capability as well.</p>
<p>When graphics capability is included in PEI, it produces a
<strong>EFI_PEI_GRAPHICS_INFO_HOB</strong></p>
<p>which provides information about the graphics mode and the
framebuffer, and may optionally produce a
<strong>EFI_PEI_GRAPHICS_DEVICE_INFO_HOB</strong> which provides information
about the graphics device characteristics. The
<strong>EFI_GRAPHICS_OUTPUT_MODE_INFORMATION</strong> structure is defined in
the <em>UEFI specification</em>. This information can be used by the
HOB-consumer phase, such as DXE, to provide display support of its
own, or elide the need to do graphics initialization again in the
UEFI GOP driver, for example.</p>
<p>It is to be noted that the PEI phase may program a temporary
framebuffer address to complete its initialization and the
framebuffer address at the time of building the</p>
<p><strong>EFI_PEI_GRAPHICS_INFO_HOB</strong> will reflect the current
assignment. The post-PEI phase consuming this HOB should be aware
that a generic PCI enumeration logic could reprogram the temporary
resources assigned by the PEI phase and it is the responsibility of
the post-PEI phase to</p>
</div></blockquote>
<p>Version 1.7</p>
<blockquote>
<div><p>update its internal data structures with the new framebuffer address
after the enumeration is complete.</p>
<p>The EFI_PEI_GRAPHICS_DEVICE_INFO_HOB is optional. When it
exists, the DXE module which provides display support uses the
<strong>VendorId</strong>, <strong>DeviceId</strong>, <strong>RevisionId</strong>, <strong>SubsystemVendorId</strong>,
and <strong>SubsystemDeviceId</strong> in the HOB to match the graphics device.
It’s useful when system has multiple graphics devices and the DXE
module cannot know which one to manage without the information
provided by this HOB. If <strong>VendorId</strong>, <strong>DeviceId</strong>,
<strong>SubsystemVendorId</strong> or</p>
<p><strong>SubsystemDeviceId</strong> is set to MAX_UINT16, or <strong>RevisionId</strong> is
set to MAX_UINT8, that field will be ignored. The ID values that
are assigned to other values will be used to identify the graphics
device. The <strong>BarIndex</strong> tells DXE module which PCI MMIO BAR is used
to hold the frame buffer. BAR 0 is used if the <strong>BarIndex</strong> is set
to MAX_UINT8 or the HOB doesn’t exist.</p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="pei-to-dxe-handoff">
<h1>9 PEI to DXE Handoff<a class="headerlink" href="#pei-to-dxe-handoff" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id304">
<h2>9.1 Introduction<a class="headerlink" href="#id304" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The PEI phase of the system firmware boot process performs
rudimentary initialization of the system to meet specific minimum
system state requirements of the DXE Foundation. The PEI Foundation
must have a mechanism of locating and passing off control of the
system to the DXE Foundation. PEI must also provide a mechanism for
components of DXE and the DXE Foundation to discover the state of
the system when the DXE Foundation is invoked. Certain aspects of
the system state at handoff are architectural, while other system
state information may vary and hence must be described to DXE
components.</div></blockquote>
</div>
<div class="section" id="discovery-and-dispatch-of-the-dxe-foundation">
<h2>9.2 Discovery and Dispatch of the DXE Foundation<a class="headerlink" href="#discovery-and-dispatch-of-the-dxe-foundation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The PEI Foundation uses a special PPI named the DXE Initial Program
Load (IPL) PPI to discover and dispatch the DXE Foundation and
components that are needed to run the DXE Foundation</p>
<p>The final action of the PEI Foundation is to locate and pass control
to the DXE IPL PPI. To accomplish this, the PEI Foundation scans all
PPIs by GUID for the GUID matching the DXE IPL PPI. The GUID for
this PPI is defined in <strong>EFI_DXE_IPL_PPI</strong>.</p>
</div></blockquote>
</div>
<div class="section" id="passing-the-hand-off-block-hob-list">
<h2>9.3 Passing the Hand-Off Block (HOB) List<a class="headerlink" href="#passing-the-hand-off-block-hob-list" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The DXE IPL PPI passes the Hand-Off Block (HOB) list from PEI to the
DXE Foundation when it invokes the DXE Foundation. The handoff state
is described in the form of HOBs in the HOB list. The HOB list must
contain at least the HOBs listed in <em>Table 18</em>.</p>
<p><strong>Table 18. Required HOB Types in the HOB List</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Required HOB Type</strong></th>
<th class="head"><strong>Usage</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Phase Handoff Information Table (PHIT) HOB</td>
<td>This HOB is required.</td>
</tr>
<tr class="row-odd"><td>One or more Resource Descriptor HOB(s) describing physical system memory</td>
<td>The DXE Foundation will use this physical system memory for DXE.</td>
</tr>
<tr class="row-even"><td>Boot-strap processor (BSP) Stack HOB</td>
<td>The DXE Foundation needs to know the current stack location so that it can move it if necessary, based upon its desired memory address map. This HOB will be of type EfiConventionalMemory</td>
</tr>
<tr class="row-odd"><td><p class="first">BSP BSPStore (“Backing Store Pointer Store”)</p>
<p>HOB</p>
<p class="last"><strong>Note:</strong> Itanium processor family only</p>
</td>
<td>The DXE Foundation needs to know the current store location so that it can move it if necessary, based upon its desired memory address map.</td>
</tr>
<tr class="row-even"><td>One or more Resource Descriptor HOB(s) describing firmware devices</td>
<td>The DXE Foundation will place this into the GCD.</td>
</tr>
<tr class="row-odd"><td>One or more Firmware Volume HOB(s)</td>
<td>The DXE Foundation needs this information to begin loading other drivers in the platform.</td>
</tr>
</tbody>
</table>
<p>Version 1.7</p>
<p><strong>PEI to DXE Handoff</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>A Memory Allocation Module HOB</td>
<td>This HOB tells the DXE Foundation where it is when allocating memory into the initial system address map.</td>
</tr>
</tbody>
</table>
<blockquote>
<div>The above HOB types are defined in volume 3 of this
specification<em>.</em></div></blockquote>
</div>
<div class="section" id="handoff-processor-state-to-the-dxe-ipl-ppi">
<h2>9.4 Handoff Processor State to the DXE IPL PPI<a class="headerlink" href="#handoff-processor-state-to-the-dxe-ipl-ppi" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><em>Table 19</em> defines the state that processors must be in at handoff
to the DXE IPL PPI, for the following processors:</div></blockquote>
<ul>
<li><p class="first">IA-32 processors</p>
</li>
<li><p class="first">Itanium processor family</p>
</li>
<li><p class="first">Intel<sup>®</sup> processors using Intel<sup>®</sup> XScale™ technology</p>
<blockquote>
<div><p><strong>Table 19. Handoff Processor State to the DXE IPL PPI</strong></p>
</div></blockquote>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Processor</strong></th>
<th class="head"><strong>State at Handoff</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IA-32</td>
<td>In 32-bit flat mode</td>
</tr>
<tr class="row-odd"><td>Itanium</td>
<td>In Itanium processor family physical mode</td>
</tr>
<tr class="row-even"><td>Intel XScale</td>
<td>In SuperVisor Mode with a one-to-one virtual-to-physical mapping if there is a memory management unit (MMU) in the system</td>
</tr>
</tbody>
</table>
<p>Version 1.7 July 2018</p>
</div>
</div>
<div class="section" id="boot-paths">
<h1>10 Boot Paths<a class="headerlink" href="#boot-paths" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id305">
<h2>10.1 Introduction<a class="headerlink" href="#id305" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The PEI Foundation is unaware of the boot path required by the
system. It relies on the PEIMs to determine the boot mode (e.g. R0,
R1, S3, etc.) and take appropriate action depending on the mode. To
implement this, each PEIM has the ability to manipulate the boot
mode using the PEI Service <strong>SetBootMode()</strong> described in Services -
PEI.</p>
<p>The PEIM does not change the order in which PEIMs are dispatched
depending on the boot mode.</p>
</div></blockquote>
</div>
<div class="section" id="code-flow">
<h2>10.2 Code Flow<a class="headerlink" href="#code-flow" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The normal code flow in PI firmware passes through a succession of
phases, in the following order:</div></blockquote>
<ol class="arabic">
<li><p class="first">SEC</p>
</li>
<li><p class="first">PEI</p>
</li>
<li><p class="first">DXE</p>
</li>
<li><p class="first">BDS</p>
</li>
<li><p class="first">Runtime 6. Afterlife</p>
<blockquote>
<div><p>This section describes alternatives to this ordering.</p>
</div></blockquote>
</li>
</ol>
<div class="section" id="reset-boot-paths">
<h3>10.2.1 Reset Boot Paths<a class="headerlink" href="#reset-boot-paths" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The following sections describe the boot paths that are followed
when a system encounters several different types of reset.</div></blockquote>
<div class="section" id="intel-itanium-processor-reset">
<h4>10.2.1.1 Intel Itanium Processor Reset<a class="headerlink" href="#intel-itanium-processor-reset" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>Itanium architecture contains enough hooks to authenticate PAL-A and
PAL-B code that is distributed by the processor vendor. The internal
microcode on the processor silicon, which starts up on a PowerGood
reset, finds the first layer of processor abstraction code (called
PAL-A) that is located in the boot firmware volume (BFV), or the
volume that has SEC and the PEI core, using architecturally defined
pointers in the BFV. It is the responsibility of this microcode to
authenticate that the PAL-A code layer from the processor vendor has
not been tampered. If the authentication of the PAL-A layer passes,
control then passes to the PAL-A layer, which then authenticates the
next layer of processor abstraction code (called PAL-B) before
passing control to it. In addition to this
microarchitecture-specific authentication, the SEC phase of UEFI is
still responsible for locating the PEI Foundation and verifying its
authenticity.</p>
<p>In an Itanium-based system, it is also imperative that the firmware
modules in the BFV be organized such that at least the PAL-A is
contained in the fault-tolerant regions. This processor-specific
PALA authenticates the PAL-B code, which usually is contained in the
non-fault-tolerant regions of the firmware system. The PAL A and PAL
B binary components are always visible to all the processors in a
node at the time of power-on; the system fabric should not need to
be initialized.</p>
</div></blockquote>
<p>Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Boot Paths</strong></p>
</div>
<div class="section" id="non-power-on-resets">
<h4>10.2.1.2 Non-Power-on Resets<a class="headerlink" href="#non-power-on-resets" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>Non-power-on resets can occur for many reasons. There are PEI and
DXE system services that reset and reboot the entire platform,
including all processors and devices. It is important to have a
standard variant of this boot path for cases such as the following:</div></blockquote>
<ul>
<li><p class="first">Resetting the processor to change frequency settings</p>
</li>
<li><p class="first">Restarting hardware to complete chipset initialization</p>
</li>
<li><p class="first">Responding to an exception from a catastrophic error</p>
<blockquote>
<div><p>This reset is also used for Configuration Values Driven through
Reset (CVDR) configuration.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="normal-boot-paths">
<h2>10.3 Normal Boot Paths<a class="headerlink" href="#normal-boot-paths" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A traditional BIOS executes POST from a cold boot (G3 to S0 state),
on resumes, or in special cases like INIT. UEFI covers all those
cases but provides a richer and more standardized operating
environment</p>
<p>The basic code flow of the system needs to be changeable due to
different circumstances. The boot path variable satisfies this need.
The initial value of the boot mode is defined by some early PEIMs,
but it can be altered by other, later PEIM(s). All systems must
support a basic S0 boot path. Typically a system has a more rich set
of boot paths, including S0 variations, S-state boot paths, and one
or more special boot paths.</p>
<p>The architecture for multiple boot paths presented here has several
benefits, as follows:</p>
</div></blockquote>
<ul>
<li><p class="first">The PEI Foundation is not required to be aware of system-specific
requirements such as MP and various power states. This lack of
awareness allows for scalability and headroom for future expansion.</p>
</li>
<li><p class="first">Supporting the various paths only minimally impacts the size of the
PEI Foundation.</p>
</li>
<li><p class="first">The PEIMs that are required to support the paths scale with the
complexity of the system.</p>
<blockquote>
<div><p>Note that the Boot Mode Register becomes a variable upon transition
to the DXE phase. The DXE phase can have additional modifiers that
affect the boot path more than the PEI phase.</p>
<p>These additional modifiers can indicate if the system is in
manufacturing mode, chassis intrusion, or AC power loss or if silent
boot is enabled.</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="basic-g0-to-s0-and-s0-variation-boot-paths">
<h3>10.3.1 Basic G0-to-S0 and S0 Variation Boot Paths<a class="headerlink" href="#basic-g0-to-s0-and-s0-variation-boot-paths" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The basic S0 boot path is “boot with full configuration.” This path
setting informs all PEIMs to do a full configuration. The basic S0
boot path must be supported.</p>
<p>The Framework architecture also defines several optional variations
to the basic S0 boot path. The variations that are supported depend
on the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Richness of supported features</p>
</li>
<li><p class="first">If the platform is open or closed</p>
</li>
<li><p class="first">Platform hardware</p>
<blockquote>
<div><p>For example, a closed system or one that has detected a chassis
intrusion could support a boot path that assumes no configuration
changes from last boot option, thus allowing a very rapid boot time.</p>
</div></blockquote>
</li>
</ul>
<p>Version 1.7</p>
<p><strong>Boot Paths Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div>Unsupported variations default to basic S0 operation. The following
are the defined variations to the basic boot path:</div></blockquote>
<ul>
<li><p class="first">Boot with minimal configuration:</p>
<blockquote>
<div><p>This path is for configuring the minimal amount of hardware to boot
the system.</p>
</div></blockquote>
</li>
<li><p class="first">Boot assuming no configuration changes:</p>
<blockquote>
<div><p>This path uses the last configuration data.</p>
</div></blockquote>
</li>
<li><p class="first">Boot with full configuration plus diagnostics:</p>
<blockquote>
<div><p>This path also causes any diagnostics to be executed.</p>
</div></blockquote>
</li>
<li><p class="first">Boot with default settings: This path uses a known set of safe values
for programming hardware.</p>
</li>
</ul>
</div>
<div class="section" id="s-state-boot-paths">
<h3>10.3.2 S-State Boot Paths<a class="headerlink" href="#s-state-boot-paths" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The following optional boot paths allow for different operation for
a resume from S3, S4, and S5:</div></blockquote>
<ul>
<li><p class="first">S3 (Save to RAM Resume): Platforms that support S3 resume must take
special care to preserve/restore memory and critical hardware.</p>
</li>
<li><p class="first">S4 (Save to Disk): Some platforms may want to perform an abbreviated
PEI and DXE phase on a S4 resume.</p>
</li>
<li><p class="first">S5 (Soft Off): Some platforms may want an S5 system state boot to be
differentiated from a normal boot-for example, if buttons other than
the power button can wake the system.</p>
<blockquote>
<div><p>An S3 resume needs to be explained in more detail because it
requires cooperation between a G0-toS0 boot path and an S3 resume
boot path. The G0-to-S0 boot path needs to save hardware programming
information that the S3 resume path needs to retrieve.</p>
<p>This information is saved in the Hardware Save Table using
predefined data structures to perform I/ O or memory writes. The
data is stored in an UEFI equivalent of the INT15 E820 type 4
(firmware reserved memory) area or a firmware device area that is
reserved for use by UEFI. The S3 resume boot path code can access
this region after memory has been restored.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="recovery-paths">
<h2>10.4 Recovery Paths<a class="headerlink" href="#recovery-paths" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>All of the above boot paths can be modified or aborted if the system
detects that recovery is needed. Recovery is the process of
reconstituting a system’s firmware devices when they have become
corrupted. The corruption can be caused by various mechanisms. Most
firmware volumes on nonvolatile storage devices (flash, disk) are
managed as blocks. If the system loses power while a block, or
semantically bound blocks, are being updated, the storage might
become invalid. On the other hand, the device might become corrupted
by an errant program or by errant hardware. The system designers
must determine the level of support for recovery based on their
perceptions of the probabilities of these events occurring and their
consequences.</p>
<p>The following are some reasons why system designers may choose to
not support recovery:</p>
</div></blockquote>
<ul class="simple">
<li>A system’s firmware volume storage media might not support
modification after being manufactured. It might be the functional
equivalent of a ROM.</li>
<li>Most mechanisms of implementing recovery require additional firmware
volume space, which might be too expensive for a particular
application.</li>
</ul>
<p>Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Boot Paths</strong></p>
<ul class="simple">
<li>A system may have enough firmware volume space and hardware features
that the firmware volume can be made sufficiently fault tolerant to
make recovery unnecessary.</li>
</ul>
<div class="section" id="discovery">
<h3>10.4.1 Discovery<a class="headerlink" href="#discovery" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Discovering that recovery is done using a PEIM (for example, by
checking a “force recovery” jumper).</div></blockquote>
</div>
<div class="section" id="general-recovery-architecture">
<h3>10.4.2 General Recovery Architecture<a class="headerlink" href="#general-recovery-architecture" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The concept behind recovery is to preserve enough of the system
firmware so that the system can boot to a point where it can do the
following:</div></blockquote>
<ul>
<li><p class="first">Read a copy of the data that was lost from chosen peripherals.</p>
</li>
<li><p class="first">Reprogram the firmware volume with that data.</p>
<blockquote>
<div><p>Preserving the recovery firmware is a function of the way the
firmware volume store is managed, which is generally beyond the
scope of this document.</p>
<p>The PI recovery architecture allows for one or many PEIMs to be
built to handle the portion of the recovery that would initialize
the recovery peripherals (and the buses they reside on) and then to
read the new images from the peripherals and update the firmware
volumes.</p>
<p>It is considered far more likely that the PEI will transition to DXE
because DXE is designed to handle access to peripherals. This
transition has the additional benefit that, if DXE then discovers
that a device has become corrupted, it may institute recovery
without transferring control back to the PEI.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="defined-boot-modes">
<h2>10.5 Defined Boot Modes<a class="headerlink" href="#defined-boot-modes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The list of possible boot modes is described in the
<strong>GetBootMode()</strong> function description. PI architecture specifically
does not define an upgrade path if new boot modes are defined. This
is necessary as the nature of those additional boot modes may work
in conjunction with or may conflict with the previously defined boot
modes.</div></blockquote>
</div>
<div class="section" id="priority-of-boot-paths">
<h2>10.6 Priority of Boot Paths<a class="headerlink" href="#priority-of-boot-paths" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Within a given PEIM, the priority ordering of the sources of boot
mode should be as follows (from highest priority to lowest):</div></blockquote>
<ol class="arabic simple">
<li><a href="#id306"><span class="problematic" id="id307">**</span></a>BOOT_IN_RECOVERY_MODE **</li>
<li><a href="#id308"><span class="problematic" id="id309">**</span></a>BOOT_ON_FLASH_UPDATE **</li>
<li><a href="#id310"><span class="problematic" id="id311">**</span></a>BOOT_ON_S3_RESUME **</li>
<li><a href="#id312"><span class="problematic" id="id313">**</span></a>BOOT_WITH_MINIMAL_CONFIGURATION **</li>
<li><a href="#id314"><span class="problematic" id="id315">**</span></a>BOOT_WITH_FULL_CONFIGURATION **</li>
<li><a href="#id316"><span class="problematic" id="id317">**</span></a>BOOT_ASSUMING_NO_CONFIGURATION_CHANGES **</li>
<li><a href="#id318"><span class="problematic" id="id319">**</span></a>BOOT_WITH_FULL_CONFIGURATION_PLUS_DIAGNOSTICS **</li>
<li><strong>BOOT_WITH_DEFAULT_SETTINGS</strong></li>
</ol>
<p>Version 1.7</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><p class="first"><strong>Boot Paths</strong></p>
<ol class="last arabic simple" start="9">
<li><a href="#id320"><span class="problematic" id="id321">**</span></a>BOOT_ON_S4_RESUME **</li>
<li><a href="#id322"><span class="problematic" id="id323">**</span></a>BOOT_ON_S5_RESUME **</li>
<li><a href="#id324"><span class="problematic" id="id325">**</span></a>BOOT_ON_S2_RESUME **</li>
</ol>
</td>
<td><strong>Platform Initialization Specification, Vol. 1</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<div>The boot modes listed above are defined in the PEI Service
<strong>SetBootMode()</strong>.</div></blockquote>
</div>
<div class="section" id="assumptions">
<h2>10.7 Assumptions<a class="headerlink" href="#assumptions" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><em>Table 20</em> lists the assumptions that can be made about the system
for each sleep state.</p>
<p><strong>Table 20. Boot Path Assumptions</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="4%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>System State</strong></th>
<th class="head"><strong>Description</strong></th>
<th class="head"><strong>Assumptions</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>R0</td>
<td>Cold Boot</td>
<td>Cannot assume that the previously stored configuration data is valid.</td>
</tr>
<tr class="row-odd"><td>R1</td>
<td>Warm Boot</td>
<td>May assume that the previously stored configuration data is valid.</td>
</tr>
<tr class="row-even"><td>S3</td>
<td><p class="first">ACPI Save to RAM</p>
<p class="last">Resume</p>
</td>
<td>The previously stored configuration data is valid and RAM is valid. RAM configuration must be restored from nonvolatile storage (NVS) before RAM may be used. The firmware may only modify previously reserved RAM. There are two types of reserved memory. One is the equivalent of the BIOS INT15h, E820 type-4 memory and indicates that the RAM is reserved for use by the firmware. The suggestion is to add another type of memory that allows the OS to corrupt the memory during runtime but that may be overwritten during resume.</td>
</tr>
<tr class="row-odd"><td><p class="first">S4, </p>
<p class="last">S5</p>
</td>
<td><p class="first">Save to Disk Resume,</p>
<p class="last">“Soft Off”</p>
</td>
<td>S4 and S5 are identical from a PEIM’s point of view. The two are distinguished to support follow-on phases. The entire system must be reinitialized but the PEIMs may assume that the previous configuration is still valid.</td>
</tr>
<tr class="row-even"><td><p class="first">Boot on Flash</p>
<p class="last">Update</p>
</td>
<td>&#160;</td>
<td><p class="first">This boot mode can be either an INIT, S3, or other means by which to restart the machine. If it is an S3, for example, the flash update cause will supersede the S3 restart. It is incumbent upon platform code, such as the Memory</p>
<p class="last">Initialization PEIM, to determine the exact cause and perform correct behavior (i.e., S3 state restoration versus INIT behavior).</p>
</td>
</tr>
<tr class="row-odd"><td><p class="first">Boot with</p>
<p>Manufacturing</p>
<p class="last">Mode settings</p>
</td>
<td>&#160;</td>
<td>PEIM’s and/or DXE drivers may parameterize based upon actions that should only occur in the factory or a manufacturer approved setting.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="architectural-boot-mode-ppis">
<h2>10.8 Architectural Boot Mode PPIs<a class="headerlink" href="#architectural-boot-mode-ppis" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There is a possible hierarchy of boot mode PPIs that abstracts the
various producers of this variable.</p>
<p>It is a hierarchy in that there should be an order of precedence in
which each mode can be set. The</p>
<p>PPIs and their respective GUIDs are described in <em>“Required
Architectural PPIs” on page 80</em> and</p>
<p><em>“Optional Architectural PPIs” on page 85</em>. The hierarchy includes
the master PPI, which publishes a</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Boot Paths</strong></p>
<blockquote>
<div><p>PPI that will be depended upon by the appropriate PEIMs, and some
subsidiary PPI. For PEIMs that require that the boot mode is finally
known, the Master Boot Mode PPI can be used as a dependency.</p>
<p><em>Table 21</em> lists the architectural boot mode PPIs.</p>
<p><strong>Table 21. Architectural Boot Mode PPIs</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="29%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>PPI Name</strong></th>
<th class="head"><strong>Required or Optional?</strong></th>
<th class="head"><strong>PPI Definition in Section…</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Master Boot Mode PPI</td>
<td>Required</td>
<td><p class="first">Architectural PPIs: Required Architectural</p>
<p class="last">PPIs</p>
</td>
</tr>
<tr class="row-odd"><td>Boot in Recovery Mode PPI</td>
<td>Optional</td>
<td><p class="first">Architectural PPIs: Optional Architectural</p>
<p class="last">PPIs</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id326">
<h2>10.9 Recovery<a class="headerlink" href="#id326" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scope">
<h3>10.9.1 Scope<a class="headerlink" href="#scope" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Recovery is the process of reconstituting a system’s firmware
devices when they have become corrupted. The corruption can be
caused by various mechanisms. Most firmware volumes (FVs) in
nonvolatile storage (NVS) devices (flash or disk, for example) are
managed as blocks. If the system loses power while a block, or
semantically bound blocks, are being updated, the storage might
become invalid. On the other hand, an errant program or hardware
could corrupt the device. The system designers must determine the
level of support for recovery based on their perceptions of the
probabilities of these events occurring and the consequences.</p>
<p>The designers of a system may choose not to support recovery for the
following reasons:</p>
</div></blockquote>
<ul class="simple">
<li>A system’s FV storage media might not support modification after
being manufactured. It might be the functional equivalent of a ROM.</li>
<li>Most mechanisms of implementing recovery require additional FV space
that might be too expensive for a particular application.</li>
<li>A system may have enough FV space and hardware features that the FV
can be made sufficiently fault tolerant to make recovery unnecessary.</li>
</ul>
</div>
<div class="section" id="id327">
<h3>10.9.2 Discovery<a class="headerlink" href="#id327" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Discovering that recovery is required may be done using a PEIM (for
example, by checking a “force recovery” jumper) or the PEI
Foundation itself. The PEI Foundation might discover that a
particular PEIM has not validated correctly or that an entire
firmware has become corrupted.</div></blockquote>
</div>
<div class="section" id="id328">
<h3>10.9.3 General Recovery Architecture<a class="headerlink" href="#id328" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The concept behind recovery is to preserve enough of the system
firmware so that the system can boot to a point where it can do the
following:</div></blockquote>
<ul class="simple">
<li>Read a copy of the data that was lost from chosen peripherals.</li>
<li>Reprogram the firmware volume (FV) with that data.</li>
</ul>
<p>Version 1.7 July 2018</p>
<p><strong>Boot Paths Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p>Preserving the recovery firmware is a function of the way the FV
store is managed, which is generally beyond the scope of this
document.</p>
<p>If the PEI Dispatcher encounters PEIMs that have been corrupted (for
example, by receiving an incorrect hash value), it must change the
boot mode to “recovery.” Once set to recovery, other PEIMs must not
change it to one of the other states.</p>
<p>A PEIM can also detect a catastrophic condition or a forced-recovery
event and alert the PEI 10.6.4 Finding and Loading the Recovery DXE
Image.</p>
</div></blockquote>
</div>
<div class="section" id="finding-and-loading-the-recovery-dxe-image">
<h3>10.9.4 Finding and Loading the Recovery DXE Image<a class="headerlink" href="#finding-and-loading-the-recovery-dxe-image" title="Permalink to this headline">¶</a></h3>
<div class="section" id="finding-the-recovery-dxe-image-overview">
<h4>10.9.4.1 Finding the Recovery DXE Image: Overview<a class="headerlink" href="#finding-the-recovery-dxe-image-overview" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The PEI Dispatcher specifically invokes the DXE Initial Program Load
(IPL) PEIM, regardless of normal or recovery mode. The DXE IPL PEIM
detects that a recovery is in process and invokes a</p>
<p>recovery-specific PPI, the Recovery Module PPI. The Recovery Module
PPI, <strong>EFI_PEI_RECOVERY_MODULE_PPI,</strong> does the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Loads a binary capsule that includes a recovery DXE image into memory</p>
</li>
<li><p class="first">Updates the Hand-Off Block (HOB) table with the DXE firmware volume</p>
</li>
<li><p class="first">Installs or Reinstalls instance of the Firmware Volume Info PPI</p>
<blockquote>
<div><p>(<strong>EFI_PEI_FIRMWARE_VOLUME_INFO_PPI)</strong> for the DXE firmware
volume</p>
<p>See Section 8.6.3 for the PPIs that are needed to load the DXE
image.</p>
</div></blockquote>
</li>
</ul>
<p><strong>*Note:</strong> The Recovery Module PPI is device and content neutral. The
DXE IPL PEIM uses the Recovery Module PPI to load a DXE image and
invokes the DXE image normally. The DXE IPL PEIM does not know or care
about the capsule’s internal structure or from which device the capsule
was loaded.*</p>
<blockquote>
<div>The internals of the recovery PEIM normally fall within four phases:</div></blockquote>
<ul>
<li><p class="first">Searching the supported devices for recovery capsules</p>
</li>
<li><p class="first">Deciding which capsule to load</p>
</li>
<li><p class="first">Loading the capsule into memory</p>
</li>
<li><p class="first">Loading the resulting DXE firmware volume</p>
<blockquote>
<div><p>The Recovery Module PPI encompasses the first three phases and the
DXE IPL PEIM encompasses the last phase. See the next topic,
Recovery Sequence: Detailed Steps, for the details of these four
phases.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="recovery-sequence">
<h4>10.9.4.2 Recovery Sequence<a class="headerlink" href="#recovery-sequence" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The normal, non-recovery sequence is that after completion of the
PEI phase, the PEI Dispatcher specifically invokes the DXE Initial
Program Load (IPL) PEIM. The recovery sequence is identical to the
non-recovery sequence in that the PEI Dispatcher also specifically
invokes the DXE IPL PEIM. After invoking the DXE IPL PEIM, the
recovery sequence is as follows:</div></blockquote>
<ol class="arabic">
<li><p class="first">The DXE IPL PEIM detects that a recovery is in process, searches for
the Recovery Module PPI, and invokes the recovery function</p>
<blockquote>
<div><p><strong>EFI_PEI_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()</strong>.</p>
</div></blockquote>
</li>
</ol>
<p>July 2018 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Boot Paths</strong></p>
<ol class="arabic">
<li><p class="first"><strong>EFI_PEI_RECOVERY_MODULE_PPI</strong> searches for one or more
instances of the Device Recovery Module PPI,
<strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</strong>. For each instance found,
the</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.GetNumberRecoveryCapsules()</strong>
function is invoked to determine the following:</p>
</div></blockquote>
</li>
</ol>
<ul class="simple">
<li>The number of recovery DXE capsules detected by the specified device</li>
<li>The maximum buffer size required to load a capsule</li>
</ul>
<ol class="arabic">
<li><p class="first"><strong>EFI_PEI_RECOVERY_MODULE_PPI</strong> then decides the following:</p>
<ul class="simple">
<li>The device search order, if more than one Device Recovery Module
PPI was discovered</li>
<li>The individual search order, if the device reported more than one
recovery DXE capsule was found generating a search order list</li>
</ul>
</li>
<li><p class="first"><strong>EFI_PEI_RECOVERY_MODULE_PPI</strong> invokes the device recovery
function</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI.LoadRecoveryCapsule()</strong> to
load a</p>
<p>capsule that includes a recovery DXE image into memory. The capsule
that is returned from the device recovery module is a capsule that
contains the recovery DXE image.</p>
</div></blockquote>
</li>
</ol>
<ol class="arabic">
<li><p class="first">The <strong>EFI_PEI_RECOVERY_MODULE_PPI</strong> security does the following:</p>
<ul class="simple">
<li>Verifies the capsule</li>
<li>Generates a data Hand-Off Block (HOB) entry for a security failure</li>
<li>Tries the next entry in the search order list</li>
</ul>
</li>
<li><p class="first">Once a valid capsule has been loaded,
<strong>EFI_PEI_RECOVERY_MODULE_PPI</strong> does the following:</p>
<ul class="simple">
<li>Decomposes the capsule and updates the HOB table with the recovery
DXE firmware volume information. The path parameters are assumed
to be redundant for recovery. The Setup parameters are either
redundant or fixed.</li>
<li>Invalidates all HOB entries for updateable firmware volume
entries.</li>
</ul>
<blockquote>
<div><p>The DXE capsule that is loaded by the Device Recovery Module PPI
makes no assumptions about contents or format other than assuming
that the recovery DXE image is somewhere in the returned capsule.</p>
<p>The following subsections describe the different recovery PPIs.</p>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="recovery-ppis-recovery-module-ppi">
<h4>10.9.4.3 Recovery PPIs: Recovery Module PPI<a class="headerlink" href="#recovery-ppis-recovery-module-ppi" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div>The Recovery Module PPI, <strong>EFI_PEI_RECOVERY_MODULE_PPI</strong>,
invokes the Device Recovery Module <strong>PPI
EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</strong> to do the following:</div></blockquote>
<ul>
<li><p class="first">Determine the number of DXE recovery capsules found by each device</p>
</li>
<li><p class="first">Determine capsule information</p>
</li>
<li><p class="first">Load a specific DXE recovery capsule from the indicated device</p>
</li>
<li><p class="first">Determine the device load order</p>
<blockquote>
<div><p>The capsule is security verified and decomposed and the HOB table is
updated with the DXE recovery firmware volume.</p>
<p>There are two general categories of recovery PPIs:</p>
</div></blockquote>
</li>
<li><p class="first">Device recovery PPI</p>
</li>
</ul>
<p><strong>Boot Paths Platform Initialization Specification, Vol. 1</strong></p>
<ul>
<li><p class="first">Device recovery block I/O PPI</p>
<blockquote>
<div><p>The Device Recovery Module PPI is device neutral. The Device
Recovery Block I/O PPI is device specific and used to access the
physical media. The following subsections describe the PPI
associated with each category. See Code Definitions for the
definitions of these PPIs.</p>
</div></blockquote>
</li>
</ul>
<p><strong>10.9.4.3.1 Device Recovery Module PPI</strong> The table below lists the
device recovery functions in the Device Recovery Module PPI,</p>
<blockquote>
<div><p><strong>EFI_PEI_DEVICE_RECOVERY_MODULE_PPI</strong>.</p>
<p><strong>Table 22. Device Recovery Module Functions</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Function</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GetNumberRecoveryCapsules()</td>
<td>Scans the devices that are supported by the PPI for DXE recovery capsules and reports the number found. The internal ordering should reflect the priority in the load order, with the highest priority capsule number set to one and the lowest priority number set to <a href="#id329"><span class="problematic" id="id330">*</span></a>N. *</td>
</tr>
<tr class="row-odd"><td>GetRecoveryCapsuleInfo()</td>
<td><p class="first">Provides the size of the indicated capsule and a <em>CapsuleType</em></p>
<p class="last">Globally Unique Identifier (GUID). The recovery module uses this information to allow an alternate priority scheme based on the <em>CapsuleType</em> information.</p>
</td>
</tr>
<tr class="row-even"><td>LoadRecoveryCapsule()</td>
<td>Loads the indicated DXE recovery capsule instance and returns a capsule with the actual number of bytes loaded.</td>
</tr>
</tbody>
</table>
<p><strong>10.9.4.3.2 Device Recovery Block I/O PPI</strong> The Device Recovery Block
I/O PPI, <strong>EFI_PEI_RECOVERY_BLOCK_IO_PPI</strong>, differs from the</p>
<blockquote>
<div><p>Device Recovery Module PPI in that the Device Recovery Block I/O PPI
is used for physical media access. The Device Recovery Module PPI
uses this PPI to search for capsules. This PPI is included with the
recovery PEIMs because a block I/O is the most common recovery
media.</p>
<p>The table below lists the functions in the Device Recovery Block I/O
PPI.</p>
<p><strong>Table 23. Device Recovery Block I/O Functions</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Function</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GetNumberOfBlockDevices()</td>
<td>Returns the number of block I/O devices supported<em>.</em> There is no ordering priority.</td>
</tr>
<tr class="row-odd"><td>GetBlockDeviceMediaInfo()</td>
<td>Indicates the type of block I/O device found, such as a legacy floppy or CDROM<em>.</em> The block size and last block number are also returned.</td>
</tr>
<tr class="row-even"><td>ReadBlocks()</td>
<td>Reads the indicated block I/O device starting at the given logical block address (LBA) and for buffer size/block size.</td>
</tr>
</tbody>
</table>
<p>July 2018 Version 1.7</p>
</div>
</div>
</div>
</div>
<div class="section" id="pei-physical-memory-usage">
<h1>11 PEI Physical Memory Usage<a class="headerlink" href="#pei-physical-memory-usage" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id331">
<h2>11.1 Introduction<a class="headerlink" href="#id331" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>This section describes how physical system memory is used during
PEI. The rules for using physical system memory are different before
and after permanent memory registration within the PEI execution.</div></blockquote>
</div>
<div class="section" id="before-permanent-memory-is-installed">
<h2>11.2 Before Permanent Memory Is Installed<a class="headerlink" href="#before-permanent-memory-is-installed" title="Permalink to this headline">¶</a></h2>
<div class="section" id="discovering-physical-memory">
<h3>11.2.1 Discovering Physical Memory<a class="headerlink" href="#discovering-physical-memory" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Before permanent memory is installed, the minimum exit condition for
the PEI phase is that it has enough physical system memory to run
PEIMs and the DXE IPL PPI that require permanent memory. These
memory-aware PEIMs may discover and initialize additional system
memory, but in doing so they must not cause loss of data in the
physical system memory initialized during the earlier phase. The
required amount of memory initialized and tested by PEIMs in these
two phases is platform dependent.</p>
<p>Before permanent memory is installed, a PEIM may not assume any area
of physical memory is present and initialized. During this early
phase, a PEIM—usually one specific to the chipset memory
controller—will initialize and test physical memory. When this PEIM
has initialized and tested the physical memory, it will register the
memory using the PEI Memory Service <strong>InstallPeiMemory()</strong>, which in
turn will cause the PEI Foundation to create an initial HandOff
Block (HOB) list and describe the memory. The memory that is
present, initialized, and tested will reside in resource descriptor
HOBs in the initial HOB list (see <em>Volume 3</em> for more information).
This memory allocation PEIM may also choose to allocate some of this
physical memory by doing the following:</p>
</div></blockquote>
<ul>
<li><p class="first">Creating memory allocation HOBs, as described in <em>“Allocating Memory
Using GUID Extension HOBs” on page 220</em>.</p>
</li>
<li><p class="first">Using the memory allocation services <strong>AllocatePages()</strong> and
<strong>AllocatePool()</strong></p>
<blockquote>
<div><p>Once permanent memory has been installed, the resources described in
the HOB list are considered permanent system memory.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="using-physical-memory">
<h3>11.2.2 Using Physical Memory<a class="headerlink" href="#using-physical-memory" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>A PEIM that requires permanent, fixed memory allocation must
schedule itself to run after
<strong>EFI_PEI_PERMANENT_MEMORY_INSTALLED_PPI</strong> is installed. To
schedule itself, the PEIM can do one of the following:</div></blockquote>
<ul>
<li><p class="first">Put this PPI’s GUID into the depex of the PEIM.</p>
</li>
<li><p class="first">Register for a notification.</p>
<blockquote>
<div><p>The PEIM can then allocate Hand-Off Blocks (HOBs) and other memory
using the same mechanisms described in <em>“Allocating Physical Memory”
on page 220</em>.</p>
</div></blockquote>
</li>
</ul>
<p><strong>PEI Physical Memory Usage Platform Initialization Specification, Vol.
1</strong></p>
<blockquote>
<div>The <strong>AllocatePool()</strong> service can be invoked at any time during the
boot phase to discover temporary memory that will have its location
translated, even before permanent memory is installed.</div></blockquote>
</div>
</div>
<div class="section" id="after-permanent-memory-is-installed">
<h2>11.3 After Permanent Memory Is Installed<a class="headerlink" href="#after-permanent-memory-is-installed" title="Permalink to this headline">¶</a></h2>
<div class="section" id="allocating-physical-memory">
<h3>11.3.1 Allocating Physical Memory<a class="headerlink" href="#allocating-physical-memory" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>After permanent memory is installed, PEIMs may allocate memory in
four ways:</div></blockquote>
<ul class="simple">
<li>Using a GUID Extension HOB</li>
<li>Within the PEI free memory space</li>
</ul>
</div>
<div class="section" id="allocating-memory-using-guid-extension-hobs">
<h3>11.3.2 Allocating Memory Using GUID Extension HOBs<a class="headerlink" href="#allocating-memory-using-guid-extension-hobs" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A PEIM may allocate memory for its private use by constructing a
GUID Extension HOB and using the private data area defined by the
GUIDed name of the HOB for private data storage.</p>
<p>See <em>Volume 3</em> for HOB construction rules.</p>
</div></blockquote>
</div>
<div class="section" id="allocating-memory-using-pei-service">
<h3>11.3.3 Allocating Memory Using PEI Service<a class="headerlink" href="#allocating-memory-using-pei-service" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A PEIM may allocate memory using the PEI Service
<strong>AllocatePages()</strong>. Use the</p>
<p><strong>EFI_MEMORY_TYPE</strong> values to specify the type of memory to
allocate; type <strong>EFI_MEMORY_TYPE</strong> is defined is defined in
<strong>AllocatePages()</strong> in the UEFI 2.0 specification.</p>
</div></blockquote>
<p>July 2018 Version 1.7</p>
<blockquote>
<div><a href="#id332"><span class="problematic" id="id333">**</span></a>12 Special Paths Unique to the **</div></blockquote>
</div>
</div>
</div>
<div class="section" id="itanium-processor-family">
<h1>Itanium<sup>®</sup> Processor Family<a class="headerlink" href="#itanium-processor-family" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id334">
<h2>12.1 Introduction<a class="headerlink" href="#id334" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The Itanium processor family supports the full complement of boot
modes listed in the PEI CIS. In addition, however, Itanium®
architecture requires an augmented flow. This flow includes a
“recovery check call” in which all processors execute the PEI
Foundation when an Itanium platform restarts. Each processor has its
own version of temporary memory such that there are as many
concurrent instances of PEI execution as there are Itanium
processors.</p>
<p>There is a point in the multiprocessor flow, however, when all
processors have to call back into the</p>
<p>Processor Abstraction Layer A (PAL-A) component to assess whether
the processor revisions and PAL-B binaries are compatible. This
callback into the PAL-A does not preserve the state of the temporary
memory, however. When the PAL-A returns control back to the various
processors, the PEI Foundation and its associated data structures
have to be reinstantiated.</p>
<p>At this point, however, the flow of the PEI phase is the same as for
IA-32 Intel architecture in that all processors make forward
progress up through invoking the DXE IPL PPI<strong>.</strong></p>
</div></blockquote>
</div>
<div class="section" id="unique-boot-paths-for-itanium-architecture">
<h2>12.2 Unique Boot Paths for Itanium Architecture<a class="headerlink" href="#unique-boot-paths-for-itanium-architecture" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Intel<sup>®</sup> Itanium processors possess two unique boot paths
that also invoke the dispatcher located at the System Abstraction
Layer entry point (SALE_ENTRY):</div></blockquote>
<ul>
<li><p class="first">Processor INIT</p>
</li>
<li><p class="first">Machine Check (MCHK)</p>
<blockquote>
<div><p>INIT and MCHK are two asynchronous events that start up the Security
(SEC) code/dispatcher in an Itanium®-based system. The PI
Architecture security module is transparent during all the code
paths except for the recovery check call that happens during a cold
boot. The PEIMs that handle these events are architecture aware and
do not return control to the PEI Dispatcher. They call their
respective architectural handlers in the operating system.</p>
<p><em>Figure 3</em> shows the boot path for INIT and MCHK events.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Processor Family Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><strong>Figure 3. Itanium Processor Boot Path (INIT and MCHK)</strong></div></blockquote>
</div>
<div class="section" id="min-state-save-area">
<h2>12.3 Min-State Save Area<a class="headerlink" href="#min-state-save-area" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>When the Processor Abstraction Layer (PAL) hands control to the
dispatcher, it will supply the following:</div></blockquote>
<ul>
<li><p class="first">Unique handoff state in the registers</p>
</li>
<li><p class="first">A pointer, called the <em>min-state pointer,</em> to the minimum-state saved
buffer area</p>
<blockquote>
<div><p>This buffer is a unique per-processor save area that is registered
to each processor during the normal</p>
<p>OS boot path. The PI Architecture defines a unique, PI
Architecture-specific data pointer, <strong>EFI_PEI_MIN_STATE_DATA</strong>,
that is attached to this min-state pointer. This data structure is
defined in the next topic.</p>
<p><em>Figure 4</em> shows a typical organization of a min-state buffer. The
PEI Data Pointer references</p>
<p><strong>EFI_PEI_MIN_STATE_DATA</strong>.</p>
</div></blockquote>
</li>
</ul>
<p>July 2018 Version 1.7</p>
<p><strong>Special Paths Unique to the Itanium</strong></p>
<p><strong>Figure 4. Min-State Buffer Organization</strong></p>
<p><strong>Processor Family Platform Initialization Specification, Vol. 1</strong></p>
<div class="section" id="efi-pei-min-state-data">
<h3>EFI_PEI_MIN_STATE_DATA<a class="headerlink" href="#efi-pei-min-state-data" title="Permalink to this headline">¶</a></h3>
<p><strong>*Note:</strong> This data structure is for the Itanium*<sub>®</sub> <em>processor
family only.</em></p>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>A structure that encapsulates the Processor Abstraction Layer (PAL)
min-state data structure for purposes of firmware state storage and
reference.</p>
<p><strong>Prototype typedef struct {</strong></p>
<p><strong>UINT64</strong> <em>OsInitHandlerPointer;</em></p>
<p><strong>UINT64</strong> <em>OsInitHandlerGP;</em></p>
<p><strong>UINT64</strong> <em>OsInitHandlerChecksum;</em></p>
<p><strong>UINT64</strong> <em>OSMchkHandlerPointer;</em></p>
<p><strong>UINT64</strong> <em>OSMchkHandlerGP;</em></p>
<p><strong>UINT64</strong> <em>OSMchkHandlerChecksum;</em></p>
<p><strong>UINT64</strong> <em>PeimInitHandlerPointer;</em></p>
<p><strong>UINT64</strong> <em>PeimInitHandlerGP;</em></p>
<p><strong>UINT64</strong> <em>PeimInitHandlerChecksum;</em></p>
<p><strong>UINT64</strong> <em>PeimMchkHandlerPointer;</em></p>
<p><strong>UINT64</strong> <em>PeimMchkHandlerGP;</em></p>
<p><strong>UINT64</strong> <em>PeimMckhHandlerChecksum;</em></p>
<p><strong>UINT64</strong> <em>TypeOfOSBooted;</em></p>
<p><strong>UINT8</strong> <em>MinStateReserved[0x400];</em></p>
<p><strong>UINT8</strong> <em>OEMReserved[0x400];</em></p>
<p><strong>} EFI_PEI_MIN_STATE_DATA;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>OsInitHandlerPointer</em></p>
<p>The address of the operating system’s INIT handler. The INIT is a
restart type for the Itanium processor family.</p>
<p><em>OsInitHandlerGP</em></p>
<p>The value of the operating system’s INIT handler’s General Purpose
(GP) register. Per the calling conventions for the Itanium processor
family, the GP must be set before invoking the function.</p>
<p><em>OsInitHandlerChecksum</em></p>
<p>A 64-bit checksum across the contents of the operating system’s INIT
handler. This can be used by the PEI firmware to corroborate the
integrity of the INIT handler prior to invocation.</p>
<p><em>OSMchkHandlerPointer</em></p>
<p>The address of the operating system’s Machine Check (MCHK) handler.
MCHK is a restart type for the Itanium processor family.</p>
</div></blockquote>
<p>Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Special Paths Unique to
the Itanium</strong></p>
<blockquote>
<div><p><em>OSMchkHandlerGP</em></p>
<p>The value of the operating system’s MCHK handler’s GP register. Per
the calling conventions for the Itanium processor family, the GP
must be set before invoking the function.</p>
<p><em>OSMchkHandlerChecksum</em></p>
<p>A 64-bit checksum across the contents of the operating system’s MCHK
handler. This can be used by the PEI firmware to corroborate the
integrity of the MCHK handler prior to invocation.</p>
<p><em>PeimInitHandlerPointer</em></p>
<p>The address of the PEIM’s INIT handler.</p>
<p><em>PeimInitHandlerGP</em></p>
<p>The value of the PEIM’s INIT handler’s GP register. Per the calling
conventions for the Itanium processor family, the GP must be set
before invoking the function.</p>
<p><em>PeimInitHandlerChecksum</em></p>
<p>A 64-bit checksum across the contents of the PEIM’s INIT handler.
This can be used by the PEI firmware to corroborate the integrity of
the INIT handler prior to invocation.</p>
<p><em>PeimMchkHandlerPointer</em></p>
<p>The address of the PEIM’s MCHK handler.</p>
<p><em>PeimMchkHandlerGP</em></p>
<p>The value of the PEIM’s MCHK handler’s GP register. Per the calling
conventions for the Itanium processor family, the GP must be set
before invoking the function.</p>
<p><em>PeimMckhHandlerChecksum</em></p>
<p>A 64-bit checksum across the contents of the PEIM’s MCHK handler.
This can be used by the PEI firmware to corroborate the integrity of
the MCHK handler prior to invocation.</p>
<p><em>TypeOfOSBooted</em></p>
<p>Details the type of operating system that was originally booted.
This allows for different preliminary processing in firmware based
upon the target OS.</p>
<p><em>MinStateReserved</em></p>
<p>Reserved bytes that must not be interpreted by OEM firmware. Future
versions of PEI may choose to expand in this range.</p>
<p><em>OEMReserved</em></p>
<p>Reserved bytes for the OEM. PEI core components should not attempt
to interpret the contents of this region.</p>
<p><strong>Description</strong></p>
<p>A 64-bit PEI data pointer is defined at the beginning of the Itanium
processor family min-state data structure. This data pointer
references an <strong>EFI_PEI_MIN_STATE_DATA</strong> structure that is
defined above. This latter structure contains the entry points of
INIT and MCHK code blocks. The pointers</p>
</div></blockquote>
<p><strong>Processor Family Platform Initialization Specification, Vol. 1</strong></p>
<blockquote>
<div><p>are defined such that the INIT and MCHK code can be either written
as ROM-based PEIMs or as DXE drivers. The distinction between PEIM
and DXE driver are at the OEM’s discretion.</p>
<p>In Itanium® architecture, the PEI firmware must register a min-state
with the PAL. This min-state is memory when the PAL code can deposit
processor-specific information upon various restart events (INIT,
RESET, Machine Check). Upon receipt of INIT or MCHK, the PEI
firmware shall first invoke the PEIM INIT or MCHK handlers,
respectively, and then the OS INIT or MCHK handler. The min-state
data structure is a natural location from which to reference the PEI
data structure that contains these latter entry points.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="dispatching-itanium-processor-family-peims">
<h2>12.4 Dispatching Itanium Processor Family PEIMs<a class="headerlink" href="#dispatching-itanium-processor-family-peims" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The Itanium processor family dispatcher starts dispatching all the
PEIMs as it resolves the dependency grammar contained within their
headers. Because all Itanium processors enter into SALE_ENTRY for a
recovery check, some of the PEIMs will contain multiprocessor (MP)
code and will work on all processors. The behavior of a particular
PEIM that is dispatched depends on the following:</div></blockquote>
<ul>
<li><p class="first">Handoff state given by the Processor Abstraction Layer (PAL)</p>
</li>
<li><p class="first">The boot mode flag</p>
<blockquote>
<div><p>Once the processor runs some code and one of the recovery check PEIM
determines that the firmware needs to be recovered, it flips the
boot flag to recovery and invokes the dispatcher again in recovery
mode.</p>
<p>If it is a nonrecovery situation (normal boot), then the recovery
check PEIM wakes up all the processors and returns them to PAL-A for
further initialization. Note that when control for a normal boot
returns back to the PAL to run PAL-B code, all of the register
contents are lost. When control returns to the dispatcher, the PEIMs
gain control in the dispatched order and can determine the memory
topology (if needed in a platform implementation) by reading the
memory controller registers of the chipset. The PEIMs can then build
Hand-Off Blocks (HOBs).</p>
<p>When the first phase is done, there will be coherent memory on the
system that all the node processors can see. The system then begins
to execute the dispatcher in a second phase, during which it builds
HOBs. On a multinode system with many processors, the configuration
of memory may take several steps and therefore quite a bit of code.</p>
<p>When the second phase is done, the last PEIM will build DXE as
described in <em>“PEI to DXE Handoff” on page 208</em> and hand control to
the PI Architecture DXE phase for further initialization of the
platform.</p>
<p><em>Figure 5</em> depicts the initial flow between PAL-A , PAL-B, and the
PEI Foundation located at SALE_ENTRY point.</p>
</div></blockquote>
</li>
</ul>
<p>Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Special Paths Unique to
the Itanium</strong></p>
<p><a class="reference internal" href="media/image7.png"><img alt="image4" src="media/image7.png" style="width: 6.50000in; height: 7.05667in;" /></a></p>
<blockquote>
<div><strong>Figure 5. Boot Path in Itanium Processors</strong></div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
<div class="section" id="security-sec-phase-information">
<h1>13 Security (SEC) Phase Information<a class="headerlink" href="#security-sec-phase-information" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id335">
<h2>13.1 Introduction<a class="headerlink" href="#id335" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The Security (SEC) phase is the first phase in the PI Architecture
architecture and is responsible for the following:</div></blockquote>
<ul>
<li><p class="first">Handling all platform restart events</p>
</li>
<li><p class="first">Creating a temporary memory store</p>
</li>
<li><p class="first">Serving as the root of trust in the system</p>
</li>
<li><p class="first">Passing handoff information to the PEI Foundation</p>
<blockquote>
<div><p>In addition to the minimum architecturally required handoff
information, the SEC phase can pass optional information to the PEI
Foundation, such as the SEC Platform Information PPI or information
about the health of the processor.</p>
<p>The tasks listed above are common to all processor
microarchitectures. However, there are some additions or differences
between IA-32 and Itanium processors, which are discussed in
<em>“ProcessorSpecific Details” on page 232</em>.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="responsibilities">
<h2>13.2 Responsibilities<a class="headerlink" href="#responsibilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="handling-all-platform-restart-events">
<h3>13.2.1 Handling All Platform Restart Events<a class="headerlink" href="#handling-all-platform-restart-events" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The Security (SEC) phase is the unit of processing that handles all
platform restart events, including the following:</div></blockquote>
<ul>
<li><p class="first">Applying power to the system from an unpowered state</p>
</li>
<li><p class="first">Restarting the system from an active state</p>
</li>
<li><p class="first">Receiving various exception conditions</p>
<blockquote>
<div><p>The SEC phase is responsible for aggregating any state information
so that some PEIM can deduce the health of the processor upon the
respective restart.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="creating-a-temporary-memory-store">
<h3>13.2.2 Creating a Temporary Memory Store<a class="headerlink" href="#creating-a-temporary-memory-store" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The Security (SEC) phase is also responsible for creating some
temporary memory store. This temporary memory store can include but
is not limited to programming the processor cache to behave as a
linear store of memory. This cache behavior is referred to as “no
evictions mode” in that access to the cache should always represent
a hit and not engender an eviction to the main memory backing store;
this “no eviction” is important in that during this early phase of
platform evolution, the main memory has not been configured and such
as eviction could engender a platform failure.</div></blockquote>
<p>228</p>
<p><strong>Platform Initialization Specification, Vol. 1 Security (SEC) Phase
Information</strong></p>
</div>
<div class="section" id="serving-as-the-root-of-trust-in-the-system">
<h3>13.2.3 Serving As the Root of Trust in the System<a class="headerlink" href="#serving-as-the-root-of-trust-in-the-system" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Finally, the Security (SEC) phase represents the root of trust in
the system. Any inductive security design in which the integrity of
the subsequent module to gain control is corroborated by the caller
must have a root, or “first,” component. For any PI Architecture
deployment, the SEC phase represents the initial code that takes
control of the system. As such, a platform or technology deployment
may choose to authenticate the PEI Foundation from the SEC phase
before invoking the PEI Foundation.</div></blockquote>
</div>
<div class="section" id="passing-handoff-information-to-the-pei-foundation">
<h3>13.2.4 Passing Handoff Information to the PEI Foundation<a class="headerlink" href="#passing-handoff-information-to-the-pei-foundation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>Regardless of the other responsibilities listed in this section, the
Security (SEC) phase’s final responsibility is to convey the
following handoff information to the PEI:</div></blockquote>
<ul>
<li><p class="first">State of the platform</p>
</li>
<li><p class="first">Location and size of the Boot Firmware Volume (BFV)</p>
</li>
<li><p class="first">Location and size of the temporary RAM</p>
</li>
<li><p class="first">Location and size of the stack</p>
</li>
<li><p class="first">Optionally, one or more HOBs via the <strong>EFI_SEC_HOB_DATA_PPI</strong>.</p>
<blockquote>
<div><p>This handoff information listed above is passed to the PEI as
arguments to the PEI Foundation entry point described in section
5.2.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="sec-platform-information-ppi">
<h2>13.3 SEC Platform Information PPI<a class="headerlink" href="#sec-platform-information-ppi" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Handoff information is passed from the Security (SEC) phase to the
PEI Foundation using the</p>
<p><strong>EFI_SEC_PEI_HAND_OFF</strong> structure and the list of PPI
descriptors passed to the PEI entry point. One of these PPIs,
<strong>EFI_SEC_PLATFORM_INFORMATION_PPI</strong>, can be used to pass
handoff information from SEC to the PEI Foundation. This PPI
abstracts platform-specific information that the PEI Foundation
needs to discover where to begin dispatching PEIMs.</p>
</div></blockquote>
</div>
<div class="section" id="sec-hob-data-ppi">
<h2>13.4 SEC HOB Data PPI<a class="headerlink" href="#sec-hob-data-ppi" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>HOB data can be passed forward from the SEC phase to PEI or DXE
consumers using HOBs. If the <strong>EFI_SEC_HOB_DATA_PPI</strong> is in the
list of PPIs passed to the PEI entry point, the PEI Foundation will
call the <strong>GetHobs()</strong> member function and installed all HOBs
returned into the HOB list. It does this after installing all PPIs
passed from SEC into the PPI database and before dispatching any
PEIMs.</div></blockquote>
</div>
<div class="section" id="health-flag-bit-format">
<h2>13.5 Health Flag Bit Format<a class="headerlink" href="#health-flag-bit-format" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The Health flag contains information that is generated by microcode,
hardware, and/or the Itanium processor Processor Abstraction Layer
(PAL) code about the state of the processor upon reset. Type
<strong>EFI_HEALTH_FLAGS</strong> is defined in</p>
<p><strong>SEC_PLATFORM_INFORMATION_PPI.PlatformInformation()</strong>.</p>
</div></blockquote>
<p><strong>Security (SEC) Phase Information Platform Initialization
Specification, Vol. 1</strong></p>
<blockquote>
<div><p>In an Itanium®-based system, the Health flag is passed from PAL-A
after restarting. It is the means by which the PAL conveys the state
of the processor to the firmware, such as PI. The handoff state is
separated between the PAL and PI because the code is provided by
different vendors; Intel provides the PAL and various OEMs design
the PI firmware.</p>
<p>The Health flag is used by both IA-32 and Itanium architectures, but
<em>Tested</em> (Te) is the only common bit. IA-32 has the built-in
self-test (BIST), but none of the other capabilities.</p>
<p>Figure 6 depicts the bit format in the Health flag.</p>
</div></blockquote>
<p><a class="reference internal" href="media/image9.jpg"><img alt="image5" src="media/image9.jpg" style="width: 6.50000in; height: 2.21265in;" /></a></p>
<blockquote>
<div><p><em>Table 24</em> explains the bit fields in the Health flag. IA-32 ignores
all bits except <em>Tested</em> (Te).</p>
<p><strong>Table 24. Health Flag Bit Field Description</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="18%" />
<col width="6%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Field</strong></th>
<th class="head"><strong>Parameter Name in EFI_HEALTH_FLAGS</strong></th>
<th class="head"><strong>Bit #</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>State</td>
<td><em>Status</em></td>
<td>0:1</td>
<td>A 2-bit field indicating self-test state after reset. For more information, see <em>“SelfTest State Parameter” on page 231</em>.</td>
</tr>
<tr class="row-odd"><td>Te</td>
<td><em>Tested</em></td>
<td>2</td>
<td>A 1-bit field indicating whether testing has occurred. If this field is zero, the processor has not been tested, and no further fields in the self-test State parameter are valid.</td>
</tr>
<tr class="row-even"><td>Vm</td>
<td><em>VirtualMemoryUnavailable</em></td>
<td>16</td>
<td>A 1-bit field. If set to 1, indicates that virtual memory features are not available.</td>
</tr>
<tr class="row-odd"><td>Ia</td>
<td><em>Ia32ExecutionUnavailable</em></td>
<td>17</td>
<td>A 1-bit field. If set to 1, indicates that IA-32 execution is not available.</td>
</tr>
<tr class="row-even"><td>Fp</td>
<td><em>FloatingPointUnavailable</em></td>
<td>18</td>
<td>A 1-bit field. If set to 1, indicates that the floating point unit is not available.</td>
</tr>
</tbody>
</table>
<p>230 Version 1.7</p>
<p><strong>Platform Initialization Specification, Vol. 1 Security (SEC) Phase
Information</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="8%" />
<col width="3%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Mf</td>
<td><em>MiscFeaturesUnavailable</em></td>
<td>19</td>
<td>A 1-bit field. If set to 1, indicates miscellaneous functional failure other than vm, ia, or fp. The test status field provides additional information on test failures when the State field returns a value of performance restricted or functionally restricted. The value returned is implementation dependent.</td>
</tr>
</tbody>
</table>
<div class="section" id="self-test-state-parameter">
<h3>13.5.1 Self-Test State Parameter<a class="headerlink" href="#self-test-state-parameter" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Self-test state parameters are defined in the same format for IA-32
Intel® processors and the Intel® Itanium® processor family. Some of
the test status bits may not be relevant to IA-32 processors. In
that case, these bits will read <strong>NULL</strong> on IA-32 processors.</p>
<p><em>Table 25</em> indicates the meanings for various values of the
self-test State parameter (bits 0:1) of the Health flag.</p>
<p><strong>Table 25. Self-Test State Bit Values</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>State</strong></th>
<th class="head"><strong>Value</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Catastrophic Failure</td>
<td>N/A</td>
<td>Processor is not executing.</td>
</tr>
<tr class="row-odd"><td>Healthy</td>
<td>00</td>
<td>No failure in functionality or performance.</td>
</tr>
<tr class="row-even"><td>Performance Restricted</td>
<td>01</td>
<td>No failure in functionality but performance is restricted.</td>
</tr>
<tr class="row-odd"><td>Functionally Restricted</td>
<td>10</td>
<td>Some code may run but functionality is restricted and performance may also be affected.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>If the state field indicates that the processor is functionally
restricted, then the vm, ia, and fp fields in the Health flag
specify additional information about the functional failure. See
<em>Table 24</em> for a description of these fields.</p>
<p>To further qualify “Functionally Restricted,” the following
requirements will be met:</p>
</div></blockquote>
<ul class="simple">
<li>The processor or PAL (for the Itanium processor family) has detected
and isolated the failing component so that it will not be used.</li>
<li>The processor must have at least one functioning memory unit,
arithmetic logic unit (ALU), shifter, and branch unit.</li>
<li>The floating-point unit may be disabled.</li>
<li>For the Itanium processor family, the Register Stack Engine (RSE) is
not required to work, but register renaming logic must work properly.</li>
<li>The paths between the processor-controlled caches and the register
files must work during the tests.</li>
<li>Loads from the firmware address space must work correctly.</li>
</ul>
<p>Version 1.7 July 2018</p>
<p><strong>Security (SEC) Phase Information Platform Initialization
Specification, Vol. 1</strong></p>
</div>
</div>
<div class="section" id="processor-specific-details">
<h2>13.6 Processor-Specific Details<a class="headerlink" href="#processor-specific-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sec-phase-in-ia-32-intel-architecture">
<h3>13.6.1 SEC Phase in IA-32 Intel Architecture<a class="headerlink" href="#sec-phase-in-ia-32-intel-architecture" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>In 32-bit Intel® architecture (IA-32), the Security (SEC) phase of
the PI Architecture is responsible for several activities:</div></blockquote>
<ul>
<li><p class="first">Locating the PEI Foundation</p>
</li>
<li><p class="first">Passing control directly to PEI using an architecturally defined
handoff state</p>
</li>
<li><p class="first">Initializing processor-controlled memory resources, such as the
processor data cache, that can be used as a linear extent of memory
for a call stack (if supported)</p>
<blockquote>
<div><p><em>Figure 7</em> below shows the steps completed during PEI initialization
for IA-32.</p>
</div></blockquote>
</li>
</ul>
<p><a class="reference internal" href="media/image11.png"><img alt="image6" src="media/image11.png" style="width: 6.50000in; height: 1.41265in;" /></a></p>
</div>
<div class="section" id="sec-phase-in-the-itanium-processor-family">
<h3>13.6.2 SEC Phase in the Itanium Processor Family<a class="headerlink" href="#sec-phase-in-the-itanium-processor-family" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Itanium architecture contains enough hooks to authenticate the PAL-A
and PAL-B code distributed by the processor vendor.</p>
<p>The internal microcode on the processor silicon that starts up on a
power-good reset finds the first layer of processor abstraction code
(called PAL-A) located in the Boot Firmware Volume (BFV) using
architecturally defined pointers in the BFV. It is the
responsibility of this microcode to authenticate that the PAL-A code
layer from the processor vendor has not been tampered.</p>
<p>If the authentication of the PAL-A layer passes, then control passes
on to the PAL-A layer. The PAL-A layer then authenticates the next
layer of processor abstraction code (called PAL-B) before passing
control to it.</p>
<p>In addition, the SEC phase of the PI Architecture is also
responsible for locating the PEI Foundation and verifying its
authenticity.</p>
<p><em>Figure 8</em> summarizes the SEC phase in the Itanium® processor
family.</p>
</div></blockquote>
<p>232 Version 1.7 <strong>Platform Initialization Specification, Vol. 1 Security
(SEC) Phase Information</strong></p>
<p><a class="reference internal" href="media/image13.png"><img alt="image7" src="media/image13.png" style="width: 6.50000in; height: 2.12333in;" /></a></p>
<blockquote>
<div><strong>Figure 8. Security (SEC) Phase in the Itanium Processor Family</strong></div></blockquote>
<p>Version 1.7 July 2018</p>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
</div>
<div class="section" id="dependency-expression-grammar">
<h1>14 Dependency Expression Grammar<a class="headerlink" href="#dependency-expression-grammar" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id336">
<h2>14.1 Dependency Expression Grammar<a class="headerlink" href="#id336" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>This topic contains an example BNF grammar for a PEIM dependency
expression compiler that converts a dependency expression source
file into a dependency section of a PEIM stored in a firmware
volume.</div></blockquote>
<div class="section" id="example-dependency-expression-bnf-grammar">
<h3>14.1.1 Example Dependency Expression BNF Grammar<a class="headerlink" href="#example-dependency-expression-bnf-grammar" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>&lt;depex&gt; ::= &lt;bool&gt;</p>
<p>&lt;bool&gt; ::= &lt;bool&gt; AND &lt;term&gt;</p>
<p>| &lt;bool&gt; OR &lt;term&gt;</p>
<p>| &lt;term&gt;</p>
<p>&lt;term&gt; ::= NOT &lt;factor&gt;</p>
<p>| &lt;factor&gt;</p>
<p>&lt;factor&gt; ::= &lt;bool&gt;</p>
<p>| TRUE</p>
<p>| FALSE</p>
<p>| GUID</p>
<p>| END</p>
<p>&lt;guid&gt; ::= ‘{‘ &lt;hex32&gt; ‘,’ &lt;hex16&gt; ‘,’ &lt;hex16&gt; ‘,’</p>
<p>&lt;hex8&gt; ‘,’ &lt;hex8&gt; ‘,’ &lt;hex8&gt; ‘,’ &lt;hex8&gt; ‘,’</p>
<p>&lt;hex8&gt; ‘,’ &lt;hex8&gt; ‘,’ &lt;hex8&gt; ‘,’ &lt;hex8&gt; ’}’</p>
<p>&lt;hex32&gt; ::= &lt;hexprefix&gt; &lt;hexvalue&gt;</p>
<p>&lt;hex16&gt; ::= &lt;hexprefix&gt; &lt;hexvalue&gt;</p>
<p>&lt;hex8&gt; ::= &lt;hexprefix&gt; &lt;hexvalue&gt;</p>
<p>&lt;hexprefix&gt;::= ‘0’ ‘x’</p>
<p>| ‘0’ ‘X’</p>
<p>&lt;hexvalue&gt; ::= &lt;hexdigit&gt; &lt;hexvalue&gt;</p>
<p>| &lt;hexdigit&gt;</p>
<p>&lt;hexdigit&gt; ::= [0-9]</p>
<p>| [a-f]</p>
<p>| [A-F]</p>
</div></blockquote>
<p><strong>Dependency Expression Grammar</strong></p>
</div>
<div class="section" id="sample-dependency-expressions">
<h3>14.1.2 Sample Dependency Expressions<a class="headerlink" href="#sample-dependency-expressions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The following contains three examples of source statements using the
BNF grammar from above along with the opcodes, operands, and binary
encoding that a dependency expression compiler would generate from
these source statements.</p>
<p>//</p>
<p>// Source</p>
<p>//</p>
<p>EFI_PEI_CPU_IO_PPI_GUID AND
EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI_GUID END</p>
<p>//</p>
<p>// Opcodes, Operands, and Binary Encoding</p>
<p>//</p>
<p>ADDR BINARY MNEMONIC</p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
</div>
<div class="section" id="te-image">
<h1>15 TE Image<a class="headerlink" href="#te-image" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id337">
<h2>15.1 Introduction<a class="headerlink" href="#id337" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>The <em>Terse Executable</em> (TE) image format was created as a mechanism
to reduce the overhead of the PE/COFF headers in PE32/PE32+ images,
resulting in a corresponding reduction of image sizes for
executables running in the PI Architecture environment. Reducing
image size provides an opportunity for use of a smaller system flash
part.</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>OPTIONAL Header</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>AddressOfEntryPoint</td>
<td>Address of entry point relative to image base. 4 bytes in both optional header and TE header</td>
</tr>
<tr class="row-odd"><td>BaseOfCode</td>
<td>Offset from image base to the start of the code section. 4 bytes in both optional header and TE header</td>
</tr>
<tr class="row-even"><td>ImageBase</td>
<td><p class="first">Image’s linked address. 4 bytes in OptionalHeader32, 8 bytes in</p>
<p class="last">OptionalHeader64, and 8 bytes in TE header</p>
</td>
</tr>
</tbody>
</table>
<blockquote>
<div>TE images, both drivers and applications, are created as PE32 (or
PE32+) executables. PE32 is a generic executable image format that
is intended to support multiple target systems, processors, and
operating systems. As a result, the headers in the image contain
information that is not necessarily applicable to all target
systems. In an effort to reduce image size, a new executable image
header (TE) was created that includes only those fields from the
PE/COFF headers required for execution under the PI Architecture.
Since this header contains the information required for execution of
the image, it can replace the PE/COFF headers from the original
image. This specification defines the TE header, the fields in the
header, and how they are used in the PI Architecture’s execution
environment.</div></blockquote>
</div>
<div class="section" id="pe32-headers">
<h2>15.2 PE32 Headers<a class="headerlink" href="#pe32-headers" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A PE file header, as described in the <em>Microsoft Portable Executable
and Common Object File Format Specification</em>, contains an MS-DOS*
stub, a PE signature, a COFF header, an optional header, and section
headers. For successful execution, PEIMs in the PI Architecture
require very little of the data from these headers, and in fact the
MS-DOS stub and PE signature are not required at all.</p>
<p>See <em>Table 26</em> and <em>Table 27</em> for the necessary fields and their
descriptions.</p>
<p><strong>Table 26. COFF Header Fields Required for TE Images</strong></p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>COFF Header</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Machine</td>
<td>Target machine identifier. 2 bytes in both COFF header and TE header</td>
</tr>
<tr class="row-odd"><td>NumberOfSections</td>
<td>Number of sections/section headers. 2 bytes in COFF header, 1 byte in TE header</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table 27. Optional Header Fields Required for TE Images</strong></div></blockquote>
<p><strong>TE Image</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Subsystem</td>
<td>Subsystem required to run the image. 2 bytes in optional header, 1 byte in TE header</td>
</tr>
</tbody>
</table>
<p><strong>TE Image Platform Initialization Specification, Vol. 1</strong></p>
<div class="section" id="te-header">
<h3>TE Header<a class="headerlink" href="#te-header" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><strong>Summary</strong></p>
<p>To reduce the overhead of PE/COFF headers in the PI Architecture’s
environment, a minimal (TE) header can be defined that includes only
those fields required for execution in the PI Architecture. This
header can then be used to replace the original headers at the start
of the original image.</p>
<p><strong>Prototype typedef struct {</strong></p>
<p><strong>UINT16</strong> <em>Signature;</em></p>
<p><strong>UINT16</strong> <em>Machine;</em></p>
<p><strong>UINT8</strong> <em>NumberOfSections;</em></p>
<p><strong>UINT8</strong> <em>Subsystem;</em></p>
<p><strong>UINT16</strong> <em>StrippedSize;</em></p>
<p><strong>UINT32</strong> <em>AddressOfEntryPoint;</em></p>
<p><strong>UINT32</strong> <em>BaseOfCode;</em></p>
<p><strong>UINT64</strong> <em>ImageBase;</em></p>
<p><strong>EFI_IMAGE_DATA_DIRECTORY</strong> <em>DataDirectory[2];</em> <strong>}
EFI_TE_IMAGE_HEADER;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>Signature</em></p>
<p>TE image signature</p>
<p><em>Machine</em></p>
<p>Target machine, as specified in the original image’s file header</p>
<p><em>NumberOfSections</em></p>
<p>Number of sections, as specified in the original image’s file header</p>
<p><em>Subsystem</em></p>
<p>Target subsystem, as specified in the original optional header</p>
<p><em>StrippedSize</em></p>
<p>Number of bytes removed from the base of the original image</p>
<p><em>AddressOfEntryPoint</em></p>
<p>Address of the entry point to the driver, as specified in the
original image’s optional header</p>
<p><em>BaseOfCode</em></p>
<p>Base of the code, as specified in the original image’s optional
header</p>
<p><em>ImageBase</em></p>
<p>Image base, as specified in the original image’s optional header
(0-extended to 64-bits for PE32 images)</p>
</div></blockquote>
<p>238 Version 1.7 <strong>TE Image</strong></p>
<blockquote>
<div><p><em>DataDirectory</em></p>
<p>Directory entries for base relocations and the debug directory from
the original image’s corresponding directory entries. See “Related
Definitions” below.</p>
</div></blockquote>
<p><strong>Field Descriptions</strong></p>
<blockquote>
<div><p>In the <strong>EFI_TE_IMAGE HEADER</strong>, the <em>Machine, NumberOfSections,
Subsystem, AddressOfEntryPoint, BaseOfCode</em>, and <em>ImageBase</em> all
come directly from the original</p>
<p>PE headers to enable partial reconstitution of the original headers
if necessary.</p>
<p>The 2-byte <em>Signature</em> should be set to
<strong>EFI_TE_IMAGE_HEADER_SIGNATURE</strong> to designate the image as TE,
as opposed to the “MZ” signature at the start of standard PE/COFF
images.</p>
<p>The <em>StrippedSize</em> should be set to the number of bytes removed from
the start of the original image, which will typically include the
MS-DOS, COFF, and optional headers, as well as the section headers.
This size can be used by image loaders and tools to make appropriate
adjustments to the other fields in the TE image header. Note that
<em>StrippedSize</em> does not take into account the size</p>
<p>of the TE image header that will be added to the image. That is to
say, the delta in the total image size when converted to TE is
<em>StrippedSize</em> – sizeof (<strong>EFI_TE_IMAGE_HEADER</strong>). This will
typically need to be taken into account by tools using the fields in
the TE header.</p>
<p>The <em>DataDirectory</em> array contents are copied directly from the base
relocations and debug directory entries in the original optional
header data directories. This image format also assumes that file
alignment is equal to section alignment.</p>
</div></blockquote>
<p><strong>Related Definitions</strong></p>
<blockquote>
<div><p><strong>//*****************************************************</strong></p>
<p><strong>//EFI_IMAGE_DATA_DIRECTORY</strong></p>
<p><strong>//*****************************************************
typedef struct {</strong></p>
<p><strong>UINT32 VirtualAddress;</strong></p>
<p><strong>UINT32 Size;</strong></p>
<p><strong>} EFI_IMAGE_DATA_DIRECTORY;</strong></p>
<p><strong>#define EFI_TE_IMAGE_DIRECTORY_ENTRY_BASERELOC 0</strong></p>
<p><a href="#id338"><span class="problematic" id="id339">**</span></a>#define EFI_TE_IMAGE_DIRECTORY_ENTRY_DEBUG 1 **</p>
<p><strong>#define EFI_TE_IMAGE_HEADER_SIGNATURE 0x5A56 // “VZ”</strong></p>
</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
</div>
<div class="section" id="te-image-creation">
<h1>16 TE Image Creation<a class="headerlink" href="#te-image-creation" title="Permalink to this headline">¶</a></h1>
<p><strong>16.1 Introduction</strong></p>
<blockquote>
<div>This section describes the tool requirements to create a TE image.</div></blockquote>
<div class="section" id="te-image-utility-requirements">
<h2>16.2 TE Image Utility Requirements<a class="headerlink" href="#te-image-utility-requirements" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>A utility that creates TE images from standard PE/COFF images must
be able to do the following:</div></blockquote>
<ul>
<li><p class="first">Create an <strong>EFI_TE_IMAGE_HEADER</strong> in memory</p>
</li>
<li><p class="first">Parse the PE/COFF headers in an existing image and extract the
necessary fields to fill in the</p>
<blockquote>
<div><p><strong>EFI_TE_IMAGE_HEADER</strong></p>
</div></blockquote>
</li>
<li><p class="first">Fill in the signature and stripped size fields in the
<strong>EFI_TE_IMAGE_HEADER</strong></p>
</li>
<li><p class="first">Write out the <strong>EFI_TE_IMAGE_HEADER</strong> to a new binary file</p>
</li>
<li><p class="first">Write out the contents of the original image, less the stripped
headers, to the output file</p>
<blockquote>
<div><p>Since some fields from the PE/COFF headers have a smaller
corresponding field in the TE image header, the utility must be able
to recognize if the original value from the PE/COFF header does not
fit in the TE header. In this case, the original image is not a
candidate for conversion to TE image format.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="te-image-relocations">
<h2>16.3 TE Image Relocations<a class="headerlink" href="#te-image-relocations" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>Relocation fix ups in TE images are not modified by the TE image
creation process. Therefore, if a TE image is to be relocated, the
loader/relocator must take into consideration the stripped size and
size of a TE image header when applying fix ups.</div></blockquote>
<p><strong>Platform Initialization Specification, Vol. 1</strong></p>
</div>
</div>
<div class="section" id="te-image-loading">
<h1>17 TE Image Loading<a class="headerlink" href="#te-image-loading" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id340">
<h2>17.1 Introduction<a class="headerlink" href="#id340" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>This section describes the use of the TE image and how embedded,
execute-in-place environments can invoke these images.</div></blockquote>
</div>
<div class="section" id="xip-images">
<h2>17.2 XIP Images<a class="headerlink" href="#xip-images" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>For execute-in-place (XIP) images that do not require relocations,
loading a TE image simply requires that the loader adjust the
image’s entry point from the value specified in the</p>
<p><strong>EFI_TE_IMAGE_HEADER</strong>. For example, if the image (and thus the
TE header) resides at memory location <em>LoadedImageAddress</em>, then the
actual entry for the driver is computed as follows:</p>
<p><em>EntryPoint = LoadedImageAddress + sizeof
(</em><strong>EFI_TE_IMAGE_HEADER</strong><em>) +</em></p>
<p><em>((</em><strong>EFI_TE_IMAGE_HEADER *</strong><em>)LoadedImageAddress)–&gt;</em></p>
<p><em>AddressOfEntryPoint – ((</em><strong>EFI_TE_IMAGE_HEADER *</strong><em>)</em></p>
<p><em>LoadedImageAddress)–&gt;StrippedSize;</em></p>
</div></blockquote>
</div>
<div class="section" id="relocated-images">
<h2>17.3 Relocated Images<a class="headerlink" href="#relocated-images" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>To successfully load and relocate a TE image requires the same
operations as required for XIP code. However, for images that can be
relocated, the image loader must make adjustments for all the
relocation fix ups performed. Details on this operation are beyond
the scope of this document, but suffice it to say that the
adjustments will be computed in a manner similar to the <em>EntryPoint</em>
adjustment made in XIP Images.</div></blockquote>
</div>
<div class="section" id="pic-images">
<h2>17.4 PIC Images<a class="headerlink" href="#pic-images" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>A TE Image is Position Independent Code (PIC) if it can be executed
in flash and shadowed to memory without any fix ups. In this case,
the TE Image Relocation Data Directory Entry Virtual Address is
non-zero, but the Relocation Data Directory Size is zero.</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, OTC-TCS Documentation Template.
      Last updated on Jul 24, 2018.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>